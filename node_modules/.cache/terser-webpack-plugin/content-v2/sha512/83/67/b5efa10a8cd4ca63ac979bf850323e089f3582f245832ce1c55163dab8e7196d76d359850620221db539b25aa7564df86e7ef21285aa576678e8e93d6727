{"code":"(this[\"webpackJsonp@dev-book/local-client\"]=this[\"webpackJsonp@dev-book/local-client\"]||[]).push([[170],{347:function(n,t){Prism.languages.graphql={comment:/#.*/,description:{pattern:/(?:\"\"\"(?:[^\"]|(?!\"\"\")\")*\"\"\"|\"(?:\\\\.|[^\\\\\"\\r\\n])*\")(?=\\s*[a-z_])/i,greedy:!0,alias:\"string\",inside:{\"language-markdown\":{pattern:/(^\"(?:\"\")?)(?!\\1)[\\s\\S]+(?=\\1$)/,lookbehind:!0,inside:Prism.languages.markdown}}},string:{pattern:/\"\"\"(?:[^\"]|(?!\"\"\")\")*\"\"\"|\"(?:\\\\.|[^\\\\\"\\r\\n])*\"/,greedy:!0},number:/(?:\\B-|\\b)\\d+(?:\\.\\d+)?(?:e[+-]?\\d+)?\\b/i,boolean:/\\b(?:true|false)\\b/,variable:/\\$[a-z_]\\w*/i,directive:{pattern:/@[a-z_]\\w*/i,alias:\"function\"},\"attr-name\":{pattern:/[a-z_]\\w*(?=\\s*(?:\\((?:[^()\"]|\"(?:\\\\.|[^\\\\\"\\r\\n])*\")*\\))?:)/i,greedy:!0},\"atom-input\":{pattern:/[A-Z]\\w*Input(?=!?.*$)/m,alias:\"class-name\"},scalar:/\\b(?:Boolean|Float|ID|Int|String)\\b/,constant:/\\b[A-Z][A-Z_\\d]*\\b/,\"class-name\":{pattern:/(\\b(?:enum|implements|interface|on|scalar|type|union)\\s+|&\\s*|:\\s*|\\[)[A-Z_]\\w*/,lookbehind:!0},fragment:{pattern:/(\\bfragment\\s+|\\.{3}\\s*(?!on\\b))[a-zA-Z_]\\w*/,lookbehind:!0,alias:\"function\"},\"definition-mutation\":{pattern:/(\\bmutation\\s+)[a-zA-Z_]\\w*/,lookbehind:!0,alias:\"function\"},\"definition-query\":{pattern:/(\\bquery\\s+)[a-zA-Z_]\\w*/,lookbehind:!0,alias:\"function\"},keyword:/\\b(?:directive|enum|extend|fragment|implements|input|interface|mutation|on|query|repeatable|scalar|schema|subscription|type|union)\\b/,operator:/[!=|&]|\\.{3}/,\"property-query\":/\\w+(?=\\s*\\()/,object:/\\w+(?=\\s*\\{)/,punctuation:/[!(){}\\[\\]:=,]/,property:/\\w+/},Prism.hooks.add(\"after-tokenize\",(function(n){if(\"graphql\"===n.language)for(var t=n.tokens.filter((function(n){return\"string\"!==typeof n&&\"comment\"!==n.type&&\"scalar\"!==n.type})),e=0;e<t.length;){var a=t[e++];if(\"keyword\"===a.type&&\"mutation\"===a.content){var i=[];if(c([\"definition-mutation\",\"punctuation\"])&&\"(\"===l(1).content){e+=2;var r=f(/^\\($/,/^\\)$/);if(-1===r)continue;for(;e<r;e++){var o=l(0);\"variable\"===o.type&&(b(o,\"variable-input\"),i.push(o.content))}e=r+1}if(c([\"punctuation\",\"property-query\"])&&\"{\"===l(0).content&&(e++,b(l(0),\"property-mutation\"),i.length>0)){var s=f(/^\\{$/,/^\\}$/);if(-1===s)continue;for(var u=e;u<s;u++){var p=t[u];\"variable\"===p.type&&i.indexOf(p.content)>=0&&b(p,\"variable-input\")}}}}function l(n){return t[e+n]}function c(n,t){t=t||0;for(var e=0;e<n.length;e++){var a=l(e+t);if(!a||a.type!==n[e])return!1}return!0}function f(n,a){for(var i=1,r=e;r<t.length;r++){var o=t[r],s=o.content;if(\"punctuation\"===o.type&&\"string\"===typeof s)if(n.test(s))i++;else if(a.test(s)&&0===--i)return r}return-1}function b(n,t){var e=n.alias;e?Array.isArray(e)||(n.alias=e=[e]):n.alias=e=[],e.push(t)}}))}}]);","name":"static/js/170.eed11a10.chunk.js","map":{"version":3,"names":["this","push","module","exports","Prism","languages","graphql","comment","description","pattern","greedy","alias","inside","lookbehind","markdown","string","number","boolean","variable","directive","scalar","constant","fragment","keyword","operator","object","punctuation","property","hooks","add","env","language","validTokens","tokens","filter","token","type","currentIndex","length","startToken","content","inputVariables","isTokenType","getToken","definitionEnd","findClosingBracket","t","addAlias","mutationEnd","i","varToken","indexOf","offset","types","open","close","stackHeight","test","aliases","Array","isArray"],"sources":["static/js/170.eed11a10.chunk.js"],"mappings":"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"},"input":"(this[\"webpackJsonp@dev-book/local-client\"] = this[\"webpackJsonp@dev-book/local-client\"] || []).push([[170],{\n\n/***/ 347:\n/***/ (function(module, exports) {\n\nPrism.languages.graphql = {\n  'comment': /#.*/,\n  'description': {\n    pattern: /(?:\"\"\"(?:[^\"]|(?!\"\"\")\")*\"\"\"|\"(?:\\\\.|[^\\\\\"\\r\\n])*\")(?=\\s*[a-z_])/i,\n    greedy: true,\n    alias: 'string',\n    inside: {\n      'language-markdown': {\n        pattern: /(^\"(?:\"\")?)(?!\\1)[\\s\\S]+(?=\\1$)/,\n        lookbehind: true,\n        inside: Prism.languages.markdown\n      }\n    }\n  },\n  'string': {\n    pattern: /\"\"\"(?:[^\"]|(?!\"\"\")\")*\"\"\"|\"(?:\\\\.|[^\\\\\"\\r\\n])*\"/,\n    greedy: true\n  },\n  'number': /(?:\\B-|\\b)\\d+(?:\\.\\d+)?(?:e[+-]?\\d+)?\\b/i,\n  'boolean': /\\b(?:true|false)\\b/,\n  'variable': /\\$[a-z_]\\w*/i,\n  'directive': {\n    pattern: /@[a-z_]\\w*/i,\n    alias: 'function'\n  },\n  'attr-name': {\n    pattern: /[a-z_]\\w*(?=\\s*(?:\\((?:[^()\"]|\"(?:\\\\.|[^\\\\\"\\r\\n])*\")*\\))?:)/i,\n    greedy: true\n  },\n  'atom-input': {\n    pattern: /[A-Z]\\w*Input(?=!?.*$)/m,\n    alias: 'class-name'\n  },\n  'scalar': /\\b(?:Boolean|Float|ID|Int|String)\\b/,\n  'constant': /\\b[A-Z][A-Z_\\d]*\\b/,\n  'class-name': {\n    pattern: /(\\b(?:enum|implements|interface|on|scalar|type|union)\\s+|&\\s*|:\\s*|\\[)[A-Z_]\\w*/,\n    lookbehind: true\n  },\n  'fragment': {\n    pattern: /(\\bfragment\\s+|\\.{3}\\s*(?!on\\b))[a-zA-Z_]\\w*/,\n    lookbehind: true,\n    alias: 'function'\n  },\n  'definition-mutation': {\n    pattern: /(\\bmutation\\s+)[a-zA-Z_]\\w*/,\n    lookbehind: true,\n    alias: 'function'\n  },\n  'definition-query': {\n    pattern: /(\\bquery\\s+)[a-zA-Z_]\\w*/,\n    lookbehind: true,\n    alias: 'function'\n  },\n  'keyword': /\\b(?:directive|enum|extend|fragment|implements|input|interface|mutation|on|query|repeatable|scalar|schema|subscription|type|union)\\b/,\n  'operator': /[!=|&]|\\.{3}/,\n  'property-query': /\\w+(?=\\s*\\()/,\n  'object': /\\w+(?=\\s*\\{)/,\n  'punctuation': /[!(){}\\[\\]:=,]/,\n  'property': /\\w+/\n};\nPrism.hooks.add('after-tokenize', function afterTokenizeGraphql(env) {\n  if (env.language !== 'graphql') {\n    return;\n  }\n\n  /**\n   * get the graphql token stream that we want to customize\n   *\n   * @typedef {InstanceType<import(\"./prism-core\")[\"Token\"]>} Token\n   * @type {Token[]}\n   */\n  var validTokens = env.tokens.filter(function (token) {\n    return typeof token !== 'string' && token.type !== 'comment' && token.type !== 'scalar';\n  });\n  var currentIndex = 0;\n\n  /**\n   * Returns whether the token relative to the current index has the given type.\n   *\n   * @param {number} offset\n   * @returns {Token | undefined}\n   */\n  function getToken(offset) {\n    return validTokens[currentIndex + offset];\n  }\n\n  /**\n   * Returns whether the token relative to the current index has the given type.\n   *\n   * @param {readonly string[]} types\n   * @param {number} [offset=0]\n   * @returns {boolean}\n   */\n  function isTokenType(types, offset) {\n    offset = offset || 0;\n    for (var i = 0; i < types.length; i++) {\n      var token = getToken(i + offset);\n      if (!token || token.type !== types[i]) {\n        return false;\n      }\n    }\n    return true;\n  }\n\n  /**\n   * Returns the index of the closing bracket to an opening bracket.\n   *\n   * It is assumed that `token[currentIndex - 1]` is an opening bracket.\n   *\n   * If no closing bracket could be found, `-1` will be returned.\n   *\n   * @param {RegExp} open\n   * @param {RegExp} close\n   * @returns {number}\n   */\n  function findClosingBracket(open, close) {\n    var stackHeight = 1;\n    for (var i = currentIndex; i < validTokens.length; i++) {\n      var token = validTokens[i];\n      var content = token.content;\n      if (token.type === 'punctuation' && typeof content === 'string') {\n        if (open.test(content)) {\n          stackHeight++;\n        } else if (close.test(content)) {\n          stackHeight--;\n          if (stackHeight === 0) {\n            return i;\n          }\n        }\n      }\n    }\n    return -1;\n  }\n\n  /**\n   * Adds an alias to the given token.\n   *\n   * @param {Token} token\n   * @param {string} alias\n   * @returns {void}\n   */\n  function addAlias(token, alias) {\n    var aliases = token.alias;\n    if (!aliases) {\n      token.alias = aliases = [];\n    } else if (!Array.isArray(aliases)) {\n      token.alias = aliases = [aliases];\n    }\n    aliases.push(alias);\n  }\n  for (; currentIndex < validTokens.length;) {\n    var startToken = validTokens[currentIndex++];\n\n    // add special aliases for mutation tokens\n    if (startToken.type === 'keyword' && startToken.content === 'mutation') {\n      // any array of the names of all input variables (if any)\n      var inputVariables = [];\n      if (isTokenType(['definition-mutation', 'punctuation']) && getToken(1).content === '(') {\n        // definition\n\n        currentIndex += 2; // skip 'definition-mutation' and 'punctuation'\n\n        var definitionEnd = findClosingBracket(/^\\($/, /^\\)$/);\n        if (definitionEnd === -1) {\n          continue;\n        }\n\n        // find all input variables\n        for (; currentIndex < definitionEnd; currentIndex++) {\n          var t = getToken(0);\n          if (t.type === 'variable') {\n            addAlias(t, 'variable-input');\n            inputVariables.push(t.content);\n          }\n        }\n        currentIndex = definitionEnd + 1;\n      }\n      if (isTokenType(['punctuation', 'property-query']) && getToken(0).content === '{') {\n        currentIndex++; // skip opening bracket\n\n        addAlias(getToken(0), 'property-mutation');\n        if (inputVariables.length > 0) {\n          var mutationEnd = findClosingBracket(/^\\{$/, /^\\}$/);\n          if (mutationEnd === -1) {\n            continue;\n          }\n\n          // give references to input variables a special alias\n          for (var i = currentIndex; i < mutationEnd; i++) {\n            var varToken = validTokens[i];\n            if (varToken.type === 'variable' && inputVariables.indexOf(varToken.content) >= 0) {\n              addAlias(varToken, 'variable-input');\n            }\n          }\n        }\n      }\n    }\n  }\n});\n\n/***/ })\n\n}]);","inputSourceMap":{"version":3,"sources":["C:/Users/Acer/Desktop/dev__book/dev__book/node_modules/prismjs/components/prism-graphql.js"],"names":["Prism","languages","graphql","pattern","greedy","alias","inside","lookbehind","markdown","hooks","add","afterTokenizeGraphql","env","language","validTokens","tokens","filter","token","type","currentIndex","getToken","offset","isTokenType","types","i","length","findClosingBracket","open","close","stackHeight","content","test","addAlias","aliases","Array","isArray","push","startToken","inputVariables","definitionEnd","t","mutationEnd","varToken","indexOf"],"mappings":"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","file":"x","sourcesContent":["Prism.languages.graphql = {\n\t'comment': /#.*/,\n\t'description': {\n\t\tpattern: /(?:\"\"\"(?:[^\"]|(?!\"\"\")\")*\"\"\"|\"(?:\\\\.|[^\\\\\"\\r\\n])*\")(?=\\s*[a-z_])/i,\n\t\tgreedy: true,\n\t\talias: 'string',\n\t\tinside: {\n\t\t\t'language-markdown': {\n\t\t\t\tpattern: /(^\"(?:\"\")?)(?!\\1)[\\s\\S]+(?=\\1$)/,\n\t\t\t\tlookbehind: true,\n\t\t\t\tinside: Prism.languages.markdown\n\t\t\t}\n\t\t}\n\t},\n\t'string': {\n\t\tpattern: /\"\"\"(?:[^\"]|(?!\"\"\")\")*\"\"\"|\"(?:\\\\.|[^\\\\\"\\r\\n])*\"/,\n\t\tgreedy: true\n\t},\n\t'number': /(?:\\B-|\\b)\\d+(?:\\.\\d+)?(?:e[+-]?\\d+)?\\b/i,\n\t'boolean': /\\b(?:true|false)\\b/,\n\t'variable': /\\$[a-z_]\\w*/i,\n\t'directive': {\n\t\tpattern: /@[a-z_]\\w*/i,\n\t\talias: 'function'\n\t},\n\t'attr-name': {\n\t\tpattern: /[a-z_]\\w*(?=\\s*(?:\\((?:[^()\"]|\"(?:\\\\.|[^\\\\\"\\r\\n])*\")*\\))?:)/i,\n\t\tgreedy: true\n\t},\n\t'atom-input': {\n\t\tpattern: /[A-Z]\\w*Input(?=!?.*$)/m,\n\t\talias: 'class-name'\n\t},\n\t'scalar': /\\b(?:Boolean|Float|ID|Int|String)\\b/,\n\t'constant': /\\b[A-Z][A-Z_\\d]*\\b/,\n\t'class-name': {\n\t\tpattern: /(\\b(?:enum|implements|interface|on|scalar|type|union)\\s+|&\\s*|:\\s*|\\[)[A-Z_]\\w*/,\n\t\tlookbehind: true\n\t},\n\t'fragment': {\n\t\tpattern: /(\\bfragment\\s+|\\.{3}\\s*(?!on\\b))[a-zA-Z_]\\w*/,\n\t\tlookbehind: true,\n\t\talias: 'function'\n\t},\n\t'definition-mutation': {\n\t\tpattern: /(\\bmutation\\s+)[a-zA-Z_]\\w*/,\n\t\tlookbehind: true,\n\t\talias: 'function'\n\t},\n\t'definition-query': {\n\t\tpattern: /(\\bquery\\s+)[a-zA-Z_]\\w*/,\n\t\tlookbehind: true,\n\t\talias: 'function'\n\t},\n\t'keyword': /\\b(?:directive|enum|extend|fragment|implements|input|interface|mutation|on|query|repeatable|scalar|schema|subscription|type|union)\\b/,\n\t'operator': /[!=|&]|\\.{3}/,\n\t'property-query': /\\w+(?=\\s*\\()/,\n\t'object': /\\w+(?=\\s*\\{)/,\n\t'punctuation': /[!(){}\\[\\]:=,]/,\n\t'property': /\\w+/\n};\n\nPrism.hooks.add('after-tokenize', function afterTokenizeGraphql(env) {\n\tif (env.language !== 'graphql') {\n\t\treturn;\n\t}\n\n\t/**\n\t * get the graphql token stream that we want to customize\n\t *\n\t * @typedef {InstanceType<import(\"./prism-core\")[\"Token\"]>} Token\n\t * @type {Token[]}\n\t */\n\tvar validTokens = env.tokens.filter(function (token) {\n\t\treturn typeof token !== 'string' && token.type !== 'comment' && token.type !== 'scalar';\n\t});\n\n\tvar currentIndex = 0;\n\n\t/**\n\t * Returns whether the token relative to the current index has the given type.\n\t *\n\t * @param {number} offset\n\t * @returns {Token | undefined}\n\t */\n\tfunction getToken(offset) {\n\t\treturn validTokens[currentIndex + offset];\n\t}\n\n\t/**\n\t * Returns whether the token relative to the current index has the given type.\n\t *\n\t * @param {readonly string[]} types\n\t * @param {number} [offset=0]\n\t * @returns {boolean}\n\t */\n\tfunction isTokenType(types, offset) {\n\t\toffset = offset || 0;\n\t\tfor (var i = 0; i < types.length; i++) {\n\t\t\tvar token = getToken(i + offset);\n\t\t\tif (!token || token.type !== types[i]) {\n\t\t\t\treturn false;\n\t\t\t}\n\t\t}\n\t\treturn true;\n\t}\n\n\t/**\n\t * Returns the index of the closing bracket to an opening bracket.\n\t *\n\t * It is assumed that `token[currentIndex - 1]` is an opening bracket.\n\t *\n\t * If no closing bracket could be found, `-1` will be returned.\n\t *\n\t * @param {RegExp} open\n\t * @param {RegExp} close\n\t * @returns {number}\n\t */\n\tfunction findClosingBracket(open, close) {\n\t\tvar stackHeight = 1;\n\n\t\tfor (var i = currentIndex; i < validTokens.length; i++) {\n\t\t\tvar token = validTokens[i];\n\t\t\tvar content = token.content;\n\n\t\t\tif (token.type === 'punctuation' && typeof content === 'string') {\n\t\t\t\tif (open.test(content)) {\n\t\t\t\t\tstackHeight++;\n\t\t\t\t} else if (close.test(content)) {\n\t\t\t\t\tstackHeight--;\n\n\t\t\t\t\tif (stackHeight === 0) {\n\t\t\t\t\t\treturn i;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\treturn -1;\n\t}\n\n\t/**\n\t * Adds an alias to the given token.\n\t *\n\t * @param {Token} token\n\t * @param {string} alias\n\t * @returns {void}\n\t */\n\tfunction addAlias(token, alias) {\n\t\tvar aliases = token.alias;\n\t\tif (!aliases) {\n\t\t\ttoken.alias = aliases = [];\n\t\t} else if (!Array.isArray(aliases)) {\n\t\t\ttoken.alias = aliases = [aliases];\n\t\t}\n\t\taliases.push(alias);\n\t}\n\n\tfor (; currentIndex < validTokens.length;) {\n\t\tvar startToken = validTokens[currentIndex++];\n\n\t\t// add special aliases for mutation tokens\n\t\tif (startToken.type === 'keyword' && startToken.content === 'mutation') {\n\t\t\t// any array of the names of all input variables (if any)\n\t\t\tvar inputVariables = [];\n\n\t\t\tif (isTokenType(['definition-mutation', 'punctuation']) && getToken(1).content === '(') {\n\t\t\t\t// definition\n\n\t\t\t\tcurrentIndex += 2; // skip 'definition-mutation' and 'punctuation'\n\n\t\t\t\tvar definitionEnd = findClosingBracket(/^\\($/, /^\\)$/);\n\t\t\t\tif (definitionEnd === -1) {\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\n\t\t\t\t// find all input variables\n\t\t\t\tfor (; currentIndex < definitionEnd; currentIndex++) {\n\t\t\t\t\tvar t = getToken(0);\n\t\t\t\t\tif (t.type === 'variable') {\n\t\t\t\t\t\taddAlias(t, 'variable-input');\n\t\t\t\t\t\tinputVariables.push(t.content);\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\tcurrentIndex = definitionEnd + 1;\n\t\t\t}\n\n\t\t\tif (isTokenType(['punctuation', 'property-query']) && getToken(0).content === '{') {\n\t\t\t\tcurrentIndex++; // skip opening bracket\n\n\t\t\t\taddAlias(getToken(0), 'property-mutation');\n\n\t\t\t\tif (inputVariables.length > 0) {\n\t\t\t\t\tvar mutationEnd = findClosingBracket(/^\\{$/, /^\\}$/);\n\t\t\t\t\tif (mutationEnd === -1) {\n\t\t\t\t\t\tcontinue;\n\t\t\t\t\t}\n\n\t\t\t\t\t// give references to input variables a special alias\n\t\t\t\t\tfor (var i = currentIndex; i < mutationEnd; i++) {\n\t\t\t\t\t\tvar varToken = validTokens[i];\n\t\t\t\t\t\tif (varToken.type === 'variable' && inputVariables.indexOf(varToken.content) >= 0) {\n\t\t\t\t\t\t\taddAlias(varToken, 'variable-input');\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n});\n"]}}