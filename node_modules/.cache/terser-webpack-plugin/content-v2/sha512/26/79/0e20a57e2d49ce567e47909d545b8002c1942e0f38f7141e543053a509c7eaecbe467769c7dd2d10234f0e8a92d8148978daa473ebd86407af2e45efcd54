{"code":"(this[\"webpackJsonp@dev-book/local-client\"]=this[\"webpackJsonp@dev-book/local-client\"]||[]).push([[230],{407:function(e,t){!function(e){var t=e.languages.javascript[\"template-string\"],n=t.pattern.source,r=t.inside.interpolation,a=r.inside[\"interpolation-punctuation\"],o=r.pattern.source;function i(t,r){if(e.languages[t])return{pattern:RegExp(\"((?:\"+r+\")\\\\s*)\"+n),lookbehind:!0,greedy:!0,inside:{\"template-punctuation\":{pattern:/^`|`$/,alias:\"string\"},\"embedded-code\":{pattern:/[\\s\\S]+/,alias:t}}}}function s(e,t){return\"___\"+t.toUpperCase()+\"_\"+e+\"___\"}function p(t,n,r){var a={code:t,grammar:n,language:r};return e.hooks.run(\"before-tokenize\",a),a.tokens=e.tokenize(a.code,a.grammar),e.hooks.run(\"after-tokenize\",a),a.tokens}function l(t){var n={};n[\"interpolation-punctuation\"]=a;var o=e.tokenize(t,n);if(3===o.length){var i=[1,1];i.push.apply(i,p(o[1],e.languages.javascript,\"javascript\")),o.splice.apply(o,i)}return new e.Token(\"interpolation\",o,r.alias,t)}function c(t,n,r){var a=e.tokenize(t,{interpolation:{pattern:RegExp(o),lookbehind:!0}}),i=0,c={},u=p(a.map((function(e){if(\"string\"===typeof e)return e;for(var n,a=e.content;-1!==t.indexOf(n=s(i++,r)););return c[n]=a,n})).join(\"\"),n,r),g=Object.keys(c);return i=0,function e(t){for(var n=0;n<t.length;n++){if(i>=g.length)return;var r=t[n];if(\"string\"===typeof r||\"string\"===typeof r.content){var a=g[i],o=\"string\"===typeof r?r:r.content,s=o.indexOf(a);if(-1!==s){++i;var p=o.substring(0,s),u=l(c[a]),f=o.substring(s+a.length),v=[];if(p&&v.push(p),v.push(u),f){var y=[f];e(y),v.push.apply(v,y)}\"string\"===typeof r?(t.splice.apply(t,[n,1].concat(v)),n+=v.length-1):r.content=v}}else{var d=r.content;Array.isArray(d)?e(d):e([d])}}}(u),new e.Token(r,u,\"language-\"+r,t)}e.languages.javascript[\"template-string\"]=[i(\"css\",/\\b(?:styled(?:\\([^)]*\\))?(?:\\s*\\.\\s*\\w+(?:\\([^)]*\\))*)*|css(?:\\s*\\.\\s*(?:global|resolve))?|createGlobalStyle|keyframes)/.source),i(\"html\",/\\bhtml|\\.\\s*(?:inner|outer)HTML\\s*\\+?=/.source),i(\"svg\",/\\bsvg/.source),i(\"markdown\",/\\b(?:md|markdown)/.source),i(\"graphql\",/\\b(?:gql|graphql(?:\\s*\\.\\s*experimental)?)/.source),i(\"sql\",/\\bsql/.source),t].filter(Boolean);var u={javascript:!0,js:!0,typescript:!0,ts:!0,jsx:!0,tsx:!0};function g(e){return\"string\"===typeof e?e:Array.isArray(e)?e.map(g).join(\"\"):g(e.content)}e.hooks.add(\"after-tokenize\",(function(t){t.language in u&&function t(n){for(var r=0,a=n.length;r<a;r++){var o=n[r];if(\"string\"!==typeof o){var i=o.content;if(Array.isArray(i))if(\"template-string\"===o.type){var s=i[1];if(3===i.length&&\"string\"!==typeof s&&\"embedded-code\"===s.type){var p=g(s),l=s.alias,u=Array.isArray(l)?l[0]:l,f=e.languages[u];if(!f)continue;i[1]=c(p,f,u)}}else t(i);else\"string\"!==typeof i&&t([i])}}}(t.tokens)}))}(Prism)}}]);","name":"static/js/230.0583211b.chunk.js","map":{"version":3,"names":["this","push","module","exports","Prism","templateString","languages","javascript","templateLiteralPattern","pattern","source","interpolationObject","inside","interpolationPunctuationObject","interpolationPattern","createTemplate","language","tag","RegExp","lookbehind","greedy","alias","getPlaceholder","counter","toUpperCase","tokenizeWithHooks","code","grammar","env","hooks","run","tokens","tokenize","tokenizeInterpolationExpression","expression","tempGrammar","length","args","apply","splice","Token","tokenizeEmbedded","_tokens","interpolation","placeholderCounter","placeholderMap","embeddedTokens","map","token","placeholder","interpolationExpression","content","indexOf","join","placeholders","Object","keys","walkTokens","i","s","index","before","substring","middle","after","replacement","afterTokens","concat","Array","isArray","filter","Boolean","supportedLanguages","js","typescript","ts","jsx","tsx","stringContent","value","add","findTemplateStrings","l","type","embedded"],"sources":["static/js/230.0583211b.chunk.js"],"mappings":"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"},"input":"(this[\"webpackJsonp@dev-book/local-client\"] = this[\"webpackJsonp@dev-book/local-client\"] || []).push([[230],{\n\n/***/ 407:\n/***/ (function(module, exports) {\n\n(function (Prism) {\n  var templateString = Prism.languages.javascript['template-string'];\n\n  // see the pattern in prism-javascript.js\n  var templateLiteralPattern = templateString.pattern.source;\n  var interpolationObject = templateString.inside['interpolation'];\n  var interpolationPunctuationObject = interpolationObject.inside['interpolation-punctuation'];\n  var interpolationPattern = interpolationObject.pattern.source;\n\n  /**\n   * Creates a new pattern to match a template string with a special tag.\n   *\n   * This will return `undefined` if there is no grammar with the given language id.\n   *\n   * @param {string} language The language id of the embedded language. E.g. `markdown`.\n   * @param {string} tag The regex pattern to match the tag.\n   * @returns {object | undefined}\n   * @example\n   * createTemplate('css', /\\bcss/.source);\n   */\n  function createTemplate(language, tag) {\n    if (!Prism.languages[language]) {\n      return undefined;\n    }\n    return {\n      pattern: RegExp('((?:' + tag + ')\\\\s*)' + templateLiteralPattern),\n      lookbehind: true,\n      greedy: true,\n      inside: {\n        'template-punctuation': {\n          pattern: /^`|`$/,\n          alias: 'string'\n        },\n        'embedded-code': {\n          pattern: /[\\s\\S]+/,\n          alias: language\n        }\n      }\n    };\n  }\n  Prism.languages.javascript['template-string'] = [\n  // styled-jsx:\n  //   css`a { color: #25F; }`\n  // styled-components:\n  //   styled.h1`color: red;`\n  createTemplate('css', /\\b(?:styled(?:\\([^)]*\\))?(?:\\s*\\.\\s*\\w+(?:\\([^)]*\\))*)*|css(?:\\s*\\.\\s*(?:global|resolve))?|createGlobalStyle|keyframes)/.source),\n  // html`<p></p>`\n  // div.innerHTML = `<p></p>`\n  createTemplate('html', /\\bhtml|\\.\\s*(?:inner|outer)HTML\\s*\\+?=/.source),\n  // svg`<path fill=\"#fff\" d=\"M55.37 ...\"/>`\n  createTemplate('svg', /\\bsvg/.source),\n  // md`# h1`, markdown`## h2`\n  createTemplate('markdown', /\\b(?:md|markdown)/.source),\n  // gql`...`, graphql`...`, graphql.experimental`...`\n  createTemplate('graphql', /\\b(?:gql|graphql(?:\\s*\\.\\s*experimental)?)/.source),\n  // sql`...`\n  createTemplate('sql', /\\bsql/.source),\n  // vanilla template string\n  templateString].filter(Boolean);\n\n  /**\n   * Returns a specific placeholder literal for the given language.\n   *\n   * @param {number} counter\n   * @param {string} language\n   * @returns {string}\n   */\n  function getPlaceholder(counter, language) {\n    return '___' + language.toUpperCase() + '_' + counter + '___';\n  }\n\n  /**\n   * Returns the tokens of `Prism.tokenize` but also runs the `before-tokenize` and `after-tokenize` hooks.\n   *\n   * @param {string} code\n   * @param {any} grammar\n   * @param {string} language\n   * @returns {(string|Token)[]}\n   */\n  function tokenizeWithHooks(code, grammar, language) {\n    var env = {\n      code: code,\n      grammar: grammar,\n      language: language\n    };\n    Prism.hooks.run('before-tokenize', env);\n    env.tokens = Prism.tokenize(env.code, env.grammar);\n    Prism.hooks.run('after-tokenize', env);\n    return env.tokens;\n  }\n\n  /**\n   * Returns the token of the given JavaScript interpolation expression.\n   *\n   * @param {string} expression The code of the expression. E.g. `\"${42}\"`\n   * @returns {Token}\n   */\n  function tokenizeInterpolationExpression(expression) {\n    var tempGrammar = {};\n    tempGrammar['interpolation-punctuation'] = interpolationPunctuationObject;\n\n    /** @type {Array} */\n    var tokens = Prism.tokenize(expression, tempGrammar);\n    if (tokens.length === 3) {\n      /**\n       * The token array will look like this\n       * [\n       *     [\"interpolation-punctuation\", \"${\"]\n       *     \"...\" // JavaScript expression of the interpolation\n       *     [\"interpolation-punctuation\", \"}\"]\n       * ]\n       */\n\n      var args = [1, 1];\n      args.push.apply(args, tokenizeWithHooks(tokens[1], Prism.languages.javascript, 'javascript'));\n      tokens.splice.apply(tokens, args);\n    }\n    return new Prism.Token('interpolation', tokens, interpolationObject.alias, expression);\n  }\n\n  /**\n   * Tokenizes the given code with support for JavaScript interpolation expressions mixed in.\n   *\n   * This function has 3 phases:\n   *\n   * 1. Replace all JavaScript interpolation expression with a placeholder.\n   *    The placeholder will have the syntax of a identify of the target language.\n   * 2. Tokenize the code with placeholders.\n   * 3. Tokenize the interpolation expressions and re-insert them into the tokenize code.\n   *    The insertion only works if a placeholder hasn't been \"ripped apart\" meaning that the placeholder has been\n   *    tokenized as two tokens by the grammar of the embedded language.\n   *\n   * @param {string} code\n   * @param {object} grammar\n   * @param {string} language\n   * @returns {Token}\n   */\n  function tokenizeEmbedded(code, grammar, language) {\n    // 1. First filter out all interpolations\n\n    // because they might be escaped, we need a lookbehind, so we use Prism\n    /** @type {(Token|string)[]} */\n    var _tokens = Prism.tokenize(code, {\n      'interpolation': {\n        pattern: RegExp(interpolationPattern),\n        lookbehind: true\n      }\n    });\n\n    // replace all interpolations with a placeholder which is not in the code already\n    var placeholderCounter = 0;\n    /** @type {Object<string, string>} */\n    var placeholderMap = {};\n    var embeddedCode = _tokens.map(function (token) {\n      if (typeof token === 'string') {\n        return token;\n      } else {\n        var interpolationExpression = token.content;\n        var placeholder;\n        while (code.indexOf(placeholder = getPlaceholder(placeholderCounter++, language)) !== -1) {/* noop */}\n        placeholderMap[placeholder] = interpolationExpression;\n        return placeholder;\n      }\n    }).join('');\n\n    // 2. Tokenize the embedded code\n\n    var embeddedTokens = tokenizeWithHooks(embeddedCode, grammar, language);\n\n    // 3. Re-insert the interpolation\n\n    var placeholders = Object.keys(placeholderMap);\n    placeholderCounter = 0;\n\n    /**\n     *\n     * @param {(Token|string)[]} tokens\n     * @returns {void}\n     */\n    function walkTokens(tokens) {\n      for (var i = 0; i < tokens.length; i++) {\n        if (placeholderCounter >= placeholders.length) {\n          return;\n        }\n        var token = tokens[i];\n        if (typeof token === 'string' || typeof token.content === 'string') {\n          var placeholder = placeholders[placeholderCounter];\n          var s = typeof token === 'string' ? token : /** @type {string} */token.content;\n          var index = s.indexOf(placeholder);\n          if (index !== -1) {\n            ++placeholderCounter;\n            var before = s.substring(0, index);\n            var middle = tokenizeInterpolationExpression(placeholderMap[placeholder]);\n            var after = s.substring(index + placeholder.length);\n            var replacement = [];\n            if (before) {\n              replacement.push(before);\n            }\n            replacement.push(middle);\n            if (after) {\n              var afterTokens = [after];\n              walkTokens(afterTokens);\n              replacement.push.apply(replacement, afterTokens);\n            }\n            if (typeof token === 'string') {\n              tokens.splice.apply(tokens, [i, 1].concat(replacement));\n              i += replacement.length - 1;\n            } else {\n              token.content = replacement;\n            }\n          }\n        } else {\n          var content = token.content;\n          if (Array.isArray(content)) {\n            walkTokens(content);\n          } else {\n            walkTokens([content]);\n          }\n        }\n      }\n    }\n    walkTokens(embeddedTokens);\n    return new Prism.Token(language, embeddedTokens, 'language-' + language, code);\n  }\n\n  /**\n   * The languages for which JS templating will handle tagged template literals.\n   *\n   * JS templating isn't active for only JavaScript but also related languages like TypeScript, JSX, and TSX.\n   */\n  var supportedLanguages = {\n    'javascript': true,\n    'js': true,\n    'typescript': true,\n    'ts': true,\n    'jsx': true,\n    'tsx': true\n  };\n  Prism.hooks.add('after-tokenize', function (env) {\n    if (!(env.language in supportedLanguages)) {\n      return;\n    }\n\n    /**\n     * Finds and tokenizes all template strings with an embedded languages.\n     *\n     * @param {(Token | string)[]} tokens\n     * @returns {void}\n     */\n    function findTemplateStrings(tokens) {\n      for (var i = 0, l = tokens.length; i < l; i++) {\n        var token = tokens[i];\n        if (typeof token === 'string') {\n          continue;\n        }\n        var content = token.content;\n        if (!Array.isArray(content)) {\n          if (typeof content !== 'string') {\n            findTemplateStrings([content]);\n          }\n          continue;\n        }\n        if (token.type === 'template-string') {\n          /**\n           * A JavaScript template-string token will look like this:\n           *\n           * [\"template-string\", [\n           *     [\"template-punctuation\", \"`\"],\n           *     (\n           *         An array of \"string\" and \"interpolation\" tokens. This is the simple string case.\n           *         or\n           *         [\"embedded-code\", \"...\"] This is the token containing the embedded code.\n           *                                  It also has an alias which is the language of the embedded code.\n           *     ),\n           *     [\"template-punctuation\", \"`\"]\n           * ]]\n           */\n\n          var embedded = content[1];\n          if (content.length === 3 && typeof embedded !== 'string' && embedded.type === 'embedded-code') {\n            // get string content\n            var code = stringContent(embedded);\n            var alias = embedded.alias;\n            var language = Array.isArray(alias) ? alias[0] : alias;\n            var grammar = Prism.languages[language];\n            if (!grammar) {\n              // the embedded language isn't registered.\n              continue;\n            }\n            content[1] = tokenizeEmbedded(code, grammar, language);\n          }\n        } else {\n          findTemplateStrings(content);\n        }\n      }\n    }\n    findTemplateStrings(env.tokens);\n  });\n\n  /**\n   * Returns the string content of a token or token stream.\n   *\n   * @param {string | Token | (string | Token)[]} value\n   * @returns {string}\n   */\n  function stringContent(value) {\n    if (typeof value === 'string') {\n      return value;\n    } else if (Array.isArray(value)) {\n      return value.map(stringContent).join('');\n    } else {\n      return stringContent(value.content);\n    }\n  }\n})(Prism);\n\n/***/ })\n\n}]);","inputSourceMap":{"version":3,"sources":["C:/Users/Acer/Desktop/dev__book/dev__book/node_modules/prismjs/components/prism-js-templates.js"],"names":["Prism","templateString","languages","javascript","templateLiteralPattern","pattern","source","interpolationObject","inside","interpolationPunctuationObject","interpolationPattern","createTemplate","language","tag","undefined","RegExp","lookbehind","greedy","alias","filter","Boolean","getPlaceholder","counter","toUpperCase","tokenizeWithHooks","code","grammar","env","hooks","run","tokens","tokenize","tokenizeInterpolationExpression","expression","tempGrammar","length","args","push","apply","splice","Token","tokenizeEmbedded","_tokens","placeholderCounter","placeholderMap","embeddedCode","map","token","interpolationExpression","content","placeholder","indexOf","join","embeddedTokens","placeholders","Object","keys","walkTokens","i","s","index","before","substring","middle","after","replacement","afterTokens","concat","Array","isArray","supportedLanguages","add","findTemplateStrings","l","type","embedded","stringContent","value"],"mappings":"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","file":"x","sourcesContent":["(function (Prism) {\n\n\tvar templateString = Prism.languages.javascript['template-string'];\n\n\t// see the pattern in prism-javascript.js\n\tvar templateLiteralPattern = templateString.pattern.source;\n\tvar interpolationObject = templateString.inside['interpolation'];\n\tvar interpolationPunctuationObject = interpolationObject.inside['interpolation-punctuation'];\n\tvar interpolationPattern = interpolationObject.pattern.source;\n\n\n\t/**\n\t * Creates a new pattern to match a template string with a special tag.\n\t *\n\t * This will return `undefined` if there is no grammar with the given language id.\n\t *\n\t * @param {string} language The language id of the embedded language. E.g. `markdown`.\n\t * @param {string} tag The regex pattern to match the tag.\n\t * @returns {object | undefined}\n\t * @example\n\t * createTemplate('css', /\\bcss/.source);\n\t */\n\tfunction createTemplate(language, tag) {\n\t\tif (!Prism.languages[language]) {\n\t\t\treturn undefined;\n\t\t}\n\n\t\treturn {\n\t\t\tpattern: RegExp('((?:' + tag + ')\\\\s*)' + templateLiteralPattern),\n\t\t\tlookbehind: true,\n\t\t\tgreedy: true,\n\t\t\tinside: {\n\t\t\t\t'template-punctuation': {\n\t\t\t\t\tpattern: /^`|`$/,\n\t\t\t\t\talias: 'string'\n\t\t\t\t},\n\t\t\t\t'embedded-code': {\n\t\t\t\t\tpattern: /[\\s\\S]+/,\n\t\t\t\t\talias: language\n\t\t\t\t}\n\t\t\t}\n\t\t};\n\t}\n\n\n\tPrism.languages.javascript['template-string'] = [\n\t\t// styled-jsx:\n\t\t//   css`a { color: #25F; }`\n\t\t// styled-components:\n\t\t//   styled.h1`color: red;`\n\t\tcreateTemplate('css', /\\b(?:styled(?:\\([^)]*\\))?(?:\\s*\\.\\s*\\w+(?:\\([^)]*\\))*)*|css(?:\\s*\\.\\s*(?:global|resolve))?|createGlobalStyle|keyframes)/.source),\n\n\t\t// html`<p></p>`\n\t\t// div.innerHTML = `<p></p>`\n\t\tcreateTemplate('html', /\\bhtml|\\.\\s*(?:inner|outer)HTML\\s*\\+?=/.source),\n\n\t\t// svg`<path fill=\"#fff\" d=\"M55.37 ...\"/>`\n\t\tcreateTemplate('svg', /\\bsvg/.source),\n\n\t\t// md`# h1`, markdown`## h2`\n\t\tcreateTemplate('markdown', /\\b(?:md|markdown)/.source),\n\n\t\t// gql`...`, graphql`...`, graphql.experimental`...`\n\t\tcreateTemplate('graphql', /\\b(?:gql|graphql(?:\\s*\\.\\s*experimental)?)/.source),\n\n\t\t// sql`...`\n\t\tcreateTemplate('sql', /\\bsql/.source),\n\n\t\t// vanilla template string\n\t\ttemplateString\n\t].filter(Boolean);\n\n\n\t/**\n\t * Returns a specific placeholder literal for the given language.\n\t *\n\t * @param {number} counter\n\t * @param {string} language\n\t * @returns {string}\n\t */\n\tfunction getPlaceholder(counter, language) {\n\t\treturn '___' + language.toUpperCase() + '_' + counter + '___';\n\t}\n\n\t/**\n\t * Returns the tokens of `Prism.tokenize` but also runs the `before-tokenize` and `after-tokenize` hooks.\n\t *\n\t * @param {string} code\n\t * @param {any} grammar\n\t * @param {string} language\n\t * @returns {(string|Token)[]}\n\t */\n\tfunction tokenizeWithHooks(code, grammar, language) {\n\t\tvar env = {\n\t\t\tcode: code,\n\t\t\tgrammar: grammar,\n\t\t\tlanguage: language\n\t\t};\n\t\tPrism.hooks.run('before-tokenize', env);\n\t\tenv.tokens = Prism.tokenize(env.code, env.grammar);\n\t\tPrism.hooks.run('after-tokenize', env);\n\t\treturn env.tokens;\n\t}\n\n\t/**\n\t * Returns the token of the given JavaScript interpolation expression.\n\t *\n\t * @param {string} expression The code of the expression. E.g. `\"${42}\"`\n\t * @returns {Token}\n\t */\n\tfunction tokenizeInterpolationExpression(expression) {\n\t\tvar tempGrammar = {};\n\t\ttempGrammar['interpolation-punctuation'] = interpolationPunctuationObject;\n\n\t\t/** @type {Array} */\n\t\tvar tokens = Prism.tokenize(expression, tempGrammar);\n\t\tif (tokens.length === 3) {\n\t\t\t/**\n\t\t\t * The token array will look like this\n\t\t\t * [\n\t\t\t *     [\"interpolation-punctuation\", \"${\"]\n\t\t\t *     \"...\" // JavaScript expression of the interpolation\n\t\t\t *     [\"interpolation-punctuation\", \"}\"]\n\t\t\t * ]\n\t\t\t */\n\n\t\t\tvar args = [1, 1];\n\t\t\targs.push.apply(args, tokenizeWithHooks(tokens[1], Prism.languages.javascript, 'javascript'));\n\n\t\t\ttokens.splice.apply(tokens, args);\n\t\t}\n\n\t\treturn new Prism.Token('interpolation', tokens, interpolationObject.alias, expression);\n\t}\n\n\t/**\n\t * Tokenizes the given code with support for JavaScript interpolation expressions mixed in.\n\t *\n\t * This function has 3 phases:\n\t *\n\t * 1. Replace all JavaScript interpolation expression with a placeholder.\n\t *    The placeholder will have the syntax of a identify of the target language.\n\t * 2. Tokenize the code with placeholders.\n\t * 3. Tokenize the interpolation expressions and re-insert them into the tokenize code.\n\t *    The insertion only works if a placeholder hasn't been \"ripped apart\" meaning that the placeholder has been\n\t *    tokenized as two tokens by the grammar of the embedded language.\n\t *\n\t * @param {string} code\n\t * @param {object} grammar\n\t * @param {string} language\n\t * @returns {Token}\n\t */\n\tfunction tokenizeEmbedded(code, grammar, language) {\n\t\t// 1. First filter out all interpolations\n\n\t\t// because they might be escaped, we need a lookbehind, so we use Prism\n\t\t/** @type {(Token|string)[]} */\n\t\tvar _tokens = Prism.tokenize(code, {\n\t\t\t'interpolation': {\n\t\t\t\tpattern: RegExp(interpolationPattern),\n\t\t\t\tlookbehind: true\n\t\t\t}\n\t\t});\n\n\t\t// replace all interpolations with a placeholder which is not in the code already\n\t\tvar placeholderCounter = 0;\n\t\t/** @type {Object<string, string>} */\n\t\tvar placeholderMap = {};\n\t\tvar embeddedCode = _tokens.map(function (token) {\n\t\t\tif (typeof token === 'string') {\n\t\t\t\treturn token;\n\t\t\t} else {\n\t\t\t\tvar interpolationExpression = token.content;\n\n\t\t\t\tvar placeholder;\n\t\t\t\twhile (code.indexOf(placeholder = getPlaceholder(placeholderCounter++, language)) !== -1) { /* noop */ }\n\t\t\t\tplaceholderMap[placeholder] = interpolationExpression;\n\t\t\t\treturn placeholder;\n\t\t\t}\n\t\t}).join('');\n\n\n\t\t// 2. Tokenize the embedded code\n\n\t\tvar embeddedTokens = tokenizeWithHooks(embeddedCode, grammar, language);\n\n\n\t\t// 3. Re-insert the interpolation\n\n\t\tvar placeholders = Object.keys(placeholderMap);\n\t\tplaceholderCounter = 0;\n\n\t\t/**\n\t\t *\n\t\t * @param {(Token|string)[]} tokens\n\t\t * @returns {void}\n\t\t */\n\t\tfunction walkTokens(tokens) {\n\t\t\tfor (var i = 0; i < tokens.length; i++) {\n\t\t\t\tif (placeholderCounter >= placeholders.length) {\n\t\t\t\t\treturn;\n\t\t\t\t}\n\n\t\t\t\tvar token = tokens[i];\n\n\t\t\t\tif (typeof token === 'string' || typeof token.content === 'string') {\n\t\t\t\t\tvar placeholder = placeholders[placeholderCounter];\n\t\t\t\t\tvar s = typeof token === 'string' ? token : /** @type {string} */ (token.content);\n\n\t\t\t\t\tvar index = s.indexOf(placeholder);\n\t\t\t\t\tif (index !== -1) {\n\t\t\t\t\t\t++placeholderCounter;\n\n\t\t\t\t\t\tvar before = s.substring(0, index);\n\t\t\t\t\t\tvar middle = tokenizeInterpolationExpression(placeholderMap[placeholder]);\n\t\t\t\t\t\tvar after = s.substring(index + placeholder.length);\n\n\t\t\t\t\t\tvar replacement = [];\n\t\t\t\t\t\tif (before) {\n\t\t\t\t\t\t\treplacement.push(before);\n\t\t\t\t\t\t}\n\t\t\t\t\t\treplacement.push(middle);\n\t\t\t\t\t\tif (after) {\n\t\t\t\t\t\t\tvar afterTokens = [after];\n\t\t\t\t\t\t\twalkTokens(afterTokens);\n\t\t\t\t\t\t\treplacement.push.apply(replacement, afterTokens);\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\tif (typeof token === 'string') {\n\t\t\t\t\t\t\ttokens.splice.apply(tokens, [i, 1].concat(replacement));\n\t\t\t\t\t\t\ti += replacement.length - 1;\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\ttoken.content = replacement;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t} else {\n\t\t\t\t\tvar content = token.content;\n\t\t\t\t\tif (Array.isArray(content)) {\n\t\t\t\t\t\twalkTokens(content);\n\t\t\t\t\t} else {\n\t\t\t\t\t\twalkTokens([content]);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\twalkTokens(embeddedTokens);\n\n\t\treturn new Prism.Token(language, embeddedTokens, 'language-' + language, code);\n\t}\n\n\t/**\n\t * The languages for which JS templating will handle tagged template literals.\n\t *\n\t * JS templating isn't active for only JavaScript but also related languages like TypeScript, JSX, and TSX.\n\t */\n\tvar supportedLanguages = {\n\t\t'javascript': true,\n\t\t'js': true,\n\t\t'typescript': true,\n\t\t'ts': true,\n\t\t'jsx': true,\n\t\t'tsx': true,\n\t};\n\tPrism.hooks.add('after-tokenize', function (env) {\n\t\tif (!(env.language in supportedLanguages)) {\n\t\t\treturn;\n\t\t}\n\n\t\t/**\n\t\t * Finds and tokenizes all template strings with an embedded languages.\n\t\t *\n\t\t * @param {(Token | string)[]} tokens\n\t\t * @returns {void}\n\t\t */\n\t\tfunction findTemplateStrings(tokens) {\n\t\t\tfor (var i = 0, l = tokens.length; i < l; i++) {\n\t\t\t\tvar token = tokens[i];\n\n\t\t\t\tif (typeof token === 'string') {\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\n\t\t\t\tvar content = token.content;\n\t\t\t\tif (!Array.isArray(content)) {\n\t\t\t\t\tif (typeof content !== 'string') {\n\t\t\t\t\t\tfindTemplateStrings([content]);\n\t\t\t\t\t}\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\n\t\t\t\tif (token.type === 'template-string') {\n\t\t\t\t\t/**\n\t\t\t\t\t * A JavaScript template-string token will look like this:\n\t\t\t\t\t *\n\t\t\t\t\t * [\"template-string\", [\n\t\t\t\t\t *     [\"template-punctuation\", \"`\"],\n\t\t\t\t\t *     (\n\t\t\t\t\t *         An array of \"string\" and \"interpolation\" tokens. This is the simple string case.\n\t\t\t\t\t *         or\n\t\t\t\t\t *         [\"embedded-code\", \"...\"] This is the token containing the embedded code.\n\t\t\t\t\t *                                  It also has an alias which is the language of the embedded code.\n\t\t\t\t\t *     ),\n\t\t\t\t\t *     [\"template-punctuation\", \"`\"]\n\t\t\t\t\t * ]]\n\t\t\t\t\t */\n\n\t\t\t\t\tvar embedded = content[1];\n\t\t\t\t\tif (content.length === 3 && typeof embedded !== 'string' && embedded.type === 'embedded-code') {\n\t\t\t\t\t\t// get string content\n\t\t\t\t\t\tvar code = stringContent(embedded);\n\n\t\t\t\t\t\tvar alias = embedded.alias;\n\t\t\t\t\t\tvar language = Array.isArray(alias) ? alias[0] : alias;\n\n\t\t\t\t\t\tvar grammar = Prism.languages[language];\n\t\t\t\t\t\tif (!grammar) {\n\t\t\t\t\t\t\t// the embedded language isn't registered.\n\t\t\t\t\t\t\tcontinue;\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\tcontent[1] = tokenizeEmbedded(code, grammar, language);\n\t\t\t\t\t}\n\t\t\t\t} else {\n\t\t\t\t\tfindTemplateStrings(content);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tfindTemplateStrings(env.tokens);\n\t});\n\n\n\t/**\n\t * Returns the string content of a token or token stream.\n\t *\n\t * @param {string | Token | (string | Token)[]} value\n\t * @returns {string}\n\t */\n\tfunction stringContent(value) {\n\t\tif (typeof value === 'string') {\n\t\t\treturn value;\n\t\t} else if (Array.isArray(value)) {\n\t\t\treturn value.map(stringContent).join('');\n\t\t} else {\n\t\t\treturn stringContent(value.content);\n\t\t}\n\t}\n\n}(Prism));\n"]}}