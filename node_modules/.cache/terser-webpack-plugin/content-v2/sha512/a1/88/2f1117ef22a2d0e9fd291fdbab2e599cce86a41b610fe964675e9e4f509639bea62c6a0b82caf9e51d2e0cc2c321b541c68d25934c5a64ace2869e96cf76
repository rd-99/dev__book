{"code":"(this[\"webpackJsonp@dev-book/local-client\"]=this[\"webpackJsonp@dev-book/local-client\"]||[]).push([[277],{454:function(e,n){!function(e){function n(e,n){return\"___\"+e.toUpperCase()+n+\"___\"}Object.defineProperties(e.languages[\"markup-templating\"]={},{buildPlaceholders:{value:function(t,a,o,r){if(t.language===a){var c=t.tokenStack=[];t.code=t.code.replace(o,(function(e){if(\"function\"===typeof r&&!r(e))return e;for(var o,i=c.length;-1!==t.code.indexOf(o=n(a,i));)++i;return c[i]=e,o})),t.grammar=e.languages.markup}}},tokenizePlaceholders:{value:function(t,a){if(t.language===a&&t.tokenStack){t.grammar=e.languages[a];var o=0,r=Object.keys(t.tokenStack);!function c(i){for(var l=0;l<i.length&&!(o>=r.length);l++){var u=i[l];if(\"string\"===typeof u||u.content&&\"string\"===typeof u.content){var s=r[o],p=t.tokenStack[s],g=\"string\"===typeof u?u:u.content,f=n(a,s),k=g.indexOf(f);if(k>-1){++o;var h=g.substring(0,k),d=new e.Token(a,e.tokenize(p,t.grammar),\"language-\"+a,p),v=g.substring(k+f.length),m=[];h&&m.push.apply(m,c([h])),m.push(d),v&&m.push.apply(m,c([v])),\"string\"===typeof u?i.splice.apply(i,[l,1].concat(m)):u.content=m}}else u.content&&c(u.content)}return i}(t.tokens)}}}})}(Prism)}}]);","name":"static/js/277.d3534d54.chunk.js","map":{"version":3,"names":["this","push","module","exports","Prism","getPlaceholder","language","index","toUpperCase","Object","defineProperties","languages","buildPlaceholders","value","env","placeholderPattern","replaceFilter","tokenStack","code","replace","match","placeholder","i","length","indexOf","grammar","markup","tokenizePlaceholders","j","keys","walkTokens","tokens","token","content","k","t","s","before","substring","middle","Token","tokenize","after","replacement","apply","splice","concat"],"sources":["static/js/277.d3534d54.chunk.js"],"mappings":"CAACA,KAAK,sCAAwCA,KAAK,uCAAyC,IAAIC,KAAK,CAAC,CAAC,KAAK,CAEtG,IACA,SAAUC,EAAQC,IAExB,SAAWC,GAQT,SAASC,EAAeC,EAAUC,GAChC,MAAO,MAAQD,EAASE,cAAgBD,EAAQ,KAClD,CACAE,OAAOC,iBAAiBN,EAAMO,UAAU,qBAAuB,CAAC,EAAG,CACjEC,kBAAmB,CAYjBC,MAAO,SAAeC,EAAKR,EAAUS,EAAoBC,GACvD,GAAIF,EAAIR,WAAaA,EAArB,CAGA,IAAIW,EAAaH,EAAIG,WAAa,GAClCH,EAAII,KAAOJ,EAAII,KAAKC,QAAQJ,GAAoB,SAAUK,GACxD,GAA6B,oBAAlBJ,IAAiCA,EAAcI,GACxD,OAAOA,EAMT,IAJA,IACIC,EADAC,EAAIL,EAAWM,QAIqD,IAAjET,EAAII,KAAKM,QAAQH,EAAchB,EAAeC,EAAUgB,OAC3DA,EAKJ,OADAL,EAAWK,GAAKF,EACTC,CACT,IAGAP,EAAIW,QAAUrB,EAAMO,UAAUe,MApB9B,CAqBF,GAEFC,qBAAsB,CAOpBd,MAAO,SAAeC,EAAKR,GACzB,GAAIQ,EAAIR,WAAaA,GAAaQ,EAAIG,WAAtC,CAKAH,EAAIW,QAAUrB,EAAMO,UAAUL,GAC9B,IAAIsB,EAAI,EACJC,EAAOpB,OAAOoB,KAAKf,EAAIG,aAC3B,SAASa,EAAWC,GAClB,IAAK,IAAIT,EAAI,EAAGA,EAAIS,EAAOR,UAErBK,GAAKC,EAAKN,QAFmBD,IAAK,CAKtC,IAAIU,EAAQD,EAAOT,GACnB,GAAqB,kBAAVU,GAAsBA,EAAMC,SAAoC,kBAAlBD,EAAMC,QAAsB,CACnF,IAAIC,EAAIL,EAAKD,GACTO,EAAIrB,EAAIG,WAAWiB,GACnBE,EAAqB,kBAAVJ,EAAqBA,EAAQA,EAAMC,QAC9CZ,EAAchB,EAAeC,EAAU4B,GACvC3B,EAAQ6B,EAAEZ,QAAQH,GACtB,GAAId,GAAS,EAAG,GACZqB,EACF,IAAIS,EAASD,EAAEE,UAAU,EAAG/B,GACxBgC,EAAS,IAAInC,EAAMoC,MAAMlC,EAAUF,EAAMqC,SAASN,EAAGrB,EAAIW,SAAU,YAAcnB,EAAU6B,GAC3FO,EAAQN,EAAEE,UAAU/B,EAAQc,EAAYE,QACxCoB,EAAc,GACdN,GACFM,EAAY1C,KAAK2C,MAAMD,EAAab,EAAW,CAACO,KAElDM,EAAY1C,KAAKsC,GACbG,GACFC,EAAY1C,KAAK2C,MAAMD,EAAab,EAAW,CAACY,KAE7B,kBAAVV,EACTD,EAAOc,OAAOD,MAAMb,EAAQ,CAACT,EAAG,GAAGwB,OAAOH,IAE1CX,EAAMC,QAAUU,CAEpB,CACF,MAAWX,EAAMC,SACfH,EAAWE,EAAMC,QAErB,CACA,OAAOF,CACT,CACAD,CAAWhB,EAAIiB,OA5Cf,CA6CF,IAGL,CA5GD,CA4GG3B,MAEI"},"input":"(this[\"webpackJsonp@dev-book/local-client\"] = this[\"webpackJsonp@dev-book/local-client\"] || []).push([[277],{\n\n/***/ 454:\n/***/ (function(module, exports) {\n\n(function (Prism) {\n  /**\n   * Returns the placeholder for the given language id and index.\n   *\n   * @param {string} language\n   * @param {string|number} index\n   * @returns {string}\n   */\n  function getPlaceholder(language, index) {\n    return '___' + language.toUpperCase() + index + '___';\n  }\n  Object.defineProperties(Prism.languages['markup-templating'] = {}, {\n    buildPlaceholders: {\n      /**\n       * Tokenize all inline templating expressions matching `placeholderPattern`.\n       *\n       * If `replaceFilter` is provided, only matches of `placeholderPattern` for which `replaceFilter` returns\n       * `true` will be replaced.\n       *\n       * @param {object} env The environment of the `before-tokenize` hook.\n       * @param {string} language The language id.\n       * @param {RegExp} placeholderPattern The matches of this pattern will be replaced by placeholders.\n       * @param {(match: string) => boolean} [replaceFilter]\n       */\n      value: function value(env, language, placeholderPattern, replaceFilter) {\n        if (env.language !== language) {\n          return;\n        }\n        var tokenStack = env.tokenStack = [];\n        env.code = env.code.replace(placeholderPattern, function (match) {\n          if (typeof replaceFilter === 'function' && !replaceFilter(match)) {\n            return match;\n          }\n          var i = tokenStack.length;\n          var placeholder;\n\n          // Check for existing strings\n          while (env.code.indexOf(placeholder = getPlaceholder(language, i)) !== -1) {\n            ++i;\n          }\n\n          // Create a sparse array\n          tokenStack[i] = match;\n          return placeholder;\n        });\n\n        // Switch the grammar to markup\n        env.grammar = Prism.languages.markup;\n      }\n    },\n    tokenizePlaceholders: {\n      /**\n       * Replace placeholders with proper tokens after tokenizing.\n       *\n       * @param {object} env The environment of the `after-tokenize` hook.\n       * @param {string} language The language id.\n       */\n      value: function value(env, language) {\n        if (env.language !== language || !env.tokenStack) {\n          return;\n        }\n\n        // Switch the grammar back\n        env.grammar = Prism.languages[language];\n        var j = 0;\n        var keys = Object.keys(env.tokenStack);\n        function walkTokens(tokens) {\n          for (var i = 0; i < tokens.length; i++) {\n            // all placeholders are replaced already\n            if (j >= keys.length) {\n              break;\n            }\n            var token = tokens[i];\n            if (typeof token === 'string' || token.content && typeof token.content === 'string') {\n              var k = keys[j];\n              var t = env.tokenStack[k];\n              var s = typeof token === 'string' ? token : token.content;\n              var placeholder = getPlaceholder(language, k);\n              var index = s.indexOf(placeholder);\n              if (index > -1) {\n                ++j;\n                var before = s.substring(0, index);\n                var middle = new Prism.Token(language, Prism.tokenize(t, env.grammar), 'language-' + language, t);\n                var after = s.substring(index + placeholder.length);\n                var replacement = [];\n                if (before) {\n                  replacement.push.apply(replacement, walkTokens([before]));\n                }\n                replacement.push(middle);\n                if (after) {\n                  replacement.push.apply(replacement, walkTokens([after]));\n                }\n                if (typeof token === 'string') {\n                  tokens.splice.apply(tokens, [i, 1].concat(replacement));\n                } else {\n                  token.content = replacement;\n                }\n              }\n            } else if (token.content /* && typeof token.content !== 'string' */) {\n              walkTokens(token.content);\n            }\n          }\n          return tokens;\n        }\n        walkTokens(env.tokens);\n      }\n    }\n  });\n})(Prism);\n\n/***/ })\n\n}]);","inputSourceMap":{"version":3,"sources":["C:/Users/Acer/Desktop/dev__book/dev__book/node_modules/prismjs/components/prism-markup-templating.js"],"names":["Prism","getPlaceholder","language","index","toUpperCase","Object","defineProperties","languages","buildPlaceholders","value","env","placeholderPattern","replaceFilter","tokenStack","code","replace","match","i","length","placeholder","indexOf","grammar","markup","tokenizePlaceholders","j","keys","walkTokens","tokens","token","content","k","t","s","before","substring","middle","Token","tokenize","after","replacement","push","apply","splice","concat"],"mappings":"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","file":"x","sourcesContent":["(function (Prism) {\n\n\t/**\n\t * Returns the placeholder for the given language id and index.\n\t *\n\t * @param {string} language\n\t * @param {string|number} index\n\t * @returns {string}\n\t */\n\tfunction getPlaceholder(language, index) {\n\t\treturn '___' + language.toUpperCase() + index + '___';\n\t}\n\n\tObject.defineProperties(Prism.languages['markup-templating'] = {}, {\n\t\tbuildPlaceholders: {\n\t\t\t/**\n\t\t\t * Tokenize all inline templating expressions matching `placeholderPattern`.\n\t\t\t *\n\t\t\t * If `replaceFilter` is provided, only matches of `placeholderPattern` for which `replaceFilter` returns\n\t\t\t * `true` will be replaced.\n\t\t\t *\n\t\t\t * @param {object} env The environment of the `before-tokenize` hook.\n\t\t\t * @param {string} language The language id.\n\t\t\t * @param {RegExp} placeholderPattern The matches of this pattern will be replaced by placeholders.\n\t\t\t * @param {(match: string) => boolean} [replaceFilter]\n\t\t\t */\n\t\t\tvalue: function (env, language, placeholderPattern, replaceFilter) {\n\t\t\t\tif (env.language !== language) {\n\t\t\t\t\treturn;\n\t\t\t\t}\n\n\t\t\t\tvar tokenStack = env.tokenStack = [];\n\n\t\t\t\tenv.code = env.code.replace(placeholderPattern, function (match) {\n\t\t\t\t\tif (typeof replaceFilter === 'function' && !replaceFilter(match)) {\n\t\t\t\t\t\treturn match;\n\t\t\t\t\t}\n\t\t\t\t\tvar i = tokenStack.length;\n\t\t\t\t\tvar placeholder;\n\n\t\t\t\t\t// Check for existing strings\n\t\t\t\t\twhile (env.code.indexOf(placeholder = getPlaceholder(language, i)) !== -1) {\n\t\t\t\t\t\t++i;\n\t\t\t\t\t}\n\n\t\t\t\t\t// Create a sparse array\n\t\t\t\t\ttokenStack[i] = match;\n\n\t\t\t\t\treturn placeholder;\n\t\t\t\t});\n\n\t\t\t\t// Switch the grammar to markup\n\t\t\t\tenv.grammar = Prism.languages.markup;\n\t\t\t}\n\t\t},\n\t\ttokenizePlaceholders: {\n\t\t\t/**\n\t\t\t * Replace placeholders with proper tokens after tokenizing.\n\t\t\t *\n\t\t\t * @param {object} env The environment of the `after-tokenize` hook.\n\t\t\t * @param {string} language The language id.\n\t\t\t */\n\t\t\tvalue: function (env, language) {\n\t\t\t\tif (env.language !== language || !env.tokenStack) {\n\t\t\t\t\treturn;\n\t\t\t\t}\n\n\t\t\t\t// Switch the grammar back\n\t\t\t\tenv.grammar = Prism.languages[language];\n\n\t\t\t\tvar j = 0;\n\t\t\t\tvar keys = Object.keys(env.tokenStack);\n\n\t\t\t\tfunction walkTokens(tokens) {\n\t\t\t\t\tfor (var i = 0; i < tokens.length; i++) {\n\t\t\t\t\t\t// all placeholders are replaced already\n\t\t\t\t\t\tif (j >= keys.length) {\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\tvar token = tokens[i];\n\t\t\t\t\t\tif (typeof token === 'string' || (token.content && typeof token.content === 'string')) {\n\t\t\t\t\t\t\tvar k = keys[j];\n\t\t\t\t\t\t\tvar t = env.tokenStack[k];\n\t\t\t\t\t\t\tvar s = typeof token === 'string' ? token : token.content;\n\t\t\t\t\t\t\tvar placeholder = getPlaceholder(language, k);\n\n\t\t\t\t\t\t\tvar index = s.indexOf(placeholder);\n\t\t\t\t\t\t\tif (index > -1) {\n\t\t\t\t\t\t\t\t++j;\n\n\t\t\t\t\t\t\t\tvar before = s.substring(0, index);\n\t\t\t\t\t\t\t\tvar middle = new Prism.Token(language, Prism.tokenize(t, env.grammar), 'language-' + language, t);\n\t\t\t\t\t\t\t\tvar after = s.substring(index + placeholder.length);\n\n\t\t\t\t\t\t\t\tvar replacement = [];\n\t\t\t\t\t\t\t\tif (before) {\n\t\t\t\t\t\t\t\t\treplacement.push.apply(replacement, walkTokens([before]));\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\treplacement.push(middle);\n\t\t\t\t\t\t\t\tif (after) {\n\t\t\t\t\t\t\t\t\treplacement.push.apply(replacement, walkTokens([after]));\n\t\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\t\tif (typeof token === 'string') {\n\t\t\t\t\t\t\t\t\ttokens.splice.apply(tokens, [i, 1].concat(replacement));\n\t\t\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\t\t\ttoken.content = replacement;\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t} else if (token.content /* && typeof token.content !== 'string' */) {\n\t\t\t\t\t\t\twalkTokens(token.content);\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\n\t\t\t\t\treturn tokens;\n\t\t\t\t}\n\n\t\t\t\twalkTokens(env.tokens);\n\t\t\t}\n\t\t}\n\t});\n\n}(Prism));\n"]}}