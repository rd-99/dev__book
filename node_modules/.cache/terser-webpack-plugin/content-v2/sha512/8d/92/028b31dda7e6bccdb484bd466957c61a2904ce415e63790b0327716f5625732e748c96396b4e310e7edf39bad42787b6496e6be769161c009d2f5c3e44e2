{"code":"(this[\"webpackJsonp@dev-book/local-client\"]=this[\"webpackJsonp@dev-book/local-client\"]||[]).push([[262],{439:function(e,n){!function(e){function n(e){return RegExp(\"(\\\\()\"+e+\"(?=[\\\\s\\\\)])\")}function a(e){return RegExp(\"([\\\\s([])\"+e+\"(?=[\\\\s)])\")}var t=\"[-+*/_~!@$%^=<>{}\\\\w]+\",s=\"&\"+t,i=\"(\\\\()\",o=\"(?=\\\\))\",r=\"(?=\\\\s)\",l={heading:{pattern:/;;;.*/,alias:[\"comment\",\"title\"]},comment:/;.*/,string:{pattern:/\"(?:[^\"\\\\]|\\\\.)*\"/,greedy:!0,inside:{argument:/[-A-Z]+(?=[.,\\s])/,symbol:RegExp(\"`\"+t+\"'\")}},\"quoted-symbol\":{pattern:RegExp(\"#?'\"+t),alias:[\"variable\",\"symbol\"]},\"lisp-property\":{pattern:RegExp(\":\"+t),alias:\"property\"},splice:{pattern:RegExp(\",@?\"+t),alias:[\"symbol\",\"variable\"]},keyword:[{pattern:RegExp(i+\"(?:(?:lexical-)?let\\\\*?|(?:cl-)?letf|if|when|while|unless|cons|cl-loop|and|or|not|cond|setq|error|message|null|require|provide|use-package)\"+r),lookbehind:!0},{pattern:RegExp(i+\"(?:for|do|collect|return|finally|append|concat|in|by)\"+r),lookbehind:!0}],declare:{pattern:n(\"declare\"),lookbehind:!0,alias:\"keyword\"},interactive:{pattern:n(\"interactive\"),lookbehind:!0,alias:\"keyword\"},boolean:{pattern:a(\"(?:t|nil)\"),lookbehind:!0},number:{pattern:a(\"[-+]?\\\\d+(?:\\\\.\\\\d*)?\"),lookbehind:!0},defvar:{pattern:RegExp(i+\"def(?:var|const|custom|group)\\\\s+\"+t),lookbehind:!0,inside:{keyword:/^def[a-z]+/,variable:RegExp(t)}},defun:{pattern:RegExp(i+\"(?:cl-)?(?:defun\\\\*?|defmacro)\\\\s+\"+t+\"\\\\s+\\\\([\\\\s\\\\S]*?\\\\)\"),lookbehind:!0,inside:{keyword:/^(?:cl-)?def\\S+/,arguments:null,function:{pattern:RegExp(\"(^\\\\s)\"+t),lookbehind:!0},punctuation:/[()]/}},lambda:{pattern:RegExp(i+\"lambda\\\\s+\\\\(\\\\s*(?:&?\"+t+\"(?:\\\\s+&?\"+t+\")*\\\\s*)?\\\\)\"),lookbehind:!0,inside:{keyword:/^lambda/,arguments:null,punctuation:/[()]/}},car:{pattern:RegExp(i+t),lookbehind:!0},punctuation:[/(?:['`,]?\\(|[)\\[\\]])/,{pattern:/(\\s)\\.(?=\\s)/,lookbehind:!0}]},p={\"lisp-marker\":RegExp(s),rest:{argument:{pattern:RegExp(t),alias:\"variable\"},varform:{pattern:RegExp(i+t+\"\\\\s+\\\\S[\\\\s\\\\S]*\"+o),lookbehind:!0,inside:{string:l.string,boolean:l.boolean,number:l.number,symbol:l.symbol,punctuation:/[()]/}}}},d=\"\\\\S+(?:\\\\s+\\\\S+)*\",u={pattern:RegExp(i+\"[\\\\s\\\\S]*\"+o),lookbehind:!0,inside:{\"rest-vars\":{pattern:RegExp(\"&(?:rest|body)\\\\s+\"+d),inside:p},\"other-marker-vars\":{pattern:RegExp(\"&(?:optional|aux)\\\\s+\"+d),inside:p},keys:{pattern:RegExp(\"&key\\\\s+\"+d+\"(?:\\\\s+&allow-other-keys)?\"),inside:p},argument:{pattern:RegExp(t),alias:\"variable\"},punctuation:/[()]/}};l.lambda.inside.arguments=u,l.defun.inside.arguments=e.util.clone(u),l.defun.inside.arguments.inside.sublist=u,e.languages.lisp=l,e.languages.elisp=l,e.languages.emacs=l,e.languages[\"emacs-lisp\"]=l}(Prism)}}]);","name":"static/js/262.22fc33ad.chunk.js","map":{"version":3,"names":["this","push","module","exports","Prism","simple_form","name","RegExp","primitive","pattern","symbol","marker","par","endpar","space","language","heading","alias","comment","string","greedy","inside","argument","splice","keyword","lookbehind","declare","interactive","boolean","number","defvar","variable","defun","arguments","function","punctuation","lambda","car","arg","rest","varform","forms","arglist","keys","util","clone","sublist","languages","lisp","elisp","emacs"],"sources":["static/js/262.22fc33ad.chunk.js"],"mappings":"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"},"input":"(this[\"webpackJsonp@dev-book/local-client\"] = this[\"webpackJsonp@dev-book/local-client\"] || []).push([[262],{\n\n/***/ 439:\n/***/ (function(module, exports) {\n\n(function (Prism) {\n  // Functions to construct regular expressions\n  // simple form\n  // e.g. (interactive ... or (interactive)\n  function simple_form(name) {\n    return RegExp('(\\\\()' + name + '(?=[\\\\s\\\\)])');\n  }\n  // booleans and numbers\n  function primitive(pattern) {\n    return RegExp('([\\\\s([])' + pattern + '(?=[\\\\s)])');\n  }\n\n  // Patterns in regular expressions\n\n  // Symbol name. See https://www.gnu.org/software/emacs/manual/html_node/elisp/Symbol-Type.html\n  // & and : are excluded as they are usually used for special purposes\n  var symbol = '[-+*/_~!@$%^=<>{}\\\\w]+';\n  // symbol starting with & used in function arguments\n  var marker = '&' + symbol;\n  // Open parenthesis for look-behind\n  var par = '(\\\\()';\n  var endpar = '(?=\\\\))';\n  // End the pattern with look-ahead space\n  var space = '(?=\\\\s)';\n  var language = {\n    // Three or four semicolons are considered a heading.\n    // See https://www.gnu.org/software/emacs/manual/html_node/elisp/Comment-Tips.html\n    heading: {\n      pattern: /;;;.*/,\n      alias: ['comment', 'title']\n    },\n    comment: /;.*/,\n    string: {\n      pattern: /\"(?:[^\"\\\\]|\\\\.)*\"/,\n      greedy: true,\n      inside: {\n        argument: /[-A-Z]+(?=[.,\\s])/,\n        symbol: RegExp('`' + symbol + \"'\")\n      }\n    },\n    'quoted-symbol': {\n      pattern: RegExp(\"#?'\" + symbol),\n      alias: ['variable', 'symbol']\n    },\n    'lisp-property': {\n      pattern: RegExp(':' + symbol),\n      alias: 'property'\n    },\n    splice: {\n      pattern: RegExp(',@?' + symbol),\n      alias: ['symbol', 'variable']\n    },\n    keyword: [{\n      pattern: RegExp(par + '(?:(?:lexical-)?let\\\\*?|(?:cl-)?letf|if|when|while|unless|cons|cl-loop|and|or|not|cond|setq|error|message|null|require|provide|use-package)' + space),\n      lookbehind: true\n    }, {\n      pattern: RegExp(par + '(?:for|do|collect|return|finally|append|concat|in|by)' + space),\n      lookbehind: true\n    }],\n    declare: {\n      pattern: simple_form('declare'),\n      lookbehind: true,\n      alias: 'keyword'\n    },\n    interactive: {\n      pattern: simple_form('interactive'),\n      lookbehind: true,\n      alias: 'keyword'\n    },\n    boolean: {\n      pattern: primitive('(?:t|nil)'),\n      lookbehind: true\n    },\n    number: {\n      pattern: primitive('[-+]?\\\\d+(?:\\\\.\\\\d*)?'),\n      lookbehind: true\n    },\n    defvar: {\n      pattern: RegExp(par + 'def(?:var|const|custom|group)\\\\s+' + symbol),\n      lookbehind: true,\n      inside: {\n        keyword: /^def[a-z]+/,\n        variable: RegExp(symbol)\n      }\n    },\n    defun: {\n      pattern: RegExp(par + '(?:cl-)?(?:defun\\\\*?|defmacro)\\\\s+' + symbol + '\\\\s+\\\\([\\\\s\\\\S]*?\\\\)'),\n      lookbehind: true,\n      inside: {\n        keyword: /^(?:cl-)?def\\S+/,\n        // See below, this property needs to be defined later so that it can\n        // reference the language object.\n        arguments: null,\n        function: {\n          pattern: RegExp('(^\\\\s)' + symbol),\n          lookbehind: true\n        },\n        punctuation: /[()]/\n      }\n    },\n    lambda: {\n      pattern: RegExp(par + 'lambda\\\\s+\\\\(\\\\s*(?:&?' + symbol + '(?:\\\\s+&?' + symbol + ')*\\\\s*)?\\\\)'),\n      lookbehind: true,\n      inside: {\n        keyword: /^lambda/,\n        // See below, this property needs to be defined later so that it can\n        // reference the language object.\n        arguments: null,\n        punctuation: /[()]/\n      }\n    },\n    car: {\n      pattern: RegExp(par + symbol),\n      lookbehind: true\n    },\n    punctuation: [\n    // open paren, brackets, and close paren\n    /(?:['`,]?\\(|[)\\[\\]])/,\n    // cons\n    {\n      pattern: /(\\s)\\.(?=\\s)/,\n      lookbehind: true\n    }]\n  };\n  var arg = {\n    'lisp-marker': RegExp(marker),\n    rest: {\n      argument: {\n        pattern: RegExp(symbol),\n        alias: 'variable'\n      },\n      varform: {\n        pattern: RegExp(par + symbol + '\\\\s+\\\\S[\\\\s\\\\S]*' + endpar),\n        lookbehind: true,\n        inside: {\n          string: language.string,\n          boolean: language.boolean,\n          number: language.number,\n          symbol: language.symbol,\n          punctuation: /[()]/\n        }\n      }\n    }\n  };\n  var forms = '\\\\S+(?:\\\\s+\\\\S+)*';\n  var arglist = {\n    pattern: RegExp(par + '[\\\\s\\\\S]*' + endpar),\n    lookbehind: true,\n    inside: {\n      'rest-vars': {\n        pattern: RegExp('&(?:rest|body)\\\\s+' + forms),\n        inside: arg\n      },\n      'other-marker-vars': {\n        pattern: RegExp('&(?:optional|aux)\\\\s+' + forms),\n        inside: arg\n      },\n      keys: {\n        pattern: RegExp('&key\\\\s+' + forms + '(?:\\\\s+&allow-other-keys)?'),\n        inside: arg\n      },\n      argument: {\n        pattern: RegExp(symbol),\n        alias: 'variable'\n      },\n      punctuation: /[()]/\n    }\n  };\n  language['lambda'].inside.arguments = arglist;\n  language['defun'].inside.arguments = Prism.util.clone(arglist);\n  language['defun'].inside.arguments.inside.sublist = arglist;\n  Prism.languages.lisp = language;\n  Prism.languages.elisp = language;\n  Prism.languages.emacs = language;\n  Prism.languages['emacs-lisp'] = language;\n})(Prism);\n\n/***/ })\n\n}]);","inputSourceMap":{"version":3,"sources":["C:/Users/Acer/Desktop/dev__book/dev__book/node_modules/prismjs/components/prism-lisp.js"],"names":["Prism","simple_form","name","RegExp","primitive","pattern","symbol","marker","par","endpar","space","language","heading","alias","comment","string","greedy","inside","argument","splice","keyword","lookbehind","declare","interactive","boolean","number","defvar","variable","defun","arguments","function","punctuation","lambda","car","arg","rest","varform","forms","arglist","keys","util","clone","sublist","languages","lisp","elisp","emacs"],"mappings":"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","file":"x","sourcesContent":["(function (Prism) {\n\t// Functions to construct regular expressions\n\t// simple form\n\t// e.g. (interactive ... or (interactive)\n\tfunction simple_form(name) {\n\t\treturn RegExp('(\\\\()' + name + '(?=[\\\\s\\\\)])');\n\t}\n\t// booleans and numbers\n\tfunction primitive(pattern) {\n\t\treturn RegExp('([\\\\s([])' + pattern + '(?=[\\\\s)])');\n\t}\n\n\t// Patterns in regular expressions\n\n\t// Symbol name. See https://www.gnu.org/software/emacs/manual/html_node/elisp/Symbol-Type.html\n\t// & and : are excluded as they are usually used for special purposes\n\tvar symbol = '[-+*/_~!@$%^=<>{}\\\\w]+';\n\t// symbol starting with & used in function arguments\n\tvar marker = '&' + symbol;\n\t// Open parenthesis for look-behind\n\tvar par = '(\\\\()';\n\tvar endpar = '(?=\\\\))';\n\t// End the pattern with look-ahead space\n\tvar space = '(?=\\\\s)';\n\n\tvar language = {\n\t\t// Three or four semicolons are considered a heading.\n\t\t// See https://www.gnu.org/software/emacs/manual/html_node/elisp/Comment-Tips.html\n\t\theading: {\n\t\t\tpattern: /;;;.*/,\n\t\t\talias: ['comment', 'title']\n\t\t},\n\t\tcomment: /;.*/,\n\t\tstring: {\n\t\t\tpattern: /\"(?:[^\"\\\\]|\\\\.)*\"/,\n\t\t\tgreedy: true,\n\t\t\tinside: {\n\t\t\t\targument: /[-A-Z]+(?=[.,\\s])/,\n\t\t\t\tsymbol: RegExp('`' + symbol + \"'\")\n\t\t\t}\n\t\t},\n\t\t'quoted-symbol': {\n\t\t\tpattern: RegExp(\"#?'\" + symbol),\n\t\t\talias: ['variable', 'symbol']\n\t\t},\n\t\t'lisp-property': {\n\t\t\tpattern: RegExp(':' + symbol),\n\t\t\talias: 'property'\n\t\t},\n\t\tsplice: {\n\t\t\tpattern: RegExp(',@?' + symbol),\n\t\t\talias: ['symbol', 'variable']\n\t\t},\n\t\tkeyword: [\n\t\t\t{\n\t\t\t\tpattern: RegExp(\n\t\t\t\t\tpar +\n\t\t\t\t\t\t'(?:(?:lexical-)?let\\\\*?|(?:cl-)?letf|if|when|while|unless|cons|cl-loop|and|or|not|cond|setq|error|message|null|require|provide|use-package)' +\n\t\t\t\t\t\tspace\n\t\t\t\t),\n\t\t\t\tlookbehind: true\n\t\t\t},\n\t\t\t{\n\t\t\t\tpattern: RegExp(\n\t\t\t\t\tpar + '(?:for|do|collect|return|finally|append|concat|in|by)' + space\n\t\t\t\t),\n\t\t\t\tlookbehind: true\n\t\t\t},\n\t\t],\n\t\tdeclare: {\n\t\t\tpattern: simple_form('declare'),\n\t\t\tlookbehind: true,\n\t\t\talias: 'keyword'\n\t\t},\n\t\tinteractive: {\n\t\t\tpattern: simple_form('interactive'),\n\t\t\tlookbehind: true,\n\t\t\talias: 'keyword'\n\t\t},\n\t\tboolean: {\n\t\t\tpattern: primitive('(?:t|nil)'),\n\t\t\tlookbehind: true\n\t\t},\n\t\tnumber: {\n\t\t\tpattern: primitive('[-+]?\\\\d+(?:\\\\.\\\\d*)?'),\n\t\t\tlookbehind: true\n\t\t},\n\t\tdefvar: {\n\t\t\tpattern: RegExp(par + 'def(?:var|const|custom|group)\\\\s+' + symbol),\n\t\t\tlookbehind: true,\n\t\t\tinside: {\n\t\t\t\tkeyword: /^def[a-z]+/,\n\t\t\t\tvariable: RegExp(symbol)\n\t\t\t}\n\t\t},\n\t\tdefun: {\n\t\t\tpattern: RegExp(\n\t\t\t\tpar +\n\t\t\t\t\t'(?:cl-)?(?:defun\\\\*?|defmacro)\\\\s+' +\n\t\t\t\t\tsymbol +\n\t\t\t\t\t'\\\\s+\\\\([\\\\s\\\\S]*?\\\\)'\n\t\t\t),\n\t\t\tlookbehind: true,\n\t\t\tinside: {\n\t\t\t\tkeyword: /^(?:cl-)?def\\S+/,\n\t\t\t\t// See below, this property needs to be defined later so that it can\n\t\t\t\t// reference the language object.\n\t\t\t\targuments: null,\n\t\t\t\tfunction: {\n\t\t\t\t\tpattern: RegExp('(^\\\\s)' + symbol),\n\t\t\t\t\tlookbehind: true\n\t\t\t\t},\n\t\t\t\tpunctuation: /[()]/\n\t\t\t}\n\t\t},\n\t\tlambda: {\n\t\t\tpattern: RegExp(par + 'lambda\\\\s+\\\\(\\\\s*(?:&?' + symbol + '(?:\\\\s+&?' + symbol + ')*\\\\s*)?\\\\)'),\n\t\t\tlookbehind: true,\n\t\t\tinside: {\n\t\t\t\tkeyword: /^lambda/,\n\t\t\t\t// See below, this property needs to be defined later so that it can\n\t\t\t\t// reference the language object.\n\t\t\t\targuments: null,\n\t\t\t\tpunctuation: /[()]/\n\t\t\t}\n\t\t},\n\t\tcar: {\n\t\t\tpattern: RegExp(par + symbol),\n\t\t\tlookbehind: true\n\t\t},\n\t\tpunctuation: [\n\t\t\t// open paren, brackets, and close paren\n\t\t\t/(?:['`,]?\\(|[)\\[\\]])/,\n\t\t\t// cons\n\t\t\t{\n\t\t\t\tpattern: /(\\s)\\.(?=\\s)/,\n\t\t\t\tlookbehind: true\n\t\t\t},\n\t\t]\n\t};\n\n\tvar arg = {\n\t\t'lisp-marker': RegExp(marker),\n\t\trest: {\n\t\t\targument: {\n\t\t\t\tpattern: RegExp(symbol),\n\t\t\t\talias: 'variable'\n\t\t\t},\n\t\t\tvarform: {\n\t\t\t\tpattern: RegExp(par + symbol + '\\\\s+\\\\S[\\\\s\\\\S]*' + endpar),\n\t\t\t\tlookbehind: true,\n\t\t\t\tinside: {\n\t\t\t\t\tstring: language.string,\n\t\t\t\t\tboolean: language.boolean,\n\t\t\t\t\tnumber: language.number,\n\t\t\t\t\tsymbol: language.symbol,\n\t\t\t\t\tpunctuation: /[()]/\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t};\n\n\tvar forms = '\\\\S+(?:\\\\s+\\\\S+)*';\n\n\tvar arglist = {\n\t\tpattern: RegExp(par + '[\\\\s\\\\S]*' + endpar),\n\t\tlookbehind: true,\n\t\tinside: {\n\t\t\t'rest-vars': {\n\t\t\t\tpattern: RegExp('&(?:rest|body)\\\\s+' + forms),\n\t\t\t\tinside: arg\n\t\t\t},\n\t\t\t'other-marker-vars': {\n\t\t\t\tpattern: RegExp('&(?:optional|aux)\\\\s+' + forms),\n\t\t\t\tinside: arg\n\t\t\t},\n\t\t\tkeys: {\n\t\t\t\tpattern: RegExp('&key\\\\s+' + forms + '(?:\\\\s+&allow-other-keys)?'),\n\t\t\t\tinside: arg\n\t\t\t},\n\t\t\targument: {\n\t\t\t\tpattern: RegExp(symbol),\n\t\t\t\talias: 'variable'\n\t\t\t},\n\t\t\tpunctuation: /[()]/\n\t\t}\n\t};\n\n\tlanguage['lambda'].inside.arguments = arglist;\n\tlanguage['defun'].inside.arguments = Prism.util.clone(arglist);\n\tlanguage['defun'].inside.arguments.inside.sublist = arglist;\n\n\tPrism.languages.lisp = language;\n\tPrism.languages.elisp = language;\n\tPrism.languages.emacs = language;\n\tPrism.languages['emacs-lisp'] = language;\n}(Prism));\n"]}}