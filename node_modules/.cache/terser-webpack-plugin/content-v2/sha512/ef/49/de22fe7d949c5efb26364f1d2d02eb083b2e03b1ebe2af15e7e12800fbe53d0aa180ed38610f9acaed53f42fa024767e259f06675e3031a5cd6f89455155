{"code":"(this[\"webpackJsonp@dev-book/local-client\"]=this[\"webpackJsonp@dev-book/local-client\"]||[]).push([[324],{501:function(o,r){Prism.languages.parigp={comment:/\\/\\*[\\s\\S]*?\\*\\/|\\\\\\\\.*/,string:{pattern:/\"(?:[^\"\\\\\\r\\n]|\\\\.)*\"/,greedy:!0},keyword:function(){var o=[\"breakpoint\",\"break\",\"dbg_down\",\"dbg_err\",\"dbg_up\",\"dbg_x\",\"forcomposite\",\"fordiv\",\"forell\",\"forpart\",\"forprime\",\"forstep\",\"forsubgroup\",\"forvec\",\"for\",\"iferr\",\"if\",\"local\",\"my\",\"next\",\"return\",\"until\",\"while\"];return o=o.map((function(o){return o.split(\"\").join(\" *\")})).join(\"|\"),RegExp(\"\\\\b(?:\"+o+\")\\\\b\")}(),function:/\\b\\w(?:[\\w ]*\\w)?(?= *\\()/,number:{pattern:/((?:\\. *\\. *)?)(?:\\b\\d(?: *\\d)*(?: *(?!\\. *\\.)\\.(?: *\\d)*)?|\\. *\\d(?: *\\d)*)(?: *e *(?:[+-] *)?\\d(?: *\\d)*)?/i,lookbehind:!0},operator:/\\. *\\.|[*\\/!](?: *=)?|%(?: *=|(?: *#)?(?: *')*)?|\\+(?: *[+=])?|-(?: *[-=>])?|<(?: *>|(?: *<)?(?: *=)?)?|>(?: *>)?(?: *=)?|=(?: *=){0,2}|\\\\(?: *\\/)?(?: *=)?|&(?: *&)?|\\| *\\||['#~^]/,punctuation:/[\\[\\]{}().,:;|]/}}}]);","name":"static/js/324.36e9e745.chunk.js","map":{"version":3,"names":["this","push","module","exports","Prism","languages","parigp","comment","string","pattern","greedy","keyword","keywords","map","split","join","RegExp","function","number","lookbehind","operator","punctuation"],"sources":["static/js/324.36e9e745.chunk.js"],"mappings":"CAACA,KAAK,sCAAwCA,KAAK,uCAAyC,IAAIC,KAAK,CAAC,CAAC,KAAK,CAEtG,IACA,SAAUC,EAAQC,GAExBC,MAAMC,UAAUC,OAAS,CACvBC,QAAW,0BACXC,OAAU,CACRC,QAAS,wBACTC,QAAQ,GAKVC,QAAW,WACT,IAAIC,EAAW,CAAC,aAAc,QAAS,WAAY,UAAW,SAAU,QAAS,eAAgB,SAAU,SAAU,UAAW,WAAY,UAAW,cAAe,SAAU,MAAO,QAAS,KAAM,QAAS,KAAM,OAAQ,SAAU,QAAS,SAIhP,OAHAA,EAAWA,EAASC,KAAI,SAAUF,GAChC,OAAOA,EAAQG,MAAM,IAAIC,KAAK,KAChC,IAAGA,KAAK,KACDC,OAAO,SAAWJ,EAAW,OACtC,CANW,GAOXK,SAAY,4BACZC,OAAU,CAERT,QAAS,gHACTU,YAAY,GAEdC,SAAY,sLACZC,YAAe,kBAGV"},"input":"(this[\"webpackJsonp@dev-book/local-client\"] = this[\"webpackJsonp@dev-book/local-client\"] || []).push([[324],{\n\n/***/ 501:\n/***/ (function(module, exports) {\n\nPrism.languages.parigp = {\n  'comment': /\\/\\*[\\s\\S]*?\\*\\/|\\\\\\\\.*/,\n  'string': {\n    pattern: /\"(?:[^\"\\\\\\r\\n]|\\\\.)*\"/,\n    greedy: true\n  },\n  // PARI/GP does not care about white spaces at all\n  // so let's process the keywords to build an appropriate regexp\n  // (e.g. \"b *r *e *a *k\", etc.)\n  'keyword': function () {\n    var keywords = ['breakpoint', 'break', 'dbg_down', 'dbg_err', 'dbg_up', 'dbg_x', 'forcomposite', 'fordiv', 'forell', 'forpart', 'forprime', 'forstep', 'forsubgroup', 'forvec', 'for', 'iferr', 'if', 'local', 'my', 'next', 'return', 'until', 'while'];\n    keywords = keywords.map(function (keyword) {\n      return keyword.split('').join(' *');\n    }).join('|');\n    return RegExp('\\\\b(?:' + keywords + ')\\\\b');\n  }(),\n  'function': /\\b\\w(?:[\\w ]*\\w)?(?= *\\()/,\n  'number': {\n    // The lookbehind and the negative lookahead prevent from breaking the .. operator\n    pattern: /((?:\\. *\\. *)?)(?:\\b\\d(?: *\\d)*(?: *(?!\\. *\\.)\\.(?: *\\d)*)?|\\. *\\d(?: *\\d)*)(?: *e *(?:[+-] *)?\\d(?: *\\d)*)?/i,\n    lookbehind: true\n  },\n  'operator': /\\. *\\.|[*\\/!](?: *=)?|%(?: *=|(?: *#)?(?: *')*)?|\\+(?: *[+=])?|-(?: *[-=>])?|<(?: *>|(?: *<)?(?: *=)?)?|>(?: *>)?(?: *=)?|=(?: *=){0,2}|\\\\(?: *\\/)?(?: *=)?|&(?: *&)?|\\| *\\||['#~^]/,\n  'punctuation': /[\\[\\]{}().,:;|]/\n};\n\n/***/ })\n\n}]);","inputSourceMap":{"version":3,"sources":["C:/Users/Acer/Desktop/dev__book/dev__book/node_modules/prismjs/components/prism-parigp.js"],"names":["Prism","languages","parigp","pattern","greedy","keywords","map","keyword","split","join","RegExp","lookbehind"],"mappings":";;;;;AAAAA,KAAK,CAACC,SAAS,CAACC,MAAM,GAAG;EACxB,SAAS,EAAE,yBAAyB;EACpC,QAAQ,EAAE;IACTC,OAAO,EAAE,uBAAuB;IAChCC,MAAM,EAAE;EACT,CAAC;EACD;EACA;EACA;EACA,SAAS,EAAG,YAAY;IACvB,IAAIC,QAAQ,GAAG,CACd,YAAY,EAAE,OAAO,EAAE,UAAU,EAAE,SAAS,EAAE,QAAQ,EAAE,OAAO,EAC/D,cAAc,EAAE,QAAQ,EAAE,QAAQ,EAAE,SAAS,EAAE,UAAU,EACzD,SAAS,EAAE,aAAa,EAAE,QAAQ,EAAE,KAAK,EAAE,OAAO,EAAE,IAAI,EACxD,OAAO,EAAE,IAAI,EAAE,MAAM,EAAE,QAAQ,EAAE,OAAO,EAAE,OAAO,CACjD;IACDA,QAAQ,GAAGA,QAAQ,CAACC,GAAG,CAAC,UAAUC,OAAO,EAAE;MAC1C,OAAOA,OAAO,CAACC,KAAK,CAAC,EAAE,CAAC,CAACC,IAAI,CAAC,IAAI,CAAC;IACpC,CAAC,CAAC,CAACA,IAAI,CAAC,GAAG,CAAC;IACZ,OAAOC,MAAM,CAAC,QAAQ,GAAGL,QAAQ,GAAG,MAAM,CAAC;EAC5C,CAAC,CAAC,CAAE;EACJ,UAAU,EAAE,2BAA2B;EACvC,QAAQ,EAAE;IACT;IACAF,OAAO,EAAE,+GAA+G;IACxHQ,UAAU,EAAE;EACb,CAAC;EACD,UAAU,EAAE,qLAAqL;EACjM,aAAa,EAAE;AAChB,CAAC,C","file":"x","sourcesContent":["Prism.languages.parigp = {\n\t'comment': /\\/\\*[\\s\\S]*?\\*\\/|\\\\\\\\.*/,\n\t'string': {\n\t\tpattern: /\"(?:[^\"\\\\\\r\\n]|\\\\.)*\"/,\n\t\tgreedy: true\n\t},\n\t// PARI/GP does not care about white spaces at all\n\t// so let's process the keywords to build an appropriate regexp\n\t// (e.g. \"b *r *e *a *k\", etc.)\n\t'keyword': (function () {\n\t\tvar keywords = [\n\t\t\t'breakpoint', 'break', 'dbg_down', 'dbg_err', 'dbg_up', 'dbg_x',\n\t\t\t'forcomposite', 'fordiv', 'forell', 'forpart', 'forprime',\n\t\t\t'forstep', 'forsubgroup', 'forvec', 'for', 'iferr', 'if',\n\t\t\t'local', 'my', 'next', 'return', 'until', 'while'\n\t\t];\n\t\tkeywords = keywords.map(function (keyword) {\n\t\t\treturn keyword.split('').join(' *');\n\t\t}).join('|');\n\t\treturn RegExp('\\\\b(?:' + keywords + ')\\\\b');\n\t}()),\n\t'function': /\\b\\w(?:[\\w ]*\\w)?(?= *\\()/,\n\t'number': {\n\t\t// The lookbehind and the negative lookahead prevent from breaking the .. operator\n\t\tpattern: /((?:\\. *\\. *)?)(?:\\b\\d(?: *\\d)*(?: *(?!\\. *\\.)\\.(?: *\\d)*)?|\\. *\\d(?: *\\d)*)(?: *e *(?:[+-] *)?\\d(?: *\\d)*)?/i,\n\t\tlookbehind: true\n\t},\n\t'operator': /\\. *\\.|[*\\/!](?: *=)?|%(?: *=|(?: *#)?(?: *')*)?|\\+(?: *[+=])?|-(?: *[-=>])?|<(?: *>|(?: *<)?(?: *=)?)?|>(?: *>)?(?: *=)?|=(?: *=){0,2}|\\\\(?: *\\/)?(?: *=)?|&(?: *&)?|\\| *\\||['#~^]/,\n\t'punctuation': /[\\[\\]{}().,:;|]/\n};\n"]}}