{"code":"(this[\"webpackJsonp@dev-book/local-client\"]=this[\"webpackJsonp@dev-book/local-client\"]||[]).push([[514],{691:function(e,n){!function(e){function n(e){return function(){return e}}var o=/\\b(?:align|allowzero|and|asm|async|await|break|cancel|catch|comptime|const|continue|defer|else|enum|errdefer|error|export|extern|fn|for|if|inline|linksection|nakedcc|noalias|null|or|orelse|packed|promise|pub|resume|return|stdcallcc|struct|suspend|switch|test|threadlocal|try|undefined|union|unreachable|usingnamespace|var|volatile|while)\\b/,r=\"\\\\b(?!\"+o.source+\")(?!\\\\d)\\\\w+\\\\b\",s=/align\\s*\\((?:[^()]|\\([^()]*\\))*\\)/.source,a=\"(?!\\\\s)(?:!?\\\\s*(?:\"+/(?:\\?|\\bpromise->|(?:\\[[^[\\]]*\\]|\\*(?!\\*)|\\*\\*)(?:\\s*<ALIGN>|\\s*const\\b|\\s*volatile\\b|\\s*allowzero\\b)*)/.source.replace(/<ALIGN>/g,n(s))+\"\\\\s*)*\"+/(?:\\bpromise\\b|(?:\\berror\\.)?<ID>(?:\\.<ID>)*(?!\\s+<ID>))/.source.replace(/<ID>/g,n(r))+\")+\";e.languages.zig={comment:[{pattern:/\\/{3}.*/,alias:\"doc-comment\"},/\\/{2}.*/],string:[{pattern:/(^|[^\\\\@])c?\"(?:[^\"\\\\\\r\\n]|\\\\.)*\"/,lookbehind:!0,greedy:!0},{pattern:/([\\r\\n])([ \\t]+c?\\\\{2}).*(?:(?:\\r\\n?|\\n)\\2.*)*/,lookbehind:!0,greedy:!0},{pattern:/(^|[^\\\\])'(?:[^'\\\\\\r\\n]|\\\\(?:.|x[a-fA-F\\d]{2}|u\\{[a-fA-F\\d]{1,6}\\}))'/,lookbehind:!0,greedy:!0}],builtin:/\\B@(?!\\d)\\w+(?=\\s*\\()/,label:{pattern:/(\\b(?:break|continue)\\s*:\\s*)\\w+\\b|\\b(?!\\d)\\w+\\b(?=\\s*:\\s*(?:\\{|while\\b))/,lookbehind:!0},\"class-name\":[/\\b(?!\\d)\\w+(?=\\s*=\\s*(?:(?:extern|packed)\\s+)?(?:enum|struct|union)\\s*[({])/,{pattern:RegExp(/(:\\s*)<TYPE>(?=\\s*(?:<ALIGN>\\s*)?[=;,)])|<TYPE>(?=\\s*(?:<ALIGN>\\s*)?\\{)/.source.replace(/<TYPE>/g,n(a)).replace(/<ALIGN>/g,n(s))),lookbehind:!0,inside:null},{pattern:RegExp(/(\\)\\s*)<TYPE>(?=\\s*(?:<ALIGN>\\s*)?;)/.source.replace(/<TYPE>/g,n(a)).replace(/<ALIGN>/g,n(s))),lookbehind:!0,inside:null}],\"builtin-types\":{pattern:/\\b(?:anyerror|bool|c_u?(?:short|int|long|longlong)|c_longdouble|c_void|comptime_(?:float|int)|[iu](?:8|16|32|64|128|size)|f(?:16|32|64|128)|noreturn|type|void)\\b/,alias:\"keyword\"},keyword:o,function:/\\b(?!\\d)\\w+(?=\\s*\\()/,number:/\\b(?:0b[01]+|0o[0-7]+|0x[a-fA-F\\d]+(?:\\.[a-fA-F\\d]*)?(?:[pP][+-]?[a-fA-F\\d]+)?|\\d+(?:\\.\\d*)?(?:[eE][+-]?\\d+)?)\\b/,boolean:/\\b(?:false|true)\\b/,operator:/\\.[*?]|\\.{2,3}|[-=]>|\\*\\*|\\+\\+|\\|\\||(?:<<|>>|[-+*]%|[-+*/%^&|<>!=])=?|[?~]/,punctuation:/[.:,;(){}[\\]]/},e.languages.zig[\"class-name\"].forEach((function(n){null===n.inside&&(n.inside=e.languages.zig)}))}(Prism)}}]);","name":"static/js/514.bcc7a9c1.chunk.js","map":{"version":3,"names":["this","push","module","exports","Prism","literal","str","keyword","IDENTIFIER","source","ALIGN","TYPE","replace","languages","zig","comment","pattern","alias","string","lookbehind","greedy","builtin","label","RegExp","inside","function","number","boolean","operator","punctuation","forEach","obj"],"sources":["static/js/514.bcc7a9c1.chunk.js"],"mappings":"CAACA,KAAK,sCAAwCA,KAAK,uCAAyC,IAAIC,KAAK,CAAC,CAAC,KAAK,CAEtG,IACA,SAAUC,EAAQC,IAExB,SAAWC,GACT,SAASC,EAAQC,GACf,OAAO,WACL,OAAOA,CACT,CACF,CACA,IAAIC,EAAU,sVACVC,EAAa,SAAWD,EAAQE,OAAS,kBACzCC,EAAQ,oCAAoCD,OAG5CE,EAAO,sBAFU,0GAA0GF,OAAOG,QAAQ,WAAYP,EAAQK,IAE9G,SADlC,2DAA2DD,OAAOG,QAAQ,QAASP,EAAQG,IAChC,KAmB7EJ,EAAMS,UAAUC,IAAM,CACpBC,QAAW,CAAC,CACVC,QAAS,UACTC,MAAO,eACN,WACHC,OAAU,CAAC,CAETF,QAAS,oCACTG,YAAY,EACZC,QAAQ,GACP,CAEDJ,QAAS,iDACTG,YAAY,EACZC,QAAQ,GACP,CAEDJ,QAAS,wEACTG,YAAY,EACZC,QAAQ,IAEVC,QAAW,wBACXC,MAAS,CACPN,QAAS,4EACTG,YAAY,GAEd,aAAc,CAEd,8EAA+E,CAI7EH,QAASO,OAAO,0EAA0Ed,OAAOG,QAAQ,UAAWP,EAAQM,IAAOC,QAAQ,WAAYP,EAAQK,KAC/JS,YAAY,EACZK,OAAQ,MACP,CAEDR,QAASO,OAAO,uCAAuCd,OAAOG,QAAQ,UAAWP,EAAQM,IAAOC,QAAQ,WAAYP,EAAQK,KAC5HS,YAAY,EACZK,OAAQ,OAGV,gBAAiB,CACfR,QAAS,oKACTC,MAAO,WAETV,QAAWA,EACXkB,SAAY,uBACZC,OAAU,mHACVC,QAAW,qBACXC,SAAY,6EACZC,YAAe,iBAEjBzB,EAAMS,UAAUC,IAAI,cAAcgB,SAAQ,SAAUC,GAC/B,OAAfA,EAAIP,SACNO,EAAIP,OAASpB,EAAMS,UAAUC,IAEjC,GACD,CAxFD,CAwFGV,MAEI"},"input":"(this[\"webpackJsonp@dev-book/local-client\"] = this[\"webpackJsonp@dev-book/local-client\"] || []).push([[514],{\n\n/***/ 691:\n/***/ (function(module, exports) {\n\n(function (Prism) {\n  function literal(str) {\n    return function () {\n      return str;\n    };\n  }\n  var keyword = /\\b(?:align|allowzero|and|asm|async|await|break|cancel|catch|comptime|const|continue|defer|else|enum|errdefer|error|export|extern|fn|for|if|inline|linksection|nakedcc|noalias|null|or|orelse|packed|promise|pub|resume|return|stdcallcc|struct|suspend|switch|test|threadlocal|try|undefined|union|unreachable|usingnamespace|var|volatile|while)\\b/;\n  var IDENTIFIER = '\\\\b(?!' + keyword.source + ')(?!\\\\d)\\\\w+\\\\b';\n  var ALIGN = /align\\s*\\((?:[^()]|\\([^()]*\\))*\\)/.source;\n  var PREFIX_TYPE_OP = /(?:\\?|\\bpromise->|(?:\\[[^[\\]]*\\]|\\*(?!\\*)|\\*\\*)(?:\\s*<ALIGN>|\\s*const\\b|\\s*volatile\\b|\\s*allowzero\\b)*)/.source.replace(/<ALIGN>/g, literal(ALIGN));\n  var SUFFIX_EXPR = /(?:\\bpromise\\b|(?:\\berror\\.)?<ID>(?:\\.<ID>)*(?!\\s+<ID>))/.source.replace(/<ID>/g, literal(IDENTIFIER));\n  var TYPE = '(?!\\\\s)(?:!?\\\\s*(?:' + PREFIX_TYPE_OP + '\\\\s*)*' + SUFFIX_EXPR + ')+';\n\n  /*\n   * A simplified grammar for Zig compile time type literals:\n   *\n   * TypeExpr = ( \"!\"? PREFIX_TYPE_OP* SUFFIX_EXPR )+\n   *\n   * SUFFIX_EXPR = ( \\b \"promise\" \\b | ( \\b \"error\" \".\" )? IDENTIFIER ( \".\" IDENTIFIER )* (?! \\s+ IDENTIFIER ) )\n   *\n   * PREFIX_TYPE_OP = \"?\"\n   *                | \\b \"promise\" \"->\"\n   *                | ( \"[\" [^\\[\\]]* \"]\" | \"*\" | \"**\" ) ( ALIGN | \"const\" \\b | \"volatile\" \\b | \"allowzero\" \\b )*\n   *\n   * ALIGN = \"align\" \"(\" ( [^()] | \"(\" [^()]* \")\" )* \")\"\n   *\n   * IDENTIFIER = \\b (?! KEYWORD ) [a-zA-Z_] \\w* \\b\n   *\n  */\n\n  Prism.languages.zig = {\n    'comment': [{\n      pattern: /\\/{3}.*/,\n      alias: 'doc-comment'\n    }, /\\/{2}.*/],\n    'string': [{\n      // \"string\" and c\"string\"\n      pattern: /(^|[^\\\\@])c?\"(?:[^\"\\\\\\r\\n]|\\\\.)*\"/,\n      lookbehind: true,\n      greedy: true\n    }, {\n      // multiline strings and c-strings\n      pattern: /([\\r\\n])([ \\t]+c?\\\\{2}).*(?:(?:\\r\\n?|\\n)\\2.*)*/,\n      lookbehind: true,\n      greedy: true\n    }, {\n      // characters 'a', '\\n', '\\xFF', '\\u{10FFFF}'\n      pattern: /(^|[^\\\\])'(?:[^'\\\\\\r\\n]|\\\\(?:.|x[a-fA-F\\d]{2}|u\\{[a-fA-F\\d]{1,6}\\}))'/,\n      lookbehind: true,\n      greedy: true\n    }],\n    'builtin': /\\B@(?!\\d)\\w+(?=\\s*\\()/,\n    'label': {\n      pattern: /(\\b(?:break|continue)\\s*:\\s*)\\w+\\b|\\b(?!\\d)\\w+\\b(?=\\s*:\\s*(?:\\{|while\\b))/,\n      lookbehind: true\n    },\n    'class-name': [\n    // const Foo = struct {};\n    /\\b(?!\\d)\\w+(?=\\s*=\\s*(?:(?:extern|packed)\\s+)?(?:enum|struct|union)\\s*[({])/, {\n      // const x: i32 = 9;\n      // var x: Bar;\n      // fn foo(x: bool, y: f32) void {}\n      pattern: RegExp(/(:\\s*)<TYPE>(?=\\s*(?:<ALIGN>\\s*)?[=;,)])|<TYPE>(?=\\s*(?:<ALIGN>\\s*)?\\{)/.source.replace(/<TYPE>/g, literal(TYPE)).replace(/<ALIGN>/g, literal(ALIGN))),\n      lookbehind: true,\n      inside: null // see below\n    }, {\n      // extern fn foo(x: f64) f64; (optional alignment)\n      pattern: RegExp(/(\\)\\s*)<TYPE>(?=\\s*(?:<ALIGN>\\s*)?;)/.source.replace(/<TYPE>/g, literal(TYPE)).replace(/<ALIGN>/g, literal(ALIGN))),\n      lookbehind: true,\n      inside: null // see below\n    }],\n\n    'builtin-types': {\n      pattern: /\\b(?:anyerror|bool|c_u?(?:short|int|long|longlong)|c_longdouble|c_void|comptime_(?:float|int)|[iu](?:8|16|32|64|128|size)|f(?:16|32|64|128)|noreturn|type|void)\\b/,\n      alias: 'keyword'\n    },\n    'keyword': keyword,\n    'function': /\\b(?!\\d)\\w+(?=\\s*\\()/,\n    'number': /\\b(?:0b[01]+|0o[0-7]+|0x[a-fA-F\\d]+(?:\\.[a-fA-F\\d]*)?(?:[pP][+-]?[a-fA-F\\d]+)?|\\d+(?:\\.\\d*)?(?:[eE][+-]?\\d+)?)\\b/,\n    'boolean': /\\b(?:false|true)\\b/,\n    'operator': /\\.[*?]|\\.{2,3}|[-=]>|\\*\\*|\\+\\+|\\|\\||(?:<<|>>|[-+*]%|[-+*/%^&|<>!=])=?|[?~]/,\n    'punctuation': /[.:,;(){}[\\]]/\n  };\n  Prism.languages.zig['class-name'].forEach(function (obj) {\n    if (obj.inside === null) {\n      obj.inside = Prism.languages.zig;\n    }\n  });\n})(Prism);\n\n/***/ })\n\n}]);","inputSourceMap":{"version":3,"sources":["C:/Users/Acer/Desktop/dev__book/dev__book/node_modules/prismjs/components/prism-zig.js"],"names":["Prism","literal","str","keyword","IDENTIFIER","source","ALIGN","PREFIX_TYPE_OP","replace","SUFFIX_EXPR","TYPE","languages","zig","pattern","alias","lookbehind","greedy","RegExp","inside","forEach","obj"],"mappings":";;;;;AAAC,WAAUA,KAAK,EAAE;EAEjB,SAASC,OAAOA,CAACC,GAAG,EAAE;IACrB,OAAO,YAAY;MAAE,OAAOA,GAAG;IAAE,CAAC;EACnC;EAEA,IAAIC,OAAO,GAAG,qVAAqV;EAEnW,IAAIC,UAAU,GAAG,QAAQ,GAAGD,OAAO,CAACE,MAAM,GAAG,iBAAiB;EAC9D,IAAIC,KAAK,GAAG,mCAAmC,CAACD,MAAM;EACtD,IAAIE,cAAc,GAAG,yGAAyG,CAACF,MAAM,CAACG,OAAO,CAAC,UAAU,EAAEP,OAAO,CAACK,KAAK,CAAC,CAAC;EACzK,IAAIG,WAAW,GAAG,0DAA0D,CAACJ,MAAM,CAACG,OAAO,CAAC,OAAO,EAAEP,OAAO,CAACG,UAAU,CAAC,CAAC;EACzH,IAAIM,IAAI,GAAG,qBAAqB,GAAGH,cAAc,GAAG,QAAQ,GAAGE,WAAW,GAAG,IAAI;;EAEjF;AACD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;EAECT,KAAK,CAACW,SAAS,CAACC,GAAG,GAAG;IACrB,SAAS,EAAE,CACV;MACCC,OAAO,EAAE,SAAS;MAClBC,KAAK,EAAE;IACR,CAAC,EACD,SAAS,CACT;IACD,QAAQ,EAAE,CACT;MACC;MACAD,OAAO,EAAE,mCAAmC;MAC5CE,UAAU,EAAE,IAAI;MAChBC,MAAM,EAAE;IACT,CAAC,EACD;MACC;MACAH,OAAO,EAAE,gDAAgD;MACzDE,UAAU,EAAE,IAAI;MAChBC,MAAM,EAAE;IACT,CAAC,EACD;MACC;MACAH,OAAO,EAAE,uEAAuE;MAChFE,UAAU,EAAE,IAAI;MAChBC,MAAM,EAAE;IACT,CAAC,CACD;IACD,SAAS,EAAE,uBAAuB;IAClC,OAAO,EAAE;MACRH,OAAO,EAAE,2EAA2E;MACpFE,UAAU,EAAE;IACb,CAAC;IACD,YAAY,EAAE;IACb;IACA,6EAA6E,EAC7E;MACC;MACA;MACA;MACAF,OAAO,EAAEI,MAAM,CAAC,yEAAyE,CAACZ,MAAM,CAACG,OAAO,CAAC,SAAS,EAAEP,OAAO,CAACS,IAAI,CAAC,CAAC,CAACF,OAAO,CAAC,UAAU,EAAEP,OAAO,CAACK,KAAK,CAAC,CAAC,CAAC;MACvKS,UAAU,EAAE,IAAI;MAChBG,MAAM,EAAE,IAAI,CAAC;IACd,CAAC,EACD;MACC;MACAL,OAAO,EAAEI,MAAM,CAAC,sCAAsC,CAACZ,MAAM,CAACG,OAAO,CAAC,SAAS,EAAEP,OAAO,CAACS,IAAI,CAAC,CAAC,CAACF,OAAO,CAAC,UAAU,EAAEP,OAAO,CAACK,KAAK,CAAC,CAAC,CAAC;MACpIS,UAAU,EAAE,IAAI;MAChBG,MAAM,EAAE,IAAI,CAAC;IACd,CAAC,CACD;;IACD,eAAe,EAAE;MAChBL,OAAO,EAAE,mKAAmK;MAC5KC,KAAK,EAAE;IACR,CAAC;IACD,SAAS,EAAEX,OAAO;IAClB,UAAU,EAAE,sBAAsB;IAClC,QAAQ,EAAE,kHAAkH;IAC5H,SAAS,EAAE,oBAAoB;IAC/B,UAAU,EAAE,4EAA4E;IACxF,aAAa,EAAE;EAChB,CAAC;EAEDH,KAAK,CAACW,SAAS,CAACC,GAAG,CAAC,YAAY,CAAC,CAACO,OAAO,CAAC,UAAUC,GAAG,EAAE;IACxD,IAAIA,GAAG,CAACF,MAAM,KAAK,IAAI,EAAE;MACxBE,GAAG,CAACF,MAAM,GAAGlB,KAAK,CAACW,SAAS,CAACC,GAAG;IACjC;EACD,CAAC,CAAC;AAEH,CAAC,EAACZ,KAAK,CAAC,C","file":"x","sourcesContent":["(function (Prism) {\n\n\tfunction literal(str) {\n\t\treturn function () { return str; };\n\t}\n\n\tvar keyword = /\\b(?:align|allowzero|and|asm|async|await|break|cancel|catch|comptime|const|continue|defer|else|enum|errdefer|error|export|extern|fn|for|if|inline|linksection|nakedcc|noalias|null|or|orelse|packed|promise|pub|resume|return|stdcallcc|struct|suspend|switch|test|threadlocal|try|undefined|union|unreachable|usingnamespace|var|volatile|while)\\b/;\n\n\tvar IDENTIFIER = '\\\\b(?!' + keyword.source + ')(?!\\\\d)\\\\w+\\\\b';\n\tvar ALIGN = /align\\s*\\((?:[^()]|\\([^()]*\\))*\\)/.source;\n\tvar PREFIX_TYPE_OP = /(?:\\?|\\bpromise->|(?:\\[[^[\\]]*\\]|\\*(?!\\*)|\\*\\*)(?:\\s*<ALIGN>|\\s*const\\b|\\s*volatile\\b|\\s*allowzero\\b)*)/.source.replace(/<ALIGN>/g, literal(ALIGN));\n\tvar SUFFIX_EXPR = /(?:\\bpromise\\b|(?:\\berror\\.)?<ID>(?:\\.<ID>)*(?!\\s+<ID>))/.source.replace(/<ID>/g, literal(IDENTIFIER));\n\tvar TYPE = '(?!\\\\s)(?:!?\\\\s*(?:' + PREFIX_TYPE_OP + '\\\\s*)*' + SUFFIX_EXPR + ')+';\n\n\t/*\n\t * A simplified grammar for Zig compile time type literals:\n\t *\n\t * TypeExpr = ( \"!\"? PREFIX_TYPE_OP* SUFFIX_EXPR )+\n\t *\n\t * SUFFIX_EXPR = ( \\b \"promise\" \\b | ( \\b \"error\" \".\" )? IDENTIFIER ( \".\" IDENTIFIER )* (?! \\s+ IDENTIFIER ) )\n\t *\n\t * PREFIX_TYPE_OP = \"?\"\n\t *                | \\b \"promise\" \"->\"\n\t *                | ( \"[\" [^\\[\\]]* \"]\" | \"*\" | \"**\" ) ( ALIGN | \"const\" \\b | \"volatile\" \\b | \"allowzero\" \\b )*\n\t *\n\t * ALIGN = \"align\" \"(\" ( [^()] | \"(\" [^()]* \")\" )* \")\"\n\t *\n\t * IDENTIFIER = \\b (?! KEYWORD ) [a-zA-Z_] \\w* \\b\n\t *\n\t*/\n\n\tPrism.languages.zig = {\n\t\t'comment': [\n\t\t\t{\n\t\t\t\tpattern: /\\/{3}.*/,\n\t\t\t\talias: 'doc-comment'\n\t\t\t},\n\t\t\t/\\/{2}.*/\n\t\t],\n\t\t'string': [\n\t\t\t{\n\t\t\t\t// \"string\" and c\"string\"\n\t\t\t\tpattern: /(^|[^\\\\@])c?\"(?:[^\"\\\\\\r\\n]|\\\\.)*\"/,\n\t\t\t\tlookbehind: true,\n\t\t\t\tgreedy: true\n\t\t\t},\n\t\t\t{\n\t\t\t\t// multiline strings and c-strings\n\t\t\t\tpattern: /([\\r\\n])([ \\t]+c?\\\\{2}).*(?:(?:\\r\\n?|\\n)\\2.*)*/,\n\t\t\t\tlookbehind: true,\n\t\t\t\tgreedy: true\n\t\t\t},\n\t\t\t{\n\t\t\t\t// characters 'a', '\\n', '\\xFF', '\\u{10FFFF}'\n\t\t\t\tpattern: /(^|[^\\\\])'(?:[^'\\\\\\r\\n]|\\\\(?:.|x[a-fA-F\\d]{2}|u\\{[a-fA-F\\d]{1,6}\\}))'/,\n\t\t\t\tlookbehind: true,\n\t\t\t\tgreedy: true\n\t\t\t}\n\t\t],\n\t\t'builtin': /\\B@(?!\\d)\\w+(?=\\s*\\()/,\n\t\t'label': {\n\t\t\tpattern: /(\\b(?:break|continue)\\s*:\\s*)\\w+\\b|\\b(?!\\d)\\w+\\b(?=\\s*:\\s*(?:\\{|while\\b))/,\n\t\t\tlookbehind: true\n\t\t},\n\t\t'class-name': [\n\t\t\t// const Foo = struct {};\n\t\t\t/\\b(?!\\d)\\w+(?=\\s*=\\s*(?:(?:extern|packed)\\s+)?(?:enum|struct|union)\\s*[({])/,\n\t\t\t{\n\t\t\t\t// const x: i32 = 9;\n\t\t\t\t// var x: Bar;\n\t\t\t\t// fn foo(x: bool, y: f32) void {}\n\t\t\t\tpattern: RegExp(/(:\\s*)<TYPE>(?=\\s*(?:<ALIGN>\\s*)?[=;,)])|<TYPE>(?=\\s*(?:<ALIGN>\\s*)?\\{)/.source.replace(/<TYPE>/g, literal(TYPE)).replace(/<ALIGN>/g, literal(ALIGN))),\n\t\t\t\tlookbehind: true,\n\t\t\t\tinside: null // see below\n\t\t\t},\n\t\t\t{\n\t\t\t\t// extern fn foo(x: f64) f64; (optional alignment)\n\t\t\t\tpattern: RegExp(/(\\)\\s*)<TYPE>(?=\\s*(?:<ALIGN>\\s*)?;)/.source.replace(/<TYPE>/g, literal(TYPE)).replace(/<ALIGN>/g, literal(ALIGN))),\n\t\t\t\tlookbehind: true,\n\t\t\t\tinside: null // see below\n\t\t\t}\n\t\t],\n\t\t'builtin-types': {\n\t\t\tpattern: /\\b(?:anyerror|bool|c_u?(?:short|int|long|longlong)|c_longdouble|c_void|comptime_(?:float|int)|[iu](?:8|16|32|64|128|size)|f(?:16|32|64|128)|noreturn|type|void)\\b/,\n\t\t\talias: 'keyword'\n\t\t},\n\t\t'keyword': keyword,\n\t\t'function': /\\b(?!\\d)\\w+(?=\\s*\\()/,\n\t\t'number': /\\b(?:0b[01]+|0o[0-7]+|0x[a-fA-F\\d]+(?:\\.[a-fA-F\\d]*)?(?:[pP][+-]?[a-fA-F\\d]+)?|\\d+(?:\\.\\d*)?(?:[eE][+-]?\\d+)?)\\b/,\n\t\t'boolean': /\\b(?:false|true)\\b/,\n\t\t'operator': /\\.[*?]|\\.{2,3}|[-=]>|\\*\\*|\\+\\+|\\|\\||(?:<<|>>|[-+*]%|[-+*/%^&|<>!=])=?|[?~]/,\n\t\t'punctuation': /[.:,;(){}[\\]]/\n\t};\n\n\tPrism.languages.zig['class-name'].forEach(function (obj) {\n\t\tif (obj.inside === null) {\n\t\t\tobj.inside = Prism.languages.zig;\n\t\t}\n\t});\n\n}(Prism));\n"]}}