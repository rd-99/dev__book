{"code":"(this[\"webpackJsonp@dev-book/local-client\"]=this[\"webpackJsonp@dev-book/local-client\"]||[]).push([[250],{427:function(n,o){!function(n){var o=/\\s\\x00-\\x1f\\x22-\\x2f\\x3a-\\x3f\\x5b-\\x5e\\x60\\x7b-\\x7e/.source;function e(n,e){return RegExp(n.replace(/<nonId>/g,o),e)}n.languages.kumir={comment:{pattern:/\\|.*/},prolog:{pattern:/#.*/,greedy:!0},string:{pattern:/\"[^\\n\\r\"]*\"|'[^\\n\\r']*'/,greedy:!0},boolean:{pattern:e(/(^|[<nonId>])(?:\\u0434\\u0430|\\u043d\\u0435\\u0442)(?=[<nonId>]|$)/.source),lookbehind:!0},\"operator-word\":{pattern:e(/(^|[<nonId>])(?:\\u0438|\\u0438\\u043b\\u0438|\\u043d\\u0435)(?=[<nonId>]|$)/.source),lookbehind:!0,alias:\"keyword\"},\"system-variable\":{pattern:e(/(^|[<nonId>])\\u0437\\u043d\\u0430\\u0447(?=[<nonId>]|$)/.source),lookbehind:!0,alias:\"keyword\"},type:[{pattern:e(/(^|[<nonId>])(?:\\u0432\\u0435\\u0449|\\u043b\\u0438\\u0442|\\u043b\\u043e\\u0433|\\u0441\\u0438\\u043c|\\u0446\\u0435\\u043b)(?:\\x20*\\u0442\\u0430\\u0431)?(?=[<nonId>]|$)/.source),lookbehind:!0,alias:\"builtin\"},{pattern:e(/(^|[<nonId>])(?:\\u043a\\u043e\\u043c\\u043f\\u043b|\\u0441\\u043a\\u0430\\u043d\\u043a\\u043e\\u0434|\\u0444\\u0430\\u0439\\u043b|\\u0446\\u0432\\u0435\\u0442)(?=[<nonId>]|$)/.source),lookbehind:!0,alias:\"important\"}],keyword:{pattern:e(/(^|[<nonId>])(?:\\u0430\\u043b\\u0433|\\u0430\\u0440\\u0433(?:\\x20*\\u0440\\u0435\\u0437)?|\\u0432\\u0432\\u043e\\u0434|\\u0412\\u041a\\u041b\\u042e\\u0427\\u0418\\u0422\\u042c|\\u0432\\u0441[\\u0435\\u0451]|\\u0432\\u044b\\u0431\\u043e\\u0440|\\u0432\\u044b\\u0432\\u043e\\u0434|\\u0432\\u044b\\u0445\\u043e\\u0434|\\u0434\\u0430\\u043d\\u043e|\\u0434\\u043b\\u044f|\\u0434\\u043e|\\u0434\\u0441|\\u0435\\u0441\\u043b\\u0438|\\u0438\\u043d\\u0430\\u0447\\u0435|\\u0438\\u0441\\u043f|\\u0438\\u0441\\u043f\\u043e\\u043b\\u044c\\u0437\\u043e\\u0432\\u0430\\u0442\\u044c|\\u043a\\u043e\\u043d(?:(?:\\x20+|_)\\u0438\\u0441\\u043f)?|\\u043a\\u0446(?:(?:\\x20+|_)\\u043f\\u0440\\u0438)?|\\u043d\\u0430\\u0434\\u043e|\\u043d\\u0430\\u0447|\\u043d\\u0441|\\u043d\\u0446|\\u043e\\u0442|\\u043f\\u0430\\u0443\\u0437\\u0430|\\u043f\\u043e\\u043a\\u0430|\\u043f\\u0440\\u0438|\\u0440\\u0430\\u0437\\u0430?|\\u0440\\u0435\\u0437|\\u0441\\u0442\\u043e\\u043f|\\u0442\\u0430\\u0431|\\u0442\\u043e|\\u0443\\u0442\\u0432|\\u0448\\u0430\\u0433)(?=[<nonId>]|$)/.source),lookbehind:!0},name:{pattern:e(/(^|[<nonId>])[^\\d<nonId>][^<nonId>]*(?:\\x20+[^<nonId>]+)*(?=[<nonId>]|$)/.source),lookbehind:!0},number:{pattern:e(/(^|[<nonId>])(?:\\B\\$[\\da-f]+\\b|(?:\\b\\d+(?:\\.\\d*)?|\\B\\.\\d+)(?:e[+-]?\\d+)?)(?=[<nonId>]|$)/.source,\"i\"),lookbehind:!0},punctuation:/:=|[(),:;\\[\\]]/,\"operator-char\":{pattern:/\\*\\*?|<[=>]?|>=?|[-+/=]/,alias:\"operator\"}},n.languages.kum=n.languages.kumir}(Prism)}}]);","name":"static/js/250.b389c567.chunk.js","map":{"version":3,"names":["this","push","module","exports","Prism","nonId","source","wrapId","pattern","flags","RegExp","replace","languages","kumir","comment","prolog","greedy","string","boolean","lookbehind","alias","type","keyword","name","number","punctuation","kum"],"sources":["static/js/250.b389c567.chunk.js"],"mappings":"CAACA,KAAK,sCAAwCA,KAAK,uCAAyC,IAAIC,KAAK,CAAC,CAAC,KAAK,CAEtG,IACA,SAAUC,EAAQC,IAGxB,SAAWC,GAMT,IAAIC,EAAQ,sDAAsDC,OASlE,SAASC,EAAOC,EAASC,GACvB,OAAOC,OAAOF,EAAQG,QAAQ,WAAYN,GAAQI,EACpD,CACAL,EAAMQ,UAAUC,MAAQ,CACtBC,QAAW,CACTN,QAAS,QAEXO,OAAU,CACRP,QAAS,MACTQ,QAAQ,GAEVC,OAAU,CACRT,QAAS,0BACTQ,QAAQ,GAEVE,QAAW,CACTV,QAASD,EAAO,kEAAyCD,QACzDa,YAAY,GAEd,gBAAiB,CACfX,QAASD,EAAO,yEAA2CD,QAC3Da,YAAY,EACZC,MAAO,WAET,kBAAmB,CACjBZ,QAASD,EAAO,uDAAmCD,QACnDa,YAAY,EACZC,MAAO,WAETC,KAAQ,CAAC,CACPb,QAASD,EAAO,6JAAmED,QACnFa,YAAY,EACZC,MAAO,WACN,CACDZ,QAASD,EAAO,8JAA0DD,QAC1Ea,YAAY,EACZC,MAAO,cAOTE,QAAW,CACTd,QAASD,EAAO,84BAAqPD,QACrQa,YAAY,GAGdI,KAAQ,CACNf,QAASD,EAAO,2EAA2ED,QAC3Fa,YAAY,GAGdK,OAAU,CACRhB,QAASD,EAAO,2FAA2FD,OAAQ,KACnHa,YAAY,GAGdM,YAAe,iBAMf,gBAAiB,CACfjB,QAAS,0BACTY,MAAO,aAGXhB,EAAMQ,UAAUc,IAAMtB,EAAMQ,UAAUC,KACvC,CArFD,CAqFGT,MAEI"},"input":"(this[\"webpackJsonp@dev-book/local-client\"] = this[\"webpackJsonp@dev-book/local-client\"] || []).push([[250],{\n\n/***/ 427:\n/***/ (function(module, exports) {\n\n/* eslint-disable regexp/no-dupe-characters-character-class */\n(function (Prism) {\n  /**\n   * Regular expression for characters that are not allowed in identifiers.\n   *\n   * @type {string}\n   */\n  var nonId = /\\s\\x00-\\x1f\\x22-\\x2f\\x3a-\\x3f\\x5b-\\x5e\\x60\\x7b-\\x7e/.source;\n\n  /**\n   * Surround a regular expression for IDs with patterns for non-ID sequences.\n   *\n   * @param {string} pattern A regular expression for identifiers.\n   * @param {string} [flags] The regular expression flags.\n   * @returns {RegExp} A wrapped regular expression for identifiers.\n   */\n  function wrapId(pattern, flags) {\n    return RegExp(pattern.replace(/<nonId>/g, nonId), flags);\n  }\n  Prism.languages.kumir = {\n    'comment': {\n      pattern: /\\|.*/\n    },\n    'prolog': {\n      pattern: /#.*/,\n      greedy: true\n    },\n    'string': {\n      pattern: /\"[^\\n\\r\"]*\"|'[^\\n\\r']*'/,\n      greedy: true\n    },\n    'boolean': {\n      pattern: wrapId(/(^|[<nonId>])(?:да|нет)(?=[<nonId>]|$)/.source),\n      lookbehind: true\n    },\n    'operator-word': {\n      pattern: wrapId(/(^|[<nonId>])(?:и|или|не)(?=[<nonId>]|$)/.source),\n      lookbehind: true,\n      alias: 'keyword'\n    },\n    'system-variable': {\n      pattern: wrapId(/(^|[<nonId>])знач(?=[<nonId>]|$)/.source),\n      lookbehind: true,\n      alias: 'keyword'\n    },\n    'type': [{\n      pattern: wrapId(/(^|[<nonId>])(?:вещ|лит|лог|сим|цел)(?:\\x20*таб)?(?=[<nonId>]|$)/.source),\n      lookbehind: true,\n      alias: 'builtin'\n    }, {\n      pattern: wrapId(/(^|[<nonId>])(?:компл|сканкод|файл|цвет)(?=[<nonId>]|$)/.source),\n      lookbehind: true,\n      alias: 'important'\n    }],\n    /**\n     * Should be performed after searching for type names because of \"таб\".\n     * \"таб\" is a reserved word, but never used without a preceding type name.\n     * \"НАЗНАЧИТЬ\", \"Фввод\", and \"Фвывод\" are not reserved words.\n     */\n    'keyword': {\n      pattern: wrapId(/(^|[<nonId>])(?:алг|арг(?:\\x20*рез)?|ввод|ВКЛЮЧИТЬ|вс[её]|выбор|вывод|выход|дано|для|до|дс|если|иначе|исп|использовать|кон(?:(?:\\x20+|_)исп)?|кц(?:(?:\\x20+|_)при)?|надо|нач|нс|нц|от|пауза|пока|при|раза?|рез|стоп|таб|то|утв|шаг)(?=[<nonId>]|$)/.source),\n      lookbehind: true\n    },\n    /** Should be performed after searching for reserved words. */\n    'name': {\n      pattern: wrapId(/(^|[<nonId>])[^\\d<nonId>][^<nonId>]*(?:\\x20+[^<nonId>]+)*(?=[<nonId>]|$)/.source),\n      lookbehind: true\n    },\n    /** Should be performed after searching for names. */\n    'number': {\n      pattern: wrapId(/(^|[<nonId>])(?:\\B\\$[\\da-f]+\\b|(?:\\b\\d+(?:\\.\\d*)?|\\B\\.\\d+)(?:e[+-]?\\d+)?)(?=[<nonId>]|$)/.source, 'i'),\n      lookbehind: true\n    },\n    /** Should be performed after searching for words. */\n    'punctuation': /:=|[(),:;\\[\\]]/,\n    /**\n     * Should be performed after searching for\n     * - numeric constants (because of \"+\" and \"-\");\n     * - punctuation marks (because of \":=\" and \"=\").\n     */\n    'operator-char': {\n      pattern: /\\*\\*?|<[=>]?|>=?|[-+/=]/,\n      alias: 'operator'\n    }\n  };\n  Prism.languages.kum = Prism.languages.kumir;\n})(Prism);\n\n/***/ })\n\n}]);","inputSourceMap":{"version":3,"sources":["C:/Users/Acer/Desktop/dev__book/dev__book/node_modules/prismjs/components/prism-kumir.js"],"names":["Prism","nonId","source","wrapId","pattern","flags","RegExp","replace","languages","kumir","greedy","lookbehind","alias","kum"],"mappings":";;;;;AAAA;AACC,WAAUA,KAAK,EAAE;EAEjB;AACD;AACA;AACA;AACA;EACC,IAAIC,KAAK,GAAG,qDAAqD,CAACC,MAAM;;EAExE;AACD;AACA;AACA;AACA;AACA;AACA;EACC,SAASC,MAAMA,CAACC,OAAO,EAAEC,KAAK,EAAE;IAC/B,OAAOC,MAAM,CAACF,OAAO,CAACG,OAAO,CAAC,UAAU,EAAEN,KAAK,CAAC,EAAEI,KAAK,CAAC;EACzD;EAEAL,KAAK,CAACQ,SAAS,CAACC,KAAK,GAAG;IACvB,SAAS,EAAE;MACVL,OAAO,EAAE;IACV,CAAC;IAED,QAAQ,EAAE;MACTA,OAAO,EAAE,KAAK;MACdM,MAAM,EAAE;IACT,CAAC;IAED,QAAQ,EAAE;MACTN,OAAO,EAAE,yBAAyB;MAClCM,MAAM,EAAE;IACT,CAAC;IAED,SAAS,EAAE;MACVN,OAAO,EAAED,MAAM,CAAC,wCAAwC,CAACD,MAAM,CAAC;MAChES,UAAU,EAAE;IACb,CAAC;IAED,eAAe,EAAE;MAChBP,OAAO,EAAED,MAAM,CAAC,0CAA0C,CAACD,MAAM,CAAC;MAClES,UAAU,EAAE,IAAI;MAChBC,KAAK,EAAE;IACR,CAAC;IAED,iBAAiB,EAAE;MAClBR,OAAO,EAAED,MAAM,CAAC,kCAAkC,CAACD,MAAM,CAAC;MAC1DS,UAAU,EAAE,IAAI;MAChBC,KAAK,EAAE;IACR,CAAC;IAED,MAAM,EAAE,CACP;MACCR,OAAO,EAAED,MAAM,CAAC,kEAAkE,CAACD,MAAM,CAAC;MAC1FS,UAAU,EAAE,IAAI;MAChBC,KAAK,EAAE;IACR,CAAC,EACD;MACCR,OAAO,EAAED,MAAM,CAAC,yDAAyD,CAACD,MAAM,CAAC;MACjFS,UAAU,EAAE,IAAI;MAChBC,KAAK,EAAE;IACR,CAAC,CACD;IAED;AACF;AACA;AACA;AACA;IACE,SAAS,EAAE;MACVR,OAAO,EAAED,MAAM,CAAC,oPAAoP,CAACD,MAAM,CAAC;MAC5QS,UAAU,EAAE;IACb,CAAC;IAED;IACA,MAAM,EAAE;MACPP,OAAO,EAAED,MAAM,CAAC,0EAA0E,CAACD,MAAM,CAAC;MAClGS,UAAU,EAAE;IACb,CAAC;IAED;IACA,QAAQ,EAAE;MACTP,OAAO,EAAED,MAAM,CAAC,0FAA0F,CAACD,MAAM,EAAE,GAAG,CAAC;MACvHS,UAAU,EAAE;IACb,CAAC;IAED;IACA,aAAa,EAAE,gBAAgB;IAE/B;AACF;AACA;AACA;AACA;IACE,eAAe,EAAE;MAChBP,OAAO,EAAE,yBAAyB;MAClCQ,KAAK,EAAE;IACR;EACD,CAAC;EAEDZ,KAAK,CAACQ,SAAS,CAACK,GAAG,GAAGb,KAAK,CAACQ,SAAS,CAACC,KAAK;AAE5C,CAAC,EAACT,KAAK,CAAC,C","file":"x","sourcesContent":["/* eslint-disable regexp/no-dupe-characters-character-class */\n(function (Prism) {\n\n\t/**\n\t * Regular expression for characters that are not allowed in identifiers.\n\t *\n\t * @type {string}\n\t */\n\tvar nonId = /\\s\\x00-\\x1f\\x22-\\x2f\\x3a-\\x3f\\x5b-\\x5e\\x60\\x7b-\\x7e/.source;\n\n\t/**\n\t * Surround a regular expression for IDs with patterns for non-ID sequences.\n\t *\n\t * @param {string} pattern A regular expression for identifiers.\n\t * @param {string} [flags] The regular expression flags.\n\t * @returns {RegExp} A wrapped regular expression for identifiers.\n\t */\n\tfunction wrapId(pattern, flags) {\n\t\treturn RegExp(pattern.replace(/<nonId>/g, nonId), flags);\n\t}\n\n\tPrism.languages.kumir = {\n\t\t'comment': {\n\t\t\tpattern: /\\|.*/\n\t\t},\n\n\t\t'prolog': {\n\t\t\tpattern: /#.*/,\n\t\t\tgreedy: true\n\t\t},\n\n\t\t'string': {\n\t\t\tpattern: /\"[^\\n\\r\"]*\"|'[^\\n\\r']*'/,\n\t\t\tgreedy: true\n\t\t},\n\n\t\t'boolean': {\n\t\t\tpattern: wrapId(/(^|[<nonId>])(?:да|нет)(?=[<nonId>]|$)/.source),\n\t\t\tlookbehind: true\n\t\t},\n\n\t\t'operator-word': {\n\t\t\tpattern: wrapId(/(^|[<nonId>])(?:и|или|не)(?=[<nonId>]|$)/.source),\n\t\t\tlookbehind: true,\n\t\t\talias: 'keyword'\n\t\t},\n\n\t\t'system-variable': {\n\t\t\tpattern: wrapId(/(^|[<nonId>])знач(?=[<nonId>]|$)/.source),\n\t\t\tlookbehind: true,\n\t\t\talias: 'keyword'\n\t\t},\n\n\t\t'type': [\n\t\t\t{\n\t\t\t\tpattern: wrapId(/(^|[<nonId>])(?:вещ|лит|лог|сим|цел)(?:\\x20*таб)?(?=[<nonId>]|$)/.source),\n\t\t\t\tlookbehind: true,\n\t\t\t\talias: 'builtin'\n\t\t\t},\n\t\t\t{\n\t\t\t\tpattern: wrapId(/(^|[<nonId>])(?:компл|сканкод|файл|цвет)(?=[<nonId>]|$)/.source),\n\t\t\t\tlookbehind: true,\n\t\t\t\talias: 'important'\n\t\t\t}\n\t\t],\n\n\t\t/**\n\t\t * Should be performed after searching for type names because of \"таб\".\n\t\t * \"таб\" is a reserved word, but never used without a preceding type name.\n\t\t * \"НАЗНАЧИТЬ\", \"Фввод\", and \"Фвывод\" are not reserved words.\n\t\t */\n\t\t'keyword': {\n\t\t\tpattern: wrapId(/(^|[<nonId>])(?:алг|арг(?:\\x20*рез)?|ввод|ВКЛЮЧИТЬ|вс[её]|выбор|вывод|выход|дано|для|до|дс|если|иначе|исп|использовать|кон(?:(?:\\x20+|_)исп)?|кц(?:(?:\\x20+|_)при)?|надо|нач|нс|нц|от|пауза|пока|при|раза?|рез|стоп|таб|то|утв|шаг)(?=[<nonId>]|$)/.source),\n\t\t\tlookbehind: true\n\t\t},\n\n\t\t/** Should be performed after searching for reserved words. */\n\t\t'name': {\n\t\t\tpattern: wrapId(/(^|[<nonId>])[^\\d<nonId>][^<nonId>]*(?:\\x20+[^<nonId>]+)*(?=[<nonId>]|$)/.source),\n\t\t\tlookbehind: true\n\t\t},\n\n\t\t/** Should be performed after searching for names. */\n\t\t'number': {\n\t\t\tpattern: wrapId(/(^|[<nonId>])(?:\\B\\$[\\da-f]+\\b|(?:\\b\\d+(?:\\.\\d*)?|\\B\\.\\d+)(?:e[+-]?\\d+)?)(?=[<nonId>]|$)/.source, 'i'),\n\t\t\tlookbehind: true\n\t\t},\n\n\t\t/** Should be performed after searching for words. */\n\t\t'punctuation': /:=|[(),:;\\[\\]]/,\n\n\t\t/**\n\t\t * Should be performed after searching for\n\t\t * - numeric constants (because of \"+\" and \"-\");\n\t\t * - punctuation marks (because of \":=\" and \"=\").\n\t\t */\n\t\t'operator-char': {\n\t\t\tpattern: /\\*\\*?|<[=>]?|>=?|[-+/=]/,\n\t\t\talias: 'operator'\n\t\t}\n\t};\n\n\tPrism.languages.kum = Prism.languages.kumir;\n\n}(Prism));\n"]}}