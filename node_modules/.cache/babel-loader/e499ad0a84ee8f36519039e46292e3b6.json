{"ast":null,"code":"/**\n * The MIT License\n * Copyright (c) 2018 Dmitriy Kubyshkin\n * Copied from https://github.com/grassator/insert-text-at-cursor\n */\nvar browserSupportsTextareaTextNodes;\n/**\n * @param {HTMLElement} input\n * @return {boolean}\n */\n\nfunction canManipulateViaTextNodes(input) {\n  if (input.nodeName !== \"TEXTAREA\") {\n    return false;\n  }\n  if (typeof browserSupportsTextareaTextNodes === \"undefined\") {\n    var textarea = document.createElement('textarea');\n    textarea.value = '1';\n    browserSupportsTextareaTextNodes = !!textarea.firstChild;\n  }\n  return browserSupportsTextareaTextNodes;\n}\n/**\n * @param {HTMLTextAreaElement|HTMLInputElement} input\n * @param {string} text\n * @returns {void}\n */\n\nexport default (function (input, text) {\n  // Most of the used APIs only work with the field selected\n  input.focus(); // IE 8-10\n\n  if (document.selection) {\n    var ieRange = document.selection.createRange();\n    ieRange.text = text; // Move cursor after the inserted text\n\n    ieRange.collapse(false\n    /* to the end */);\n\n    ieRange.select();\n    return;\n  } // Webkit + Edge\n\n  var isSuccess = document.execCommand('insertText', false, text);\n  if (!isSuccess) {\n    var start = input.selectionStart;\n    var end = input.selectionEnd; // Firefox (non-standard method)\n\n    if (typeof input.setRangeText === \"function\") {\n      input.setRangeText(text);\n    } else {\n      // To make a change we just need a Range, not a Selection\n      var range = document.createRange();\n      var textNode = document.createTextNode(text);\n      if (canManipulateViaTextNodes(input)) {\n        var node = input.firstChild; // If textarea is empty, just insert the text\n\n        if (!node) {\n          input.appendChild(textNode);\n        } else {\n          // Otherwise we need to find a nodes for start and end\n          var offset = 0;\n          var startNode = null;\n          var endNode = null;\n          while (node && (startNode === null || endNode === null)) {\n            var nodeLength = node.nodeValue.length; // if start of the selection falls into current node\n\n            if (start >= offset && start <= offset + nodeLength) {\n              range.setStart(startNode = node, start - offset);\n            } // if end of the selection falls into current node\n\n            if (end >= offset && end <= offset + nodeLength) {\n              range.setEnd(endNode = node, end - offset);\n            }\n            offset += nodeLength;\n            node = node.nextSibling;\n          } // If there is some text selected, remove it as we should replace it\n\n          if (start !== end) {\n            range.deleteContents();\n          }\n        }\n      } // If the node is a textarea and the range doesn't span outside the element\n      //\n      // Get the commonAncestorContainer of the selected range and test its type\n      // If the node is of type `#text` it means that we're still working with text nodes within our textarea element\n      // otherwise, if it's of type `#document` for example it means our selection spans outside the textarea.\n\n      if (canManipulateViaTextNodes(input) && range.commonAncestorContainer.nodeName === '#text') {\n        // Finally insert a new node. The browser will automatically split start and end nodes into two if necessary\n        range.insertNode(textNode);\n      } else {\n        // If the node is not a textarea or the range spans outside a textarea the only way is to replace the whole value\n        var value = input.value;\n        input.value = value.slice(0, start) + text + value.slice(end);\n      }\n    } // Correct the cursor position to be at the end of the insertion\n\n    input.setSelectionRange(start + text.length, start + text.length); // Notify any possible listeners of the change\n\n    var e = document.createEvent(\"UIEvent\");\n    e.initEvent(\"input\", true, false);\n    input.dispatchEvent(e);\n  }\n});","map":{"version":3,"names":["browserSupportsTextareaTextNodes","canManipulateViaTextNodes","input","nodeName","textarea","document","createElement","value","firstChild","text","focus","selection","ieRange","createRange","collapse","select","isSuccess","execCommand","start","selectionStart","end","selectionEnd","setRangeText","range","textNode","createTextNode","node","appendChild","offset","startNode","endNode","nodeLength","nodeValue","length","setStart","setEnd","nextSibling","deleteContents","commonAncestorContainer","insertNode","slice","setSelectionRange","e","createEvent","initEvent","dispatchEvent"],"sources":["../../../src/utils/InsertTextAtPosition.ts"],"sourcesContent":["/**\n * The MIT License\n * Copyright (c) 2018 Dmitriy Kubyshkin\n * Copied from https://github.com/grassator/insert-text-at-cursor\n */\n\nlet browserSupportsTextareaTextNodes: any;\n\n/**\n * @param {HTMLElement} input\n * @return {boolean}\n */\nfunction canManipulateViaTextNodes(input: HTMLTextAreaElement | HTMLInputElement) {\n  if (input.nodeName !== \"TEXTAREA\") {\n    return false;\n  }\n  if (typeof browserSupportsTextareaTextNodes === \"undefined\") {\n    const textarea: HTMLTextAreaElement = document.createElement('textarea');\n    textarea.value = '1';\n    browserSupportsTextareaTextNodes = !!textarea.firstChild;\n  }\n  return browserSupportsTextareaTextNodes;\n}\n\n/**\n * @param {HTMLTextAreaElement|HTMLInputElement} input\n * @param {string} text\n * @returns {void}\n */\nexport default (input: HTMLTextAreaElement | HTMLInputElement, text: string) => {\n  // Most of the used APIs only work with the field selected\n  input.focus();\n\n  // IE 8-10\n  if ((document as any).selection) {\n    const ieRange = (document as any).selection.createRange();\n    ieRange.text = text;\n\n    // Move cursor after the inserted text\n    ieRange.collapse(false /* to the end */);\n    ieRange.select();\n\n    return;\n  }\n\n  // Webkit + Edge\n  const isSuccess = document.execCommand('insertText', false, text);\n  if (!isSuccess) {\n    const start = input.selectionStart!;\n    const end = input.selectionEnd!;\n    // Firefox (non-standard method)\n    if (typeof input.setRangeText === \"function\") {\n      input.setRangeText(text);\n    } else {\n      // To make a change we just need a Range, not a Selection\n      const range = document.createRange();\n      const textNode = document.createTextNode(text);\n\n      if (canManipulateViaTextNodes(input)) {\n        let node = input.firstChild;\n\n        // If textarea is empty, just insert the text\n        if (!node) {\n          input.appendChild(textNode);\n        } else {\n          // Otherwise we need to find a nodes for start and end\n          let offset = 0;\n          let startNode = null;\n          let endNode = null;\n\n          while (node && (startNode === null || endNode === null)) {\n            const nodeLength = node.nodeValue!.length;\n\n            // if start of the selection falls into current node\n            if (start >= offset && start <= offset + nodeLength) {\n              range.setStart((startNode = node), start - offset);\n            }\n\n            // if end of the selection falls into current node\n            if (end >= offset && end <= offset + nodeLength) {\n              range.setEnd((endNode = node), end - offset);\n            }\n\n            offset += nodeLength;\n            node = node.nextSibling;\n          }\n\n          // If there is some text selected, remove it as we should replace it\n          if (start !== end) {\n            range.deleteContents();\n          }\n        }\n      }\n\n      // If the node is a textarea and the range doesn't span outside the element\n      //\n      // Get the commonAncestorContainer of the selected range and test its type\n      // If the node is of type `#text` it means that we're still working with text nodes within our textarea element\n      // otherwise, if it's of type `#document` for example it means our selection spans outside the textarea.\n      if (canManipulateViaTextNodes(input) && range.commonAncestorContainer.nodeName === '#text') {\n        // Finally insert a new node. The browser will automatically split start and end nodes into two if necessary\n        range.insertNode(textNode);\n      } else {\n        // If the node is not a textarea or the range spans outside a textarea the only way is to replace the whole value\n        const value = input.value;\n        input.value = value.slice(0, start) + text + value.slice(end);\n      }\n    }\n\n    // Correct the cursor position to be at the end of the insertion\n    input.setSelectionRange(start + text.length, start + text.length);\n\n    // Notify any possible listeners of the change\n    const e = document.createEvent(\"UIEvent\");\n    e.initEvent(\"input\", true, false);\n    input.dispatchEvent(e);\n  }\n}"],"mappings":"AAAA;AACA;AACA;AACA;AACA;AAEA,IAAIA,gCAAJ;AAEA;AACA;AACA;AACA;;AACA,SAASC,yBAATA,CAAmCC,KAAnC,EAAkF;EAChF,IAAIA,KAAK,CAACC,QAAN,KAAmB,UAAvB,EAAmC;IACjC,OAAO,KAAP;EACD;EACD,IAAI,OAAOH,gCAAP,KAA4C,WAAhD,EAA6D;IAC3D,IAAMI,QAA6B,GAAGC,QAAQ,CAACC,aAAT,CAAuB,UAAvB,CAAtC;IACAF,QAAQ,CAACG,KAAT,GAAiB,GAAjB;IACAP,gCAAgC,GAAG,CAAC,CAACI,QAAQ,CAACI,UAA9C;EACD;EACD,OAAOR,gCAAP;AACD;AAED;AACA;AACA;AACA;AACA;;AACA,gBAAe,UAACE,KAAD,EAAgDO,IAAhD,EAAiE;EAC9E;EACAP,KAAK,CAACQ,KAAN,GAF8E,CAI9E;;EACA,IAAKL,QAAD,CAAkBM,SAAtB,EAAiC;IAC/B,IAAMC,OAAO,GAAIP,QAAD,CAAkBM,SAAlB,CAA4BE,WAA5B,EAAhB;IACAD,OAAO,CAACH,IAAR,GAAeA,IAAf,CAF+B,CAI/B;;IACAG,OAAO,CAACE,QAAR,CAAiB;IAAM,gBAAvB;;IACAF,OAAO,CAACG,MAAR;IAEA;EACD,CAd6E,CAgB9E;;EACA,IAAMC,SAAS,GAAGX,QAAQ,CAACY,WAAT,CAAqB,YAArB,EAAmC,KAAnC,EAA0CR,IAA1C,CAAlB;EACA,IAAI,CAACO,SAAL,EAAgB;IACd,IAAME,KAAK,GAAGhB,KAAK,CAACiB,cAApB;IACA,IAAMC,GAAG,GAAGlB,KAAK,CAACmB,YAAlB,CAFc,CAGd;;IACA,IAAI,OAAOnB,KAAK,CAACoB,YAAb,KAA8B,UAAlC,EAA8C;MAC5CpB,KAAK,CAACoB,YAAN,CAAmBb,IAAnB;IACD,CAFD,MAEO;MACL;MACA,IAAMc,KAAK,GAAGlB,QAAQ,CAACQ,WAAT,EAAd;MACA,IAAMW,QAAQ,GAAGnB,QAAQ,CAACoB,cAAT,CAAwBhB,IAAxB,CAAjB;MAEA,IAAIR,yBAAyB,CAACC,KAAD,CAA7B,EAAsC;QACpC,IAAIwB,IAAI,GAAGxB,KAAK,CAACM,UAAjB,CADoC,CAGpC;;QACA,IAAI,CAACkB,IAAL,EAAW;UACTxB,KAAK,CAACyB,WAAN,CAAkBH,QAAlB;QACD,CAFD,MAEO;UACL;UACA,IAAII,MAAM,GAAG,CAAb;UACA,IAAIC,SAAS,GAAG,IAAhB;UACA,IAAIC,OAAO,GAAG,IAAd;UAEA,OAAOJ,IAAI,KAAKG,SAAS,KAAK,IAAd,IAAsBC,OAAO,KAAK,IAAvC,CAAX,EAAyD;YACvD,IAAMC,UAAU,GAAGL,IAAI,CAACM,SAAL,CAAgBC,MAAnC,CADuD,CAGvD;;YACA,IAAIf,KAAK,IAAIU,MAAT,IAAmBV,KAAK,IAAIU,MAAM,GAAGG,UAAzC,EAAqD;cACnDR,KAAK,CAACW,QAAN,CAAgBL,SAAS,GAAGH,IAA5B,EAAmCR,KAAK,GAAGU,MAA3C;YACD,CANsD,CAQvD;;YACA,IAAIR,GAAG,IAAIQ,MAAP,IAAiBR,GAAG,IAAIQ,MAAM,GAAGG,UAArC,EAAiD;cAC/CR,KAAK,CAACY,MAAN,CAAcL,OAAO,GAAGJ,IAAxB,EAA+BN,GAAG,GAAGQ,MAArC;YACD;YAEDA,MAAM,IAAIG,UAAV;YACAL,IAAI,GAAGA,IAAI,CAACU,WAAZ;UACD,CArBI,CAuBL;;UACA,IAAIlB,KAAK,KAAKE,GAAd,EAAmB;YACjBG,KAAK,CAACc,cAAN;UACD;QACF;MACF,CAvCI,CAyCL;MACA;MACA;MACA;MACA;;MACA,IAAIpC,yBAAyB,CAACC,KAAD,CAAzB,IAAoCqB,KAAK,CAACe,uBAAN,CAA8BnC,QAA9B,KAA2C,OAAnF,EAA4F;QAC1F;QACAoB,KAAK,CAACgB,UAAN,CAAiBf,QAAjB;MACD,CAHD,MAGO;QACL;QACA,IAAMjB,KAAK,GAAGL,KAAK,CAACK,KAApB;QACAL,KAAK,CAACK,KAAN,GAAcA,KAAK,CAACiC,KAAN,CAAY,CAAZ,EAAetB,KAAf,IAAwBT,IAAxB,GAA+BF,KAAK,CAACiC,KAAN,CAAYpB,GAAZ,CAA7C;MACD;IACF,CA5Da,CA8Dd;;IACAlB,KAAK,CAACuC,iBAAN,CAAwBvB,KAAK,GAAGT,IAAI,CAACwB,MAArC,EAA6Cf,KAAK,GAAGT,IAAI,CAACwB,MAA1D,EA/Dc,CAiEd;;IACA,IAAMS,CAAC,GAAGrC,QAAQ,CAACsC,WAAT,CAAqB,SAArB,CAAV;IACAD,CAAC,CAACE,SAAF,CAAY,OAAZ,EAAqB,IAArB,EAA2B,KAA3B;IACA1C,KAAK,CAAC2C,aAAN,CAAoBH,CAApB;EACD;AACF,CAxFD"},"metadata":{},"sourceType":"module"}