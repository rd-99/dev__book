{"ast":null,"code":"\"use strict\";\n\n;\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nvar tslib_1 = require(\"tslib\");\nvar types_1 = tslib_1.__importDefault(require(\"./types\"));\nfunction default_1(fork) {\n  var types = fork.use(types_1.default);\n  var Type = types.Type;\n  var builtin = types.builtInTypes;\n  var isNumber = builtin.number;\n  // An example of constructing a new type with arbitrary constraints from\n  // an existing type.\n  function geq(than) {\n    return Type.from(function (value) {\n      return isNumber.check(value) && value >= than;\n    }, isNumber + \" >= \" + than);\n  }\n  ;\n  // Default value-returning functions that may optionally be passed as a\n  // third argument to Def.prototype.field.\n  var defaults = {\n    // Functions were used because (among other reasons) that's the most\n    // elegant way to allow for the emptyArray one always to give a new\n    // array instance.\n    \"null\": function _null() {\n      return null;\n    },\n    \"emptyArray\": function emptyArray() {\n      return [];\n    },\n    \"false\": function _false() {\n      return false;\n    },\n    \"true\": function _true() {\n      return true;\n    },\n    \"undefined\": function undefined() {},\n    \"use strict\": function useStrict() {\n      return \"use strict\";\n    }\n  };\n  var naiveIsPrimitive = Type.or(builtin.string, builtin.number, builtin.boolean, builtin.null, builtin.undefined);\n  var isPrimitive = Type.from(function (value) {\n    if (value === null) return true;\n    var type = typeof value;\n    if (type === \"object\" || type === \"function\") {\n      return false;\n    }\n    return true;\n  }, naiveIsPrimitive.toString());\n  return {\n    geq: geq,\n    defaults: defaults,\n    isPrimitive: isPrimitive\n  };\n}\nexports.default = default_1;\nmodule.exports = exports[\"default\"];","map":{"version":3,"names":["Object","defineProperty","exports","value","tslib_1","require","types_1","__importDefault","default_1","fork","types","use","default","Type","builtin","builtInTypes","isNumber","number","geq","than","from","check","defaults","_null","emptyArray","_false","_true","undefined","useStrict","naiveIsPrimitive","or","string","boolean","null","isPrimitive","type","toString","module"],"sources":["C:/Users/Acer/Desktop/dev__book/dev__book/node_modules/jscodeshift/node_modules/ast-types/lib/shared.js"],"sourcesContent":["\"use strict\";;\nObject.defineProperty(exports, \"__esModule\", { value: true });\nvar tslib_1 = require(\"tslib\");\nvar types_1 = tslib_1.__importDefault(require(\"./types\"));\nfunction default_1(fork) {\n    var types = fork.use(types_1.default);\n    var Type = types.Type;\n    var builtin = types.builtInTypes;\n    var isNumber = builtin.number;\n    // An example of constructing a new type with arbitrary constraints from\n    // an existing type.\n    function geq(than) {\n        return Type.from(function (value) { return isNumber.check(value) && value >= than; }, isNumber + \" >= \" + than);\n    }\n    ;\n    // Default value-returning functions that may optionally be passed as a\n    // third argument to Def.prototype.field.\n    var defaults = {\n        // Functions were used because (among other reasons) that's the most\n        // elegant way to allow for the emptyArray one always to give a new\n        // array instance.\n        \"null\": function () { return null; },\n        \"emptyArray\": function () { return []; },\n        \"false\": function () { return false; },\n        \"true\": function () { return true; },\n        \"undefined\": function () { },\n        \"use strict\": function () { return \"use strict\"; }\n    };\n    var naiveIsPrimitive = Type.or(builtin.string, builtin.number, builtin.boolean, builtin.null, builtin.undefined);\n    var isPrimitive = Type.from(function (value) {\n        if (value === null)\n            return true;\n        var type = typeof value;\n        if (type === \"object\" ||\n            type === \"function\") {\n            return false;\n        }\n        return true;\n    }, naiveIsPrimitive.toString());\n    return {\n        geq: geq,\n        defaults: defaults,\n        isPrimitive: isPrimitive,\n    };\n}\nexports.default = default_1;\nmodule.exports = exports[\"default\"];\n"],"mappings":"AAAA,YAAY;;AAAC;AACbA,MAAM,CAACC,cAAc,CAACC,OAAO,EAAE,YAAY,EAAE;EAAEC,KAAK,EAAE;AAAK,CAAC,CAAC;AAC7D,IAAIC,OAAO,GAAGC,OAAO,CAAC,OAAO,CAAC;AAC9B,IAAIC,OAAO,GAAGF,OAAO,CAACG,eAAe,CAACF,OAAO,CAAC,SAAS,CAAC,CAAC;AACzD,SAASG,SAASA,CAACC,IAAI,EAAE;EACrB,IAAIC,KAAK,GAAGD,IAAI,CAACE,GAAG,CAACL,OAAO,CAACM,OAAO,CAAC;EACrC,IAAIC,IAAI,GAAGH,KAAK,CAACG,IAAI;EACrB,IAAIC,OAAO,GAAGJ,KAAK,CAACK,YAAY;EAChC,IAAIC,QAAQ,GAAGF,OAAO,CAACG,MAAM;EAC7B;EACA;EACA,SAASC,GAAGA,CAACC,IAAI,EAAE;IACf,OAAON,IAAI,CAACO,IAAI,CAAC,UAAUjB,KAAK,EAAE;MAAE,OAAOa,QAAQ,CAACK,KAAK,CAAClB,KAAK,CAAC,IAAIA,KAAK,IAAIgB,IAAI;IAAE,CAAC,EAAEH,QAAQ,GAAG,MAAM,GAAGG,IAAI,CAAC;EACnH;EACA;EACA;EACA;EACA,IAAIG,QAAQ,GAAG;IACX;IACA;IACA;IACA,MAAM,EAAE,SAAAC,MAAA,EAAY;MAAE,OAAO,IAAI;IAAE,CAAC;IACpC,YAAY,EAAE,SAAAC,WAAA,EAAY;MAAE,OAAO,EAAE;IAAE,CAAC;IACxC,OAAO,EAAE,SAAAC,OAAA,EAAY;MAAE,OAAO,KAAK;IAAE,CAAC;IACtC,MAAM,EAAE,SAAAC,MAAA,EAAY;MAAE,OAAO,IAAI;IAAE,CAAC;IACpC,WAAW,EAAE,SAAAC,UAAA,EAAY,CAAE,CAAC;IAC5B,YAAY,EAAE,SAAAC,UAAA,EAAY;MAAE,OAAO,YAAY;IAAE;EACrD,CAAC;EACD,IAAIC,gBAAgB,GAAGhB,IAAI,CAACiB,EAAE,CAAChB,OAAO,CAACiB,MAAM,EAAEjB,OAAO,CAACG,MAAM,EAAEH,OAAO,CAACkB,OAAO,EAAElB,OAAO,CAACmB,IAAI,EAAEnB,OAAO,CAACa,SAAS,CAAC;EAChH,IAAIO,WAAW,GAAGrB,IAAI,CAACO,IAAI,CAAC,UAAUjB,KAAK,EAAE;IACzC,IAAIA,KAAK,KAAK,IAAI,EACd,OAAO,IAAI;IACf,IAAIgC,IAAI,GAAG,OAAOhC,KAAK;IACvB,IAAIgC,IAAI,KAAK,QAAQ,IACjBA,IAAI,KAAK,UAAU,EAAE;MACrB,OAAO,KAAK;IAChB;IACA,OAAO,IAAI;EACf,CAAC,EAAEN,gBAAgB,CAACO,QAAQ,CAAC,CAAC,CAAC;EAC/B,OAAO;IACHlB,GAAG,EAAEA,GAAG;IACRI,QAAQ,EAAEA,QAAQ;IAClBY,WAAW,EAAEA;EACjB,CAAC;AACL;AACAhC,OAAO,CAACU,OAAO,GAAGJ,SAAS;AAC3B6B,MAAM,CAACnC,OAAO,GAAGA,OAAO,CAAC,SAAS,CAAC"},"metadata":{},"sourceType":"script"}