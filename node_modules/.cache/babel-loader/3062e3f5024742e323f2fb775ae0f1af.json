{"ast":null,"code":"/**\n * Copyright (c) Facebook, Inc. and its affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n */\n\n'use strict';\n\nvar recast = require('recast');\nvar builders = recast.types.builders;\nvar types = recast.types.namedTypes;\nfunction splice(arr, element, replacement) {\n  arr.splice.apply(arr, [arr.indexOf(element), 1].concat(replacement));\n}\nfunction cleanLocation(node) {\n  delete node.start;\n  delete node.end;\n  delete node.loc;\n  return node;\n}\nfunction ensureStatement(node) {\n  return types.Statement.check(node) ?\n  // Removing the location information seems to ensure that the node is\n  // correctly reprinted with a trailing semicolon\n  cleanLocation(node) : builders.expressionStatement(node);\n}\nfunction getVistor(varNames, nodes) {\n  return {\n    visitIdentifier: function visitIdentifier(path) {\n      this.traverse(path);\n      var node = path.node;\n      var parent = path.parent.node;\n\n      // If this identifier is not one of our generated ones, do nothing\n      var varIndex = varNames.indexOf(node.name);\n      if (varIndex === -1) {\n        return;\n      }\n      var replacement = nodes[varIndex];\n      nodes[varIndex] = null;\n\n      // If the replacement is an array, we need to explode the nodes in context\n      if (Array.isArray(replacement)) {\n        if (types.Function.check(parent) && parent.params.indexOf(node) > -1) {\n          // Function parameters: function foo(${bar}) {}\n          splice(parent.params, node, replacement);\n        } else if (types.VariableDeclarator.check(parent)) {\n          // Variable declarations: var foo = ${bar}, baz = 42;\n          splice(path.parent.parent.node.declarations, parent, replacement);\n        } else if (types.ArrayExpression.check(parent)) {\n          // Arrays: var foo = [${bar}, baz];\n          splice(parent.elements, node, replacement);\n        } else if (types.Property.check(parent) && parent.shorthand) {\n          // Objects: var foo = {${bar}, baz: 42};\n          splice(path.parent.parent.node.properties, parent, replacement);\n        } else if (types.CallExpression.check(parent) && parent.arguments.indexOf(node) > -1) {\n          // Function call arguments: foo(${bar}, baz)\n          splice(parent.arguments, node, replacement);\n        } else if (types.ExpressionStatement.check(parent)) {\n          // Generic sequence of statements: { ${foo}; bar; }\n          path.parent.replace.apply(path.parent, replacement.map(ensureStatement));\n        } else {\n          // Every else, let recast take care of it\n          path.replace.apply(path, replacement);\n        }\n      } else if (types.ExpressionStatement.check(parent)) {\n        path.parent.replace(ensureStatement(replacement));\n      } else {\n        path.replace(replacement);\n      }\n    }\n  };\n}\nfunction replaceNodes(src, varNames, nodes, parser) {\n  var ast = recast.parse(src, {\n    parser: parser\n  });\n  recast.visit(ast, getVistor(varNames, nodes));\n  return ast;\n}\nvar varNameCounter = 0;\nfunction getUniqueVarName() {\n  return \"$jscodeshift\".concat(varNameCounter++, \"$\");\n}\nmodule.exports = function withParser(parser) {\n  function statements(template /*, ...nodes*/) {\n    template = Array.from(template);\n    var nodes = Array.from(arguments).slice(1);\n    var varNames = nodes.map(function () {\n      return getUniqueVarName();\n    });\n    var src = template.reduce(function (result, elem, i) {\n      return result + varNames[i - 1] + elem;\n    });\n    return replaceNodes(src, varNames, nodes, parser).program.body;\n  }\n  function statement( /*template, ...nodes*/\n  ) {\n    return statements.apply(null, arguments)[0];\n  }\n  function expression(template /*, ...nodes*/) {\n    // wrap code in `(...)` to force evaluation as expression\n    template = Array.from(template);\n    if (template.length > 0) {\n      template[0] = '(' + template[0];\n      template[template.length - 1] += ')';\n    }\n    var expression = statement.apply(null, [template].concat(Array.from(arguments).slice(1))).expression;\n\n    // Remove added parens\n    if (expression.extra) {\n      expression.extra.parenthesized = false;\n    }\n    return expression;\n  }\n  return {\n    statements: statements,\n    statement: statement,\n    expression: expression\n  };\n};","map":{"version":3,"names":["recast","require","builders","types","namedTypes","splice","arr","element","replacement","apply","indexOf","concat","cleanLocation","node","start","end","loc","ensureStatement","Statement","check","expressionStatement","getVistor","varNames","nodes","visitIdentifier","path","traverse","parent","varIndex","name","Array","isArray","Function","params","VariableDeclarator","declarations","ArrayExpression","elements","Property","shorthand","properties","CallExpression","arguments","ExpressionStatement","replace","map","replaceNodes","src","parser","ast","parse","visit","varNameCounter","getUniqueVarName","module","exports","withParser","statements","template","from","slice","reduce","result","elem","i","program","body","statement","expression","length","extra","parenthesized"],"sources":["C:/Users/Acer/Desktop/dev__book/dev__book/node_modules/jscodeshift/src/template.js"],"sourcesContent":["\n/**\n * Copyright (c) Facebook, Inc. and its affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n */\n\n'use strict';\n\nconst recast = require('recast');\n\nconst builders = recast.types.builders;\nconst types = recast.types.namedTypes;\n\nfunction splice(arr, element, replacement) {\n  arr.splice.apply(arr, [arr.indexOf(element), 1].concat(replacement));\n}\n\nfunction cleanLocation(node) {\n  delete node.start;\n  delete node.end;\n  delete node.loc;\n  return node;\n}\n\nfunction ensureStatement(node) {\n  return types.Statement.check(node) ?\n    // Removing the location information seems to ensure that the node is\n    // correctly reprinted with a trailing semicolon\n    cleanLocation(node) :\n    builders.expressionStatement(node);\n}\n\nfunction getVistor(varNames, nodes) {\n  return {\n    visitIdentifier: function(path) {\n      this.traverse(path);\n      const node = path.node;\n      const parent = path.parent.node;\n\n      // If this identifier is not one of our generated ones, do nothing\n      const varIndex = varNames.indexOf(node.name);\n      if (varIndex === -1) {\n        return;\n      }\n\n      let replacement = nodes[varIndex];\n      nodes[varIndex] = null;\n\n      // If the replacement is an array, we need to explode the nodes in context\n      if (Array.isArray(replacement)) {\n\n        if (types.Function.check(parent) &&\n            parent.params.indexOf(node) > -1) {\n          // Function parameters: function foo(${bar}) {}\n          splice(parent.params, node, replacement);\n        } else if (types.VariableDeclarator.check(parent)) {\n          // Variable declarations: var foo = ${bar}, baz = 42;\n          splice(\n            path.parent.parent.node.declarations,\n            parent,\n            replacement\n          );\n        } else if (types.ArrayExpression.check(parent)) {\n          // Arrays: var foo = [${bar}, baz];\n          splice(parent.elements, node, replacement);\n        } else if (types.Property.check(parent) && parent.shorthand) {\n          // Objects: var foo = {${bar}, baz: 42};\n          splice(\n            path.parent.parent.node.properties,\n            parent,\n            replacement\n          );\n        } else if (types.CallExpression.check(parent) &&\n            parent.arguments.indexOf(node) > -1) {\n          // Function call arguments: foo(${bar}, baz)\n          splice(parent.arguments, node, replacement);\n        } else if (types.ExpressionStatement.check(parent)) {\n          // Generic sequence of statements: { ${foo}; bar; }\n          path.parent.replace.apply(\n            path.parent,\n            replacement.map(ensureStatement)\n          );\n        } else {\n          // Every else, let recast take care of it\n          path.replace.apply(path, replacement);\n        }\n      } else if (types.ExpressionStatement.check(parent)) {\n        path.parent.replace(ensureStatement(replacement));\n      } else {\n        path.replace(replacement);\n      }\n    }\n  };\n}\n\nfunction replaceNodes(src, varNames, nodes, parser) {\n  const ast = recast.parse(src, {parser});\n  recast.visit(ast, getVistor(varNames, nodes));\n  return ast;\n}\n\nlet varNameCounter = 0;\nfunction getUniqueVarName() {\n  return `$jscodeshift${varNameCounter++}$`;\n}\n\n\nmodule.exports = function withParser(parser) {\n  function statements(template/*, ...nodes*/) {\n    template = Array.from(template);\n    const nodes = Array.from(arguments).slice(1);\n    const varNames = nodes.map(() => getUniqueVarName());\n    const src = template.reduce(\n      (result, elem, i) => result + varNames[i - 1] + elem\n    );\n\n    return replaceNodes(\n      src,\n      varNames,\n      nodes,\n      parser\n    ).program.body;\n  }\n\n  function statement(/*template, ...nodes*/) {\n    return statements.apply(null, arguments)[0];\n  }\n\n  function expression(template/*, ...nodes*/) {\n    // wrap code in `(...)` to force evaluation as expression\n    template = Array.from(template);\n    if (template.length > 0) {\n      template[0] = '(' + template[0];\n      template[template.length - 1] += ')';\n    }\n\n    const expression = statement.apply(\n      null,\n      [template].concat(Array.from(arguments).slice(1))\n    ).expression;\n\n    // Remove added parens\n    if (expression.extra) {\n      expression.extra.parenthesized = false;\n    }\n\n    return expression;\n  }\n\n  return {statements, statement, expression};\n}\n"],"mappings":"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"},"metadata":{},"sourceType":"script"}