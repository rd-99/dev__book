{"ast":null,"code":"/**\n * Copyright (c) Facebook, Inc. and its affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n */\n\n'use strict';\n\nconst Collection = require('./Collection');\nconst collections = require('./collections');\nconst getParser = require('./getParser');\nconst matchNode = require('./matchNode');\nconst recast = require('recast');\nconst template = require('./template');\nconst Node = recast.types.namedTypes.Node;\nconst NodePath = recast.types.NodePath;\n\n// Register all built-in collections\nfor (var name in collections) {\n  collections[name].register();\n}\n\n/**\n * Main entry point to the tool. The function accepts multiple different kinds\n * of arguments as a convenience. In particular the function accepts either\n *\n * - a string containing source code\n *   The string is parsed with Recast\n * - a single AST node\n * - a single node path\n * - an array of nodes\n * - an array of node paths\n *\n * @exports jscodeshift\n * @param {Node|NodePath|Array|string} source\n * @param {Object} options Options to pass to Recast when passing source code\n * @return {Collection}\n */\nfunction core(source, options) {\n  return typeof source === 'string' ? fromSource(source, options) : fromAST(source);\n}\n\n/**\n * Returns a collection from a node, node path, array of nodes or array of node\n * paths.\n *\n * @ignore\n * @param {Node|NodePath|Array} source\n * @return {Collection}\n */\nfunction fromAST(ast) {\n  if (Array.isArray(ast)) {\n    if (ast[0] instanceof NodePath || ast.length === 0) {\n      return Collection.fromPaths(ast);\n    } else if (Node.check(ast[0])) {\n      return Collection.fromNodes(ast);\n    }\n  } else {\n    if (ast instanceof NodePath) {\n      return Collection.fromPaths([ast]);\n    } else if (Node.check(ast)) {\n      return Collection.fromNodes([ast]);\n    }\n  }\n  throw new TypeError('Received an unexpected value ' + Object.prototype.toString.call(ast));\n}\nfunction fromSource(source, options) {\n  if (!options) {\n    options = {};\n  }\n  if (!options.parser) {\n    options.parser = getParser();\n  }\n  return fromAST(recast.parse(source, options));\n}\n\n/**\n * Utility function to match a node against a pattern.\n * @augments core\n * @static\n * @param {Node|NodePath|Object} path\n * @parma {Object} filter\n * @return boolean\n */\nfunction match(path, filter) {\n  if (!(path instanceof NodePath)) {\n    if (typeof path.get === 'function') {\n      path = path.get();\n    } else {\n      path = {\n        value: path\n      };\n    }\n  }\n  return matchNode(path.value, filter);\n}\nconst plugins = [];\n\n/**\n * Utility function for registering plugins.\n *\n * Plugins are simple functions that are passed the core jscodeshift instance.\n * They should extend jscodeshift by calling `registerMethods`, etc.\n * This method guards against repeated registrations (the plugin callback will only be called once).\n *\n * @augments core\n * @static\n * @param {Function} plugin\n */\nfunction use(plugin) {\n  if (plugins.indexOf(plugin) === -1) {\n    plugins.push(plugin);\n    plugin(core);\n  }\n}\n\n/**\n * Returns a version of the core jscodeshift function \"bound\" to a specific\n * parser.\n *\n * @augments core\n * @static\n */\nfunction withParser(parser) {\n  if (typeof parser === 'string') {\n    parser = getParser(parser);\n  }\n  const newCore = function (source, options) {\n    if (options && !options.parser) {\n      options.parser = parser;\n    } else {\n      options = {\n        parser\n      };\n    }\n    return core(source, options);\n  };\n  return enrichCore(newCore, parser);\n}\n\n/**\n* The ast-types library\n* @external astTypes\n* @see {@link https://github.com/benjamn/ast-types}\n*/\n\nfunction enrichCore(core, parser) {\n  // add builders and types to the function for simple access\n  Object.assign(core, recast.types.namedTypes);\n  Object.assign(core, recast.types.builders);\n  core.registerMethods = Collection.registerMethods;\n  /**\n  * @augments core\n  * @type external:astTypes\n  */\n  core.types = recast.types;\n  core.match = match;\n  core.template = template(parser);\n\n  // add mappings and filters to function\n  core.filters = {};\n  core.mappings = {};\n  for (const name in collections) {\n    if (collections[name].filters) {\n      core.filters[name] = collections[name].filters;\n    }\n    if (collections[name].mappings) {\n      core.mappings[name] = collections[name].mappings;\n    }\n  }\n  core.use = use;\n  core.withParser = withParser;\n  return core;\n}\nmodule.exports = enrichCore(core, getParser());","map":{"version":3,"names":["Collection","require","collections","getParser","matchNode","recast","template","Node","types","namedTypes","NodePath","name","register","core","source","options","fromSource","fromAST","ast","Array","isArray","length","fromPaths","check","fromNodes","TypeError","Object","prototype","toString","call","parser","parse","match","path","filter","get","value","plugins","use","plugin","indexOf","push","withParser","newCore","enrichCore","assign","builders","registerMethods","filters","mappings","module","exports"],"sources":["C:/Users/Acer/Desktop/dev__book/dev__book/node_modules/jscodeshift/src/core.js"],"sourcesContent":["\n/**\n * Copyright (c) Facebook, Inc. and its affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n */\n\n'use strict';\nconst Collection = require('./Collection');\n\nconst collections = require('./collections');\nconst getParser = require('./getParser');\nconst matchNode = require('./matchNode');\nconst recast = require('recast');\nconst template = require('./template');\n\nconst Node = recast.types.namedTypes.Node;\nconst NodePath = recast.types.NodePath;\n\n// Register all built-in collections\nfor (var name in collections) {\n  collections[name].register();\n}\n\n/**\n * Main entry point to the tool. The function accepts multiple different kinds\n * of arguments as a convenience. In particular the function accepts either\n *\n * - a string containing source code\n *   The string is parsed with Recast\n * - a single AST node\n * - a single node path\n * - an array of nodes\n * - an array of node paths\n *\n * @exports jscodeshift\n * @param {Node|NodePath|Array|string} source\n * @param {Object} options Options to pass to Recast when passing source code\n * @return {Collection}\n */\nfunction core(source, options) {\n  return typeof source === 'string' ?\n    fromSource(source, options) :\n    fromAST(source);\n}\n\n/**\n * Returns a collection from a node, node path, array of nodes or array of node\n * paths.\n *\n * @ignore\n * @param {Node|NodePath|Array} source\n * @return {Collection}\n */\nfunction fromAST(ast) {\n  if (Array.isArray(ast)) {\n    if (ast[0] instanceof NodePath || ast.length === 0) {\n      return Collection.fromPaths(ast);\n    } else if (Node.check(ast[0])) {\n      return Collection.fromNodes(ast);\n    }\n  } else {\n    if (ast instanceof NodePath) {\n      return Collection.fromPaths([ast]);\n    } else if (Node.check(ast)) {\n      return Collection.fromNodes([ast]);\n    }\n  }\n  throw new TypeError(\n    'Received an unexpected value ' + Object.prototype.toString.call(ast)\n  );\n}\n\nfunction fromSource(source, options) {\n  if (!options) {\n    options = {};\n  }\n  if (!options.parser) {\n    options.parser = getParser();\n  }\n  return fromAST(recast.parse(source, options));\n}\n\n/**\n * Utility function to match a node against a pattern.\n * @augments core\n * @static\n * @param {Node|NodePath|Object} path\n * @parma {Object} filter\n * @return boolean\n */\nfunction match(path, filter) {\n  if (!(path instanceof NodePath)) {\n    if (typeof path.get === 'function') {\n      path = path.get();\n    } else {\n      path = {value: path};\n    }\n  }\n  return matchNode(path.value, filter);\n}\n\nconst plugins = [];\n\n/**\n * Utility function for registering plugins.\n *\n * Plugins are simple functions that are passed the core jscodeshift instance.\n * They should extend jscodeshift by calling `registerMethods`, etc.\n * This method guards against repeated registrations (the plugin callback will only be called once).\n *\n * @augments core\n * @static\n * @param {Function} plugin\n */\nfunction use(plugin) {\n  if (plugins.indexOf(plugin) === -1) {\n    plugins.push(plugin);\n    plugin(core);\n  }\n}\n\n/**\n * Returns a version of the core jscodeshift function \"bound\" to a specific\n * parser.\n *\n * @augments core\n * @static\n */\nfunction withParser(parser) {\n  if (typeof parser === 'string') {\n    parser = getParser(parser);\n  }\n\n  const newCore = function(source, options) {\n    if (options && !options.parser) {\n      options.parser = parser;\n    } else {\n      options = {parser};\n    }\n    return core(source, options);\n  };\n\n  return enrichCore(newCore, parser);\n}\n\n/**\n* The ast-types library\n* @external astTypes\n* @see {@link https://github.com/benjamn/ast-types}\n*/\n\nfunction enrichCore(core, parser) {\n  // add builders and types to the function for simple access\n  Object.assign(core, recast.types.namedTypes);\n  Object.assign(core, recast.types.builders);\n  core.registerMethods = Collection.registerMethods;\n  /**\n  * @augments core\n  * @type external:astTypes\n  */\n  core.types = recast.types;\n  core.match = match;\n  core.template = template(parser);\n\n  // add mappings and filters to function\n  core.filters = {};\n  core.mappings = {};\n  for (const name in collections) {\n    if (collections[name].filters) {\n      core.filters[name] = collections[name].filters;\n    }\n    if (collections[name].mappings) {\n      core.mappings[name] = collections[name].mappings;\n    }\n  }\n  core.use = use;\n  core.withParser = withParser;\n  return core;\n}\n\nmodule.exports = enrichCore(core, getParser());\n"],"mappings":"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"},"metadata":{},"sourceType":"script"}