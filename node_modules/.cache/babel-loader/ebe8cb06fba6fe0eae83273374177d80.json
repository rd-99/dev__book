{"ast":null,"code":"/**\n * Copyright (c) Facebook, Inc. and its affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n */\n\n'use strict';\n\nconst Collection = require('../Collection');\nconst matchNode = require('../matchNode');\nconst once = require('../utils/once');\nconst recast = require('recast');\nconst Node = recast.types.namedTypes.Node;\nvar types = recast.types.namedTypes;\n\n/**\n* @mixin\n*/\nconst traversalMethods = {\n  /**\n   * Find nodes of a specific type within the nodes of this collection.\n   *\n   * @param {type}\n   * @param {filter}\n   * @return {Collection}\n   */\n  find: function (type, filter) {\n    const paths = [];\n    const visitorMethodName = 'visit' + type;\n    const visitor = {};\n    function visit(path) {\n      /*jshint validthis:true */\n      if (!filter || matchNode(path.value, filter)) {\n        paths.push(path);\n      }\n      this.traverse(path);\n    }\n    this.__paths.forEach(function (p, i) {\n      const self = this;\n      visitor[visitorMethodName] = function (path) {\n        if (self.__paths[i] === path) {\n          this.traverse(path);\n        } else {\n          return visit.call(this, path);\n        }\n      };\n      recast.visit(p, visitor);\n    }, this);\n    return Collection.fromPaths(paths, this, type);\n  },\n  /**\n   * Returns a collection containing the paths that create the scope of the\n   * currently selected paths. Dedupes the paths.\n   *\n   * @return {Collection}\n   */\n  closestScope: function () {\n    return this.map(path => path.scope && path.scope.path);\n  },\n  /**\n   * Traverse the AST up and finds the closest node of the provided type.\n   *\n   * @param {Collection}\n   * @param {filter}\n   * @return {Collection}\n   */\n  closest: function (type, filter) {\n    return this.map(function (path) {\n      let parent = path.parent;\n      while (parent && !(type.check(parent.value) && (!filter || matchNode(parent.value, filter)))) {\n        parent = parent.parent;\n      }\n      return parent || null;\n    });\n  },\n  /**\n   * Finds the declaration for each selected path. Useful for member expressions\n   * or JSXElements. Expects a callback function that maps each path to the name\n   * to look for.\n   *\n   * If the callback returns a falsey value, the element is skipped.\n   *\n   * @param {function} nameGetter\n   *\n   * @return {Collection}\n   */\n  getVariableDeclarators: function (nameGetter) {\n    return this.map(function (path) {\n      /*jshint curly:false*/\n      let scope = path.scope;\n      if (!scope) return;\n      const name = nameGetter.apply(path, arguments);\n      if (!name) return;\n      scope = scope.lookup(name);\n      if (!scope) return;\n      const bindings = scope.getBindings()[name];\n      if (!bindings) return;\n      const decl = Collection.fromPaths(bindings).closest(types.VariableDeclarator);\n      if (decl.length === 1) {\n        return decl.paths()[0];\n      }\n    }, types.VariableDeclarator);\n  }\n};\nfunction toArray(value) {\n  return Array.isArray(value) ? value : [value];\n}\n\n/**\n* @mixin\n*/\nconst mutationMethods = {\n  /**\n   * Simply replaces the selected nodes with the provided node. If a function\n   * is provided it is executed for every node and the node is replaced with the\n   * functions return value.\n   *\n   * @param {Node|Array<Node>|function} nodes\n   * @return {Collection}\n   */\n  replaceWith: function (nodes) {\n    return this.forEach(function (path, i) {\n      const newNodes = typeof nodes === 'function' ? nodes.call(path, path, i) : nodes;\n      path.replace.apply(path, toArray(newNodes));\n    });\n  },\n  /**\n   * Inserts a new node before the current one.\n   *\n   * @param {Node|Array<Node>|function} insert\n   * @return {Collection}\n   */\n  insertBefore: function (insert) {\n    return this.forEach(function (path, i) {\n      const newNodes = typeof insert === 'function' ? insert.call(path, path, i) : insert;\n      path.insertBefore.apply(path, toArray(newNodes));\n    });\n  },\n  /**\n   * Inserts a new node after the current one.\n   *\n   * @param {Node|Array<Node>|function} insert\n   * @return {Collection}\n   */\n  insertAfter: function (insert) {\n    return this.forEach(function (path, i) {\n      const newNodes = typeof insert === 'function' ? insert.call(path, path, i) : insert;\n      path.insertAfter.apply(path, toArray(newNodes));\n    });\n  },\n  remove: function () {\n    return this.forEach(path => path.prune());\n  }\n};\nfunction register() {\n  Collection.registerMethods(traversalMethods, Node);\n  Collection.registerMethods(mutationMethods, Node);\n  Collection.setDefaultCollectionType(Node);\n}\nexports.register = once(register);","map":{"version":3,"names":["Collection","require","matchNode","once","recast","Node","types","namedTypes","traversalMethods","find","type","filter","paths","visitorMethodName","visitor","visit","path","value","push","traverse","__paths","forEach","p","i","self","call","fromPaths","closestScope","map","scope","closest","parent","check","getVariableDeclarators","nameGetter","name","apply","arguments","lookup","bindings","getBindings","decl","VariableDeclarator","length","toArray","Array","isArray","mutationMethods","replaceWith","nodes","newNodes","replace","insertBefore","insert","insertAfter","remove","prune","register","registerMethods","setDefaultCollectionType","exports"],"sources":["C:/Users/Acer/Desktop/dev__book/dev__book/node_modules/jscodeshift/src/collections/Node.js"],"sourcesContent":["\n/**\n * Copyright (c) Facebook, Inc. and its affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n */\n\n'use strict';\n\nconst Collection = require('../Collection');\n\nconst matchNode = require('../matchNode');\nconst once = require('../utils/once');\nconst recast = require('recast');\n\nconst Node = recast.types.namedTypes.Node;\nvar types = recast.types.namedTypes;\n\n/**\n* @mixin\n*/\nconst traversalMethods = {\n\n  /**\n   * Find nodes of a specific type within the nodes of this collection.\n   *\n   * @param {type}\n   * @param {filter}\n   * @return {Collection}\n   */\n  find: function(type, filter) {\n    const paths = [];\n    const visitorMethodName = 'visit' + type;\n\n    const visitor = {};\n    function visit(path) {\n      /*jshint validthis:true */\n      if (!filter || matchNode(path.value, filter)) {\n        paths.push(path);\n      }\n      this.traverse(path);\n    }\n    this.__paths.forEach(function(p, i) {\n      const self = this;\n      visitor[visitorMethodName] = function(path) {\n        if (self.__paths[i] === path) {\n          this.traverse(path);\n        } else {\n          return visit.call(this, path);\n        }\n      };\n      recast.visit(p, visitor);\n    }, this);\n\n    return Collection.fromPaths(paths, this, type);\n  },\n\n  /**\n   * Returns a collection containing the paths that create the scope of the\n   * currently selected paths. Dedupes the paths.\n   *\n   * @return {Collection}\n   */\n  closestScope: function() {\n    return this.map(path => path.scope && path.scope.path);\n  },\n\n  /**\n   * Traverse the AST up and finds the closest node of the provided type.\n   *\n   * @param {Collection}\n   * @param {filter}\n   * @return {Collection}\n   */\n  closest: function(type, filter) {\n    return this.map(function(path) {\n      let parent = path.parent;\n      while (\n        parent &&\n        !(\n          type.check(parent.value) &&\n          (!filter || matchNode(parent.value, filter))\n        )\n      ) {\n        parent = parent.parent;\n      }\n      return parent || null;\n    });\n  },\n\n  /**\n   * Finds the declaration for each selected path. Useful for member expressions\n   * or JSXElements. Expects a callback function that maps each path to the name\n   * to look for.\n   *\n   * If the callback returns a falsey value, the element is skipped.\n   *\n   * @param {function} nameGetter\n   *\n   * @return {Collection}\n   */\n  getVariableDeclarators: function(nameGetter) {\n    return this.map(function(path) {\n      /*jshint curly:false*/\n      let scope = path.scope;\n      if (!scope) return;\n      const name = nameGetter.apply(path, arguments);\n      if (!name) return;\n      scope = scope.lookup(name);\n      if (!scope) return;\n      const bindings = scope.getBindings()[name];\n      if (!bindings) return;\n      const decl = Collection.fromPaths(bindings)\n        .closest(types.VariableDeclarator);\n      if (decl.length === 1) {\n        return decl.paths()[0];\n      }\n    }, types.VariableDeclarator);\n  },\n};\n\nfunction toArray(value) {\n  return Array.isArray(value) ? value : [value];\n}\n\n/**\n* @mixin\n*/\nconst mutationMethods = {\n  /**\n   * Simply replaces the selected nodes with the provided node. If a function\n   * is provided it is executed for every node and the node is replaced with the\n   * functions return value.\n   *\n   * @param {Node|Array<Node>|function} nodes\n   * @return {Collection}\n   */\n  replaceWith: function(nodes) {\n    return this.forEach(function(path, i) {\n      const newNodes =\n        (typeof nodes === 'function') ? nodes.call(path, path, i) : nodes;\n      path.replace.apply(path, toArray(newNodes));\n    });\n  },\n\n  /**\n   * Inserts a new node before the current one.\n   *\n   * @param {Node|Array<Node>|function} insert\n   * @return {Collection}\n   */\n  insertBefore: function(insert) {\n    return this.forEach(function(path, i) {\n      const newNodes =\n        (typeof insert === 'function') ? insert.call(path, path, i) : insert;\n      path.insertBefore.apply(path, toArray(newNodes));\n    });\n  },\n\n  /**\n   * Inserts a new node after the current one.\n   *\n   * @param {Node|Array<Node>|function} insert\n   * @return {Collection}\n   */\n  insertAfter: function(insert) {\n    return this.forEach(function(path, i) {\n      const newNodes =\n        (typeof insert === 'function') ? insert.call(path, path, i) : insert;\n      path.insertAfter.apply(path, toArray(newNodes));\n    });\n  },\n\n  remove: function() {\n    return this.forEach(path => path.prune());\n  }\n\n};\n\nfunction register() {\n  Collection.registerMethods(traversalMethods, Node);\n  Collection.registerMethods(mutationMethods, Node);\n  Collection.setDefaultCollectionType(Node);\n}\n\nexports.register = once(register);\n"],"mappings":"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"},"metadata":{},"sourceType":"script"}