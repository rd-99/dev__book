{"ast":null,"code":"/**\n * Copyright (c) Facebook, Inc. and its affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n */\n\n'use strict';\n\nconst Collection = require('../Collection');\nconst NodeCollection = require('./Node');\nconst assert = require('assert');\nconst once = require('../utils/once');\nconst recast = require('recast');\nconst requiresModule = require('./VariableDeclarator').filters.requiresModule;\nconst types = recast.types.namedTypes;\nconst JSXElement = types.JSXElement;\nconst JSXAttribute = types.JSXAttribute;\nconst Literal = types.Literal;\n\n/**\n * Contains filter methods and mutation methods for processing JSXElements.\n * @mixin\n */\nconst globalMethods = {\n  /**\n   * Finds all JSXElements optionally filtered by name\n   *\n   * @param {string} name\n   * @return {Collection}\n   */\n  findJSXElements: function (name) {\n    const nameFilter = name && {\n      openingElement: {\n        name: {\n          name: name\n        }\n      }\n    };\n    return this.find(JSXElement, nameFilter);\n  },\n  /**\n   * Finds all JSXElements by module name. Given\n   *\n   *     var Bar = require('Foo');\n   *     <Bar />\n   *\n   * findJSXElementsByModuleName('Foo') will find <Bar />, without having to\n   * know the variable name.\n   */\n  findJSXElementsByModuleName: function (moduleName) {\n    assert.ok(moduleName && typeof moduleName === 'string', 'findJSXElementsByModuleName(...) needs a name to look for');\n    return this.find(types.VariableDeclarator).filter(requiresModule(moduleName)).map(function (path) {\n      const id = path.value.id.name;\n      if (id) {\n        return Collection.fromPaths([path]).closestScope().findJSXElements(id).paths();\n      }\n    });\n  }\n};\nconst filterMethods = {\n  /**\n   * Filter method for attributes.\n   *\n   * @param {Object} attributeFilter\n   * @return {function}\n   */\n  hasAttributes: function (attributeFilter) {\n    const attributeNames = Object.keys(attributeFilter);\n    return function filter(path) {\n      if (!JSXElement.check(path.value)) {\n        return false;\n      }\n      const elementAttributes = Object.create(null);\n      path.value.openingElement.attributes.forEach(function (attr) {\n        if (!JSXAttribute.check(attr) || !(attr.name.name in attributeFilter)) {\n          return;\n        }\n        elementAttributes[attr.name.name] = attr;\n      });\n      return attributeNames.every(function (name) {\n        if (!(name in elementAttributes)) {\n          return false;\n        }\n        const value = elementAttributes[name].value;\n        const expected = attributeFilter[name];\n\n        // Only when value is truthy access it's properties\n        const actual = !value ? value : Literal.check(value) ? value.value : value.expression;\n        if (typeof expected === 'function') {\n          return expected(actual);\n        }\n\n        // Literal attribute values are always strings\n        return String(expected) === actual;\n      });\n    };\n  },\n  /**\n   * Filter elements which contain a specific child type\n   *\n   * @param {string} name\n   * @return {function}\n   */\n  hasChildren: function (name) {\n    return function filter(path) {\n      return JSXElement.check(path.value) && path.value.children.some(child => JSXElement.check(child) && child.openingElement.name.name === name);\n    };\n  }\n};\n\n/**\n* @mixin\n*/\nconst traversalMethods = {\n  /**\n   * Returns all child nodes, including literals and expressions.\n   *\n   * @return {Collection}\n   */\n  childNodes: function () {\n    const paths = [];\n    this.forEach(function (path) {\n      const children = path.get('children');\n      const l = children.value.length;\n      for (let i = 0; i < l; i++) {\n        paths.push(children.get(i));\n      }\n    });\n    return Collection.fromPaths(paths, this);\n  },\n  /**\n   * Returns all children that are JSXElements.\n   *\n   * @return {JSXElementCollection}\n   */\n  childElements: function () {\n    const paths = [];\n    this.forEach(function (path) {\n      const children = path.get('children');\n      const l = children.value.length;\n      for (let i = 0; i < l; i++) {\n        if (types.JSXElement.check(children.value[i])) {\n          paths.push(children.get(i));\n        }\n      }\n    });\n    return Collection.fromPaths(paths, this, JSXElement);\n  }\n};\nconst mappingMethods = {\n  /**\n   * Given a JSXElement, returns its \"root\" name. E.g. it would return \"Foo\" for\n   * both <Foo /> and <Foo.Bar />.\n   *\n   * @param {NodePath} path\n   * @return {string}\n   */\n  getRootName: function (path) {\n    let name = path.value.openingElement.name;\n    while (types.JSXMemberExpression.check(name)) {\n      name = name.object;\n    }\n    return name && name.name || null;\n  }\n};\nfunction register() {\n  NodeCollection.register();\n  Collection.registerMethods(globalMethods, types.Node);\n  Collection.registerMethods(traversalMethods, JSXElement);\n}\nexports.register = once(register);\nexports.filters = filterMethods;\nexports.mappings = mappingMethods;","map":{"version":3,"names":["Collection","require","NodeCollection","assert","once","recast","requiresModule","filters","types","namedTypes","JSXElement","JSXAttribute","Literal","globalMethods","findJSXElements","name","nameFilter","openingElement","find","findJSXElementsByModuleName","moduleName","ok","VariableDeclarator","filter","map","path","id","value","fromPaths","closestScope","paths","filterMethods","hasAttributes","attributeFilter","attributeNames","Object","keys","check","elementAttributes","create","attributes","forEach","attr","every","expected","actual","expression","String","hasChildren","children","some","child","traversalMethods","childNodes","get","l","length","i","push","childElements","mappingMethods","getRootName","JSXMemberExpression","object","register","registerMethods","Node","exports","mappings"],"sources":["C:/Users/Acer/Desktop/dev__book/dev__book/node_modules/jscodeshift/src/collections/JSXElement.js"],"sourcesContent":["\n/**\n * Copyright (c) Facebook, Inc. and its affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n */\n\n'use strict';\n\nconst Collection = require('../Collection');\nconst NodeCollection = require('./Node');\n\nconst assert = require('assert');\nconst once = require('../utils/once');\nconst recast = require('recast');\nconst requiresModule = require('./VariableDeclarator').filters.requiresModule;\n\nconst types = recast.types.namedTypes;\nconst JSXElement = types.JSXElement;\nconst JSXAttribute = types.JSXAttribute;\nconst Literal = types.Literal;\n\n/**\n * Contains filter methods and mutation methods for processing JSXElements.\n * @mixin\n */\nconst globalMethods = {\n  /**\n   * Finds all JSXElements optionally filtered by name\n   *\n   * @param {string} name\n   * @return {Collection}\n   */\n  findJSXElements: function(name) {\n    const nameFilter = name && {openingElement: {name: {name: name}}};\n    return this.find(JSXElement, nameFilter);\n  },\n\n  /**\n   * Finds all JSXElements by module name. Given\n   *\n   *     var Bar = require('Foo');\n   *     <Bar />\n   *\n   * findJSXElementsByModuleName('Foo') will find <Bar />, without having to\n   * know the variable name.\n   */\n  findJSXElementsByModuleName: function(moduleName) {\n    assert.ok(\n      moduleName && typeof moduleName === 'string',\n      'findJSXElementsByModuleName(...) needs a name to look for'\n    );\n\n    return this.find(types.VariableDeclarator)\n      .filter(requiresModule(moduleName))\n      .map(function(path) {\n        const id = path.value.id.name;\n        if (id) {\n          return Collection.fromPaths([path])\n            .closestScope()\n            .findJSXElements(id)\n            .paths();\n        }\n      });\n  }\n};\n\nconst filterMethods = {\n\n  /**\n   * Filter method for attributes.\n   *\n   * @param {Object} attributeFilter\n   * @return {function}\n   */\n  hasAttributes: function(attributeFilter) {\n    const attributeNames = Object.keys(attributeFilter);\n    return function filter(path) {\n      if (!JSXElement.check(path.value)) {\n        return false;\n      }\n      const elementAttributes = Object.create(null);\n      path.value.openingElement.attributes.forEach(function(attr) {\n        if (!JSXAttribute.check(attr) ||\n          !(attr.name.name in attributeFilter)) {\n          return;\n        }\n        elementAttributes[attr.name.name] = attr;\n      });\n\n      return attributeNames.every(function(name) {\n        if (!(name in elementAttributes) ){\n          return false;\n        }\n\n        const value = elementAttributes[name].value;\n        const expected = attributeFilter[name];\n\n        // Only when value is truthy access it's properties\n        const actual = !value\n          ? value\n          : Literal.check(value)\n          ? value.value\n          : value.expression;\n\n        if (typeof expected === 'function') {\n          return expected(actual);\n        }\n\n         // Literal attribute values are always strings\n        return String(expected) === actual;\n      });\n    };\n  },\n\n  /**\n   * Filter elements which contain a specific child type\n   *\n   * @param {string} name\n   * @return {function}\n   */\n  hasChildren: function(name) {\n    return function filter(path) {\n      return JSXElement.check(path.value) &&\n        path.value.children.some(\n          child => JSXElement.check(child) &&\n                   child.openingElement.name.name === name\n        );\n    };\n  }\n};\n\n/**\n* @mixin\n*/\nconst traversalMethods = {\n\n  /**\n   * Returns all child nodes, including literals and expressions.\n   *\n   * @return {Collection}\n   */\n  childNodes: function() {\n    const paths = [];\n    this.forEach(function(path) {\n      const children = path.get('children');\n      const l = children.value.length;\n      for (let i = 0; i < l; i++) {\n        paths.push(children.get(i));\n      }\n    });\n    return Collection.fromPaths(paths, this);\n  },\n\n  /**\n   * Returns all children that are JSXElements.\n   *\n   * @return {JSXElementCollection}\n   */\n  childElements: function() {\n    const paths = [];\n    this.forEach(function(path) {\n      const children = path.get('children');\n      const l = children.value.length;\n      for (let i = 0; i < l; i++) {\n        if (types.JSXElement.check(children.value[i])) {\n          paths.push(children.get(i));\n        }\n      }\n    });\n    return Collection.fromPaths(paths, this, JSXElement);\n  },\n};\n\nconst mappingMethods = {\n  /**\n   * Given a JSXElement, returns its \"root\" name. E.g. it would return \"Foo\" for\n   * both <Foo /> and <Foo.Bar />.\n   *\n   * @param {NodePath} path\n   * @return {string}\n   */\n  getRootName: function(path) {\n    let name = path.value.openingElement.name;\n    while (types.JSXMemberExpression.check(name)) {\n      name = name.object;\n    }\n\n    return name && name.name || null;\n  }\n};\n\nfunction register() {\n  NodeCollection.register();\n  Collection.registerMethods(globalMethods, types.Node);\n  Collection.registerMethods(traversalMethods, JSXElement);\n}\n\nexports.register = once(register);\nexports.filters = filterMethods;\nexports.mappings = mappingMethods;\n"],"mappings":"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"},"metadata":{},"sourceType":"script"}