{"ast":null,"code":"module.exports = create;\nvar classifyCharacter = require('micromark/dist/util/classify-character');\nvar chunkedSplice = require('micromark/dist/util/chunked-splice');\nvar resolveAll = require('micromark/dist/util/resolve-all');\nvar shallow = require('micromark/dist/util/shallow');\nfunction create(options) {\n  var settings = options || {};\n  var single = settings.singleTilde;\n  var tokenizer = {\n    tokenize: tokenizeStrikethrough,\n    resolveAll: resolveAllStrikethrough\n  };\n  if (single === null || single === undefined) {\n    single = true;\n  }\n  return {\n    text: {\n      126: tokenizer\n    },\n    insideSpan: {\n      null: tokenizer\n    }\n  };\n\n  // Take events and resolve strikethrough.\n  function resolveAllStrikethrough(events, context) {\n    var index = -1;\n    var strikethrough;\n    var text;\n    var open;\n    var nextEvents;\n\n    // Walk through all events.\n    while (++index < events.length) {\n      // Find a token that can close.\n      if (events[index][0] === 'enter' && events[index][1].type === 'strikethroughSequenceTemporary' && events[index][1]._close) {\n        open = index;\n\n        // Now walk back to find an opener.\n        while (open--) {\n          // Find a token that can open the closer.\n          if (events[open][0] === 'exit' && events[open][1].type === 'strikethroughSequenceTemporary' && events[open][1]._open &&\n          // If the sizes are the same:\n          events[index][1].end.offset - events[index][1].start.offset === events[open][1].end.offset - events[open][1].start.offset) {\n            events[index][1].type = 'strikethroughSequence';\n            events[open][1].type = 'strikethroughSequence';\n            strikethrough = {\n              type: 'strikethrough',\n              start: shallow(events[open][1].start),\n              end: shallow(events[index][1].end)\n            };\n            text = {\n              type: 'strikethroughText',\n              start: shallow(events[open][1].end),\n              end: shallow(events[index][1].start)\n            };\n\n            // Opening.\n            nextEvents = [['enter', strikethrough, context], ['enter', events[open][1], context], ['exit', events[open][1], context], ['enter', text, context]];\n\n            // Between.\n            chunkedSplice(nextEvents, nextEvents.length, 0, resolveAll(context.parser.constructs.insideSpan.null, events.slice(open + 1, index), context));\n\n            // Closing.\n            chunkedSplice(nextEvents, nextEvents.length, 0, [['exit', text, context], ['enter', events[index][1], context], ['exit', events[index][1], context], ['exit', strikethrough, context]]);\n            chunkedSplice(events, open - 1, index - open + 3, nextEvents);\n            index = open + nextEvents.length - 2;\n            break;\n          }\n        }\n      }\n    }\n    return removeRemainingSequences(events);\n  }\n  function removeRemainingSequences(events) {\n    var index = -1;\n    var length = events.length;\n    while (++index < length) {\n      if (events[index][1].type === 'strikethroughSequenceTemporary') {\n        events[index][1].type = 'data';\n      }\n    }\n    return events;\n  }\n  function tokenizeStrikethrough(effects, ok, nok) {\n    var previous = this.previous;\n    var events = this.events;\n    var size = 0;\n    return start;\n    function start(code) {\n      if (code !== 126 || previous === 126 && events[events.length - 1][1].type !== 'characterEscape') {\n        return nok(code);\n      }\n      effects.enter('strikethroughSequenceTemporary');\n      return more(code);\n    }\n    function more(code) {\n      var before = classifyCharacter(previous);\n      var token;\n      var after;\n      if (code === 126) {\n        // If this is the third marker, exit.\n        if (size > 1) return nok(code);\n        effects.consume(code);\n        size++;\n        return more;\n      }\n      if (size < 2 && !single) return nok(code);\n      token = effects.exit('strikethroughSequenceTemporary');\n      after = classifyCharacter(code);\n      token._open = !after || after === 2 && before;\n      token._close = !before || before === 2 && after;\n      return ok(code);\n    }\n  }\n}","map":{"version":3,"names":["module","exports","create","classifyCharacter","require","chunkedSplice","resolveAll","shallow","options","settings","single","singleTilde","tokenizer","tokenize","tokenizeStrikethrough","resolveAllStrikethrough","undefined","text","insideSpan","null","events","context","index","strikethrough","open","nextEvents","length","type","_close","_open","end","offset","start","parser","constructs","slice","removeRemainingSequences","effects","ok","nok","previous","size","code","enter","more","before","token","after","consume","exit"],"sources":["C:/Users/Acer/Desktop/dev__book/dev__book/node_modules/micromark-extension-gfm-strikethrough/index.js"],"sourcesContent":["module.exports = create\n\nvar classifyCharacter = require('micromark/dist/util/classify-character')\nvar chunkedSplice = require('micromark/dist/util/chunked-splice')\nvar resolveAll = require('micromark/dist/util/resolve-all')\nvar shallow = require('micromark/dist/util/shallow')\n\nfunction create(options) {\n  var settings = options || {}\n  var single = settings.singleTilde\n  var tokenizer = {\n    tokenize: tokenizeStrikethrough,\n    resolveAll: resolveAllStrikethrough\n  }\n\n  if (single === null || single === undefined) {\n    single = true\n  }\n\n  return {text: {126: tokenizer}, insideSpan: {null: tokenizer}}\n\n  // Take events and resolve strikethrough.\n  function resolveAllStrikethrough(events, context) {\n    var index = -1\n    var strikethrough\n    var text\n    var open\n    var nextEvents\n\n    // Walk through all events.\n    while (++index < events.length) {\n      // Find a token that can close.\n      if (\n        events[index][0] === 'enter' &&\n        events[index][1].type === 'strikethroughSequenceTemporary' &&\n        events[index][1]._close\n      ) {\n        open = index\n\n        // Now walk back to find an opener.\n        while (open--) {\n          // Find a token that can open the closer.\n          if (\n            events[open][0] === 'exit' &&\n            events[open][1].type === 'strikethroughSequenceTemporary' &&\n            events[open][1]._open &&\n            // If the sizes are the same:\n            events[index][1].end.offset - events[index][1].start.offset ===\n              events[open][1].end.offset - events[open][1].start.offset\n          ) {\n            events[index][1].type = 'strikethroughSequence'\n            events[open][1].type = 'strikethroughSequence'\n\n            strikethrough = {\n              type: 'strikethrough',\n              start: shallow(events[open][1].start),\n              end: shallow(events[index][1].end)\n            }\n\n            text = {\n              type: 'strikethroughText',\n              start: shallow(events[open][1].end),\n              end: shallow(events[index][1].start)\n            }\n\n            // Opening.\n            nextEvents = [\n              ['enter', strikethrough, context],\n              ['enter', events[open][1], context],\n              ['exit', events[open][1], context],\n              ['enter', text, context]\n            ]\n\n            // Between.\n            chunkedSplice(\n              nextEvents,\n              nextEvents.length,\n              0,\n              resolveAll(\n                context.parser.constructs.insideSpan.null,\n                events.slice(open + 1, index),\n                context\n              )\n            )\n\n            // Closing.\n            chunkedSplice(nextEvents, nextEvents.length, 0, [\n              ['exit', text, context],\n              ['enter', events[index][1], context],\n              ['exit', events[index][1], context],\n              ['exit', strikethrough, context]\n            ])\n\n            chunkedSplice(events, open - 1, index - open + 3, nextEvents)\n\n            index = open + nextEvents.length - 2\n            break\n          }\n        }\n      }\n    }\n\n    return removeRemainingSequences(events)\n  }\n\n  function removeRemainingSequences(events) {\n    var index = -1\n    var length = events.length\n\n    while (++index < length) {\n      if (events[index][1].type === 'strikethroughSequenceTemporary') {\n        events[index][1].type = 'data'\n      }\n    }\n\n    return events\n  }\n\n  function tokenizeStrikethrough(effects, ok, nok) {\n    var previous = this.previous\n    var events = this.events\n    var size = 0\n\n    return start\n\n    function start(code) {\n      if (\n        code !== 126 ||\n        (previous === 126 &&\n          events[events.length - 1][1].type !== 'characterEscape')\n      ) {\n        return nok(code)\n      }\n\n      effects.enter('strikethroughSequenceTemporary')\n      return more(code)\n    }\n\n    function more(code) {\n      var before = classifyCharacter(previous)\n      var token\n      var after\n\n      if (code === 126) {\n        // If this is the third marker, exit.\n        if (size > 1) return nok(code)\n        effects.consume(code)\n        size++\n        return more\n      }\n\n      if (size < 2 && !single) return nok(code)\n      token = effects.exit('strikethroughSequenceTemporary')\n      after = classifyCharacter(code)\n      token._open = !after || (after === 2 && before)\n      token._close = !before || (before === 2 && after)\n      return ok(code)\n    }\n  }\n}\n"],"mappings":"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"},"metadata":{},"sourceType":"script"}