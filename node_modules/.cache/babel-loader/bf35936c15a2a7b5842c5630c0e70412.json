{"ast":null,"code":"\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.Printer = void 0;\nvar tslib_1 = require(\"tslib\");\nvar assert_1 = tslib_1.__importDefault(require(\"assert\"));\nvar comments_1 = require(\"./comments\");\nvar lines_1 = require(\"./lines\");\nvar options_1 = require(\"./options\");\nvar patcher_1 = require(\"./patcher\");\nvar types = tslib_1.__importStar(require(\"ast-types\"));\nvar namedTypes = types.namedTypes;\nvar isString = types.builtInTypes.string;\nvar isObject = types.builtInTypes.object;\nvar fast_path_1 = tslib_1.__importDefault(require(\"./fast-path\"));\nvar util = tslib_1.__importStar(require(\"./util\"));\nvar PrintResult = function PrintResult(code, sourceMap) {\n  assert_1.default.ok(this instanceof PrintResult);\n  isString.assert(code);\n  this.code = code;\n  if (sourceMap) {\n    isObject.assert(sourceMap);\n    this.map = sourceMap;\n  }\n};\nvar PRp = PrintResult.prototype;\nvar warnedAboutToString = false;\nPRp.toString = function () {\n  if (!warnedAboutToString) {\n    console.warn(\"Deprecation warning: recast.print now returns an object with \" + \"a .code property. You appear to be treating the object as a \" + \"string, which might still work but is strongly discouraged.\");\n    warnedAboutToString = true;\n  }\n  return this.code;\n};\nvar emptyPrintResult = new PrintResult(\"\");\nvar Printer = function Printer(config) {\n  assert_1.default.ok(this instanceof Printer);\n  var explicitTabWidth = config && config.tabWidth;\n  config = options_1.normalize(config);\n  // It's common for client code to pass the same options into both\n  // recast.parse and recast.print, but the Printer doesn't need (and\n  // can be confused by) config.sourceFileName, so we null it out.\n  config.sourceFileName = null;\n  // Non-destructively modifies options with overrides, and returns a\n  // new print function that uses the modified options.\n  function makePrintFunctionWith(options, overrides) {\n    options = Object.assign({}, options, overrides);\n    return function (path) {\n      return print(path, options);\n    };\n  }\n  function print(path, options) {\n    assert_1.default.ok(path instanceof fast_path_1.default);\n    options = options || {};\n    if (options.includeComments) {\n      return comments_1.printComments(path, makePrintFunctionWith(options, {\n        includeComments: false\n      }));\n    }\n    var oldTabWidth = config.tabWidth;\n    if (!explicitTabWidth) {\n      var loc = path.getNode().loc;\n      if (loc && loc.lines && loc.lines.guessTabWidth) {\n        config.tabWidth = loc.lines.guessTabWidth();\n      }\n    }\n    var reprinter = patcher_1.getReprinter(path);\n    var lines = reprinter ?\n    // Since the print function that we pass to the reprinter will\n    // be used to print \"new\" nodes, it's tempting to think we\n    // should pass printRootGenerically instead of print, to avoid\n    // calling maybeReprint again, but that would be a mistake\n    // because the new nodes might not be entirely new, but merely\n    // moved from elsewhere in the AST. The print function is the\n    // right choice because it gives us the opportunity to reprint\n    // such nodes using their original source.\n    reprinter(print) : genericPrint(path, config, options, makePrintFunctionWith(options, {\n      includeComments: true,\n      avoidRootParens: false\n    }));\n    config.tabWidth = oldTabWidth;\n    return lines;\n  }\n  this.print = function (ast) {\n    if (!ast) {\n      return emptyPrintResult;\n    }\n    var lines = print(fast_path_1.default.from(ast), {\n      includeComments: true,\n      avoidRootParens: false\n    });\n    return new PrintResult(lines.toString(config), util.composeSourceMaps(config.inputSourceMap, lines.getSourceMap(config.sourceMapName, config.sourceRoot)));\n  };\n  this.printGenerically = function (ast) {\n    if (!ast) {\n      return emptyPrintResult;\n    }\n    // Print the entire AST generically.\n    function printGenerically(path) {\n      return comments_1.printComments(path, function (path) {\n        return genericPrint(path, config, {\n          includeComments: true,\n          avoidRootParens: false\n        }, printGenerically);\n      });\n    }\n    var path = fast_path_1.default.from(ast);\n    var oldReuseWhitespace = config.reuseWhitespace;\n    // Do not reuse whitespace (or anything else, for that matter)\n    // when printing generically.\n    config.reuseWhitespace = false;\n    // TODO Allow printing of comments?\n    var pr = new PrintResult(printGenerically(path).toString(config));\n    config.reuseWhitespace = oldReuseWhitespace;\n    return pr;\n  };\n};\nexports.Printer = Printer;\nfunction genericPrint(path, config, options, printPath) {\n  assert_1.default.ok(path instanceof fast_path_1.default);\n  var node = path.getValue();\n  var parts = [];\n  var linesWithoutParens = genericPrintNoParens(path, config, printPath);\n  if (!node || linesWithoutParens.isEmpty()) {\n    return linesWithoutParens;\n  }\n  var shouldAddParens = node.extra ? node.extra.parenthesized : false;\n  var decoratorsLines = printDecorators(path, printPath);\n  if (decoratorsLines.isEmpty()) {\n    // Nodes with decorators can't have parentheses, so we can avoid\n    // computing path.needsParens() except in this case.\n    if (!options.avoidRootParens) {\n      shouldAddParens = shouldAddParens || path.needsParens();\n    }\n  } else {\n    parts.push(decoratorsLines);\n  }\n  if (shouldAddParens) {\n    parts.unshift(\"(\");\n  }\n  parts.push(linesWithoutParens);\n  if (shouldAddParens) {\n    parts.push(\")\");\n  }\n  return lines_1.concat(parts);\n}\n// Note that the `options` parameter of this function is what other\n// functions in this file call the `config` object (that is, the\n// configuration object originally passed into the Printer constructor).\n// Its properties are documented in lib/options.js.\nfunction genericPrintNoParens(path, options, print) {\n  var n = path.getValue();\n  if (!n) {\n    return lines_1.fromString(\"\");\n  }\n  if (typeof n === \"string\") {\n    return lines_1.fromString(n, options);\n  }\n  namedTypes.Printable.assert(n);\n  var parts = [];\n  switch (n.type) {\n    case \"File\":\n      return path.call(print, \"program\");\n    case \"Program\":\n      // Babel 6\n      if (n.directives) {\n        path.each(function (childPath) {\n          parts.push(print(childPath), \";\\n\");\n        }, \"directives\");\n      }\n      if (n.interpreter) {\n        parts.push(path.call(print, \"interpreter\"));\n      }\n      parts.push(path.call(function (bodyPath) {\n        return printStatementSequence(bodyPath, options, print);\n      }, \"body\"));\n      return lines_1.concat(parts);\n    case \"Noop\": // Babel extension.\n    case \"EmptyStatement\":\n      return lines_1.fromString(\"\");\n    case \"ExpressionStatement\":\n      return lines_1.concat([path.call(print, \"expression\"), \";\"]);\n    case \"ParenthesizedExpression\":\n      // Babel extension.\n      return lines_1.concat([\"(\", path.call(print, \"expression\"), \")\"]);\n    case \"BinaryExpression\":\n    case \"LogicalExpression\":\n    case \"AssignmentExpression\":\n      return lines_1.fromString(\" \").join([path.call(print, \"left\"), n.operator, path.call(print, \"right\")]);\n    case \"AssignmentPattern\":\n      return lines_1.concat([path.call(print, \"left\"), \" = \", path.call(print, \"right\")]);\n    case \"MemberExpression\":\n    case \"OptionalMemberExpression\":\n      {\n        parts.push(path.call(print, \"object\"));\n        var property = path.call(print, \"property\");\n        // Like n.optional, except with defaults applied, so optional\n        // defaults to true for OptionalMemberExpression nodes.\n        var optional = types.getFieldValue(n, \"optional\");\n        if (n.computed) {\n          parts.push(optional ? \"?.[\" : \"[\", property, \"]\");\n        } else {\n          parts.push(optional ? \"?.\" : \".\", property);\n        }\n        return lines_1.concat(parts);\n      }\n    case \"ChainExpression\":\n      return path.call(print, \"expression\");\n    case \"MetaProperty\":\n      return lines_1.concat([path.call(print, \"meta\"), \".\", path.call(print, \"property\")]);\n    case \"BindExpression\":\n      if (n.object) {\n        parts.push(path.call(print, \"object\"));\n      }\n      parts.push(\"::\", path.call(print, \"callee\"));\n      return lines_1.concat(parts);\n    case \"Path\":\n      return lines_1.fromString(\".\").join(n.body);\n    case \"Identifier\":\n      return lines_1.concat([lines_1.fromString(n.name, options), n.optional ? \"?\" : \"\", path.call(print, \"typeAnnotation\")]);\n    case \"SpreadElement\":\n    case \"SpreadElementPattern\":\n    case \"RestProperty\": // Babel 6 for ObjectPattern\n    case \"SpreadProperty\":\n    case \"SpreadPropertyPattern\":\n    case \"ObjectTypeSpreadProperty\":\n    case \"RestElement\":\n      return lines_1.concat([\"...\", path.call(print, \"argument\"), path.call(print, \"typeAnnotation\")]);\n    case \"FunctionDeclaration\":\n    case \"FunctionExpression\":\n    case \"TSDeclareFunction\":\n      if (n.declare) {\n        parts.push(\"declare \");\n      }\n      if (n.async) {\n        parts.push(\"async \");\n      }\n      parts.push(\"function\");\n      if (n.generator) parts.push(\"*\");\n      if (n.id) {\n        parts.push(\" \", path.call(print, \"id\"), path.call(print, \"typeParameters\"));\n      } else {\n        if (n.typeParameters) {\n          parts.push(path.call(print, \"typeParameters\"));\n        }\n      }\n      parts.push(\"(\", printFunctionParams(path, options, print), \")\", path.call(print, \"returnType\"));\n      if (n.body) {\n        parts.push(\" \", path.call(print, \"body\"));\n      }\n      return lines_1.concat(parts);\n    case \"ArrowFunctionExpression\":\n      if (n.async) {\n        parts.push(\"async \");\n      }\n      if (n.typeParameters) {\n        parts.push(path.call(print, \"typeParameters\"));\n      }\n      if (!options.arrowParensAlways && n.params.length === 1 && !n.rest && n.params[0].type === \"Identifier\" && !n.params[0].typeAnnotation && !n.returnType) {\n        parts.push(path.call(print, \"params\", 0));\n      } else {\n        parts.push(\"(\", printFunctionParams(path, options, print), \")\", path.call(print, \"returnType\"));\n      }\n      parts.push(\" => \", path.call(print, \"body\"));\n      return lines_1.concat(parts);\n    case \"MethodDefinition\":\n      return printMethod(path, options, print);\n    case \"YieldExpression\":\n      parts.push(\"yield\");\n      if (n.delegate) parts.push(\"*\");\n      if (n.argument) parts.push(\" \", path.call(print, \"argument\"));\n      return lines_1.concat(parts);\n    case \"AwaitExpression\":\n      parts.push(\"await\");\n      if (n.all) parts.push(\"*\");\n      if (n.argument) parts.push(\" \", path.call(print, \"argument\"));\n      return lines_1.concat(parts);\n    case \"ModuleDeclaration\":\n      parts.push(\"module\", path.call(print, \"id\"));\n      if (n.source) {\n        assert_1.default.ok(!n.body);\n        parts.push(\"from\", path.call(print, \"source\"));\n      } else {\n        parts.push(path.call(print, \"body\"));\n      }\n      return lines_1.fromString(\" \").join(parts);\n    case \"ImportSpecifier\":\n      if (n.importKind && n.importKind !== \"value\") {\n        parts.push(n.importKind + \" \");\n      }\n      if (n.imported) {\n        parts.push(path.call(print, \"imported\"));\n        if (n.local && n.local.name !== n.imported.name) {\n          parts.push(\" as \", path.call(print, \"local\"));\n        }\n      } else if (n.id) {\n        parts.push(path.call(print, \"id\"));\n        if (n.name) {\n          parts.push(\" as \", path.call(print, \"name\"));\n        }\n      }\n      return lines_1.concat(parts);\n    case \"ExportSpecifier\":\n      if (n.local) {\n        parts.push(path.call(print, \"local\"));\n        if (n.exported && n.exported.name !== n.local.name) {\n          parts.push(\" as \", path.call(print, \"exported\"));\n        }\n      } else if (n.id) {\n        parts.push(path.call(print, \"id\"));\n        if (n.name) {\n          parts.push(\" as \", path.call(print, \"name\"));\n        }\n      }\n      return lines_1.concat(parts);\n    case \"ExportBatchSpecifier\":\n      return lines_1.fromString(\"*\");\n    case \"ImportNamespaceSpecifier\":\n      parts.push(\"* as \");\n      if (n.local) {\n        parts.push(path.call(print, \"local\"));\n      } else if (n.id) {\n        parts.push(path.call(print, \"id\"));\n      }\n      return lines_1.concat(parts);\n    case \"ImportDefaultSpecifier\":\n      if (n.local) {\n        return path.call(print, \"local\");\n      }\n      return path.call(print, \"id\");\n    case \"TSExportAssignment\":\n      return lines_1.concat([\"export = \", path.call(print, \"expression\")]);\n    case \"ExportDeclaration\":\n    case \"ExportDefaultDeclaration\":\n    case \"ExportNamedDeclaration\":\n      return printExportDeclaration(path, options, print);\n    case \"ExportAllDeclaration\":\n      parts.push(\"export *\");\n      if (n.exported) {\n        parts.push(\" as \", path.call(print, \"exported\"));\n      }\n      parts.push(\" from \", path.call(print, \"source\"), \";\");\n      return lines_1.concat(parts);\n    case \"TSNamespaceExportDeclaration\":\n      parts.push(\"export as namespace \", path.call(print, \"id\"));\n      return maybeAddSemicolon(lines_1.concat(parts));\n    case \"ExportNamespaceSpecifier\":\n      return lines_1.concat([\"* as \", path.call(print, \"exported\")]);\n    case \"ExportDefaultSpecifier\":\n      return path.call(print, \"exported\");\n    case \"Import\":\n      return lines_1.fromString(\"import\", options);\n    // Recast and ast-types currently support dynamic import(...) using\n    // either this dedicated ImportExpression type or a CallExpression\n    // whose callee has type Import.\n    // https://github.com/benjamn/ast-types/pull/365#issuecomment-605214486\n    case \"ImportExpression\":\n      return lines_1.concat([\"import(\", path.call(print, \"source\"), \")\"]);\n    case \"ImportDeclaration\":\n      {\n        parts.push(\"import \");\n        if (n.importKind && n.importKind !== \"value\") {\n          parts.push(n.importKind + \" \");\n        }\n        if (n.specifiers && n.specifiers.length > 0) {\n          var unbracedSpecifiers_1 = [];\n          var bracedSpecifiers_1 = [];\n          path.each(function (specifierPath) {\n            var spec = specifierPath.getValue();\n            if (spec.type === \"ImportSpecifier\") {\n              bracedSpecifiers_1.push(print(specifierPath));\n            } else if (spec.type === \"ImportDefaultSpecifier\" || spec.type === \"ImportNamespaceSpecifier\") {\n              unbracedSpecifiers_1.push(print(specifierPath));\n            }\n          }, \"specifiers\");\n          unbracedSpecifiers_1.forEach(function (lines, i) {\n            if (i > 0) {\n              parts.push(\", \");\n            }\n            parts.push(lines);\n          });\n          if (bracedSpecifiers_1.length > 0) {\n            var lines = lines_1.fromString(\", \").join(bracedSpecifiers_1);\n            if (lines.getLineLength(1) > options.wrapColumn) {\n              lines = lines_1.concat([lines_1.fromString(\",\\n\").join(bracedSpecifiers_1).indent(options.tabWidth), \",\"]);\n            }\n            if (unbracedSpecifiers_1.length > 0) {\n              parts.push(\", \");\n            }\n            if (lines.length > 1) {\n              parts.push(\"{\\n\", lines, \"\\n}\");\n            } else if (options.objectCurlySpacing) {\n              parts.push(\"{ \", lines, \" }\");\n            } else {\n              parts.push(\"{\", lines, \"}\");\n            }\n          }\n          parts.push(\" from \");\n        }\n        parts.push(path.call(print, \"source\"), \";\");\n        return lines_1.concat(parts);\n      }\n    case \"BlockStatement\":\n      {\n        var naked_1 = path.call(function (bodyPath) {\n          return printStatementSequence(bodyPath, options, print);\n        }, \"body\");\n        if (naked_1.isEmpty()) {\n          if (!n.directives || n.directives.length === 0) {\n            return lines_1.fromString(\"{}\");\n          }\n        }\n        parts.push(\"{\\n\");\n        // Babel 6\n        if (n.directives) {\n          path.each(function (childPath) {\n            parts.push(maybeAddSemicolon(print(childPath).indent(options.tabWidth)), n.directives.length > 1 || !naked_1.isEmpty() ? \"\\n\" : \"\");\n          }, \"directives\");\n        }\n        parts.push(naked_1.indent(options.tabWidth));\n        parts.push(\"\\n}\");\n        return lines_1.concat(parts);\n      }\n    case \"ReturnStatement\":\n      {\n        parts.push(\"return\");\n        if (n.argument) {\n          var argLines = path.call(print, \"argument\");\n          if (argLines.startsWithComment() || argLines.length > 1 && namedTypes.JSXElement && namedTypes.JSXElement.check(n.argument)) {\n            parts.push(\" (\\n\", argLines.indent(options.tabWidth), \"\\n)\");\n          } else {\n            parts.push(\" \", argLines);\n          }\n        }\n        parts.push(\";\");\n        return lines_1.concat(parts);\n      }\n    case \"CallExpression\":\n    case \"OptionalCallExpression\":\n      parts.push(path.call(print, \"callee\"));\n      if (n.typeParameters) {\n        parts.push(path.call(print, \"typeParameters\"));\n      }\n      if (n.typeArguments) {\n        parts.push(path.call(print, \"typeArguments\"));\n      }\n      // Like n.optional, but defaults to true for OptionalCallExpression\n      // nodes that are missing an n.optional property (unusual),\n      // according to the OptionalCallExpression definition in ast-types.\n      if (types.getFieldValue(n, \"optional\")) {\n        parts.push(\"?.\");\n      }\n      parts.push(printArgumentsList(path, options, print));\n      return lines_1.concat(parts);\n    case \"ObjectExpression\":\n    case \"ObjectPattern\":\n    case \"ObjectTypeAnnotation\":\n      {\n        var isTypeAnnotation_1 = n.type === \"ObjectTypeAnnotation\";\n        var separator_1 = options.flowObjectCommas ? \",\" : isTypeAnnotation_1 ? \";\" : \",\";\n        var fields = [];\n        var allowBreak_1 = false;\n        if (isTypeAnnotation_1) {\n          fields.push(\"indexers\", \"callProperties\");\n          if (n.internalSlots != null) {\n            fields.push(\"internalSlots\");\n          }\n        }\n        fields.push(\"properties\");\n        var len_1 = 0;\n        fields.forEach(function (field) {\n          len_1 += n[field].length;\n        });\n        var oneLine_1 = isTypeAnnotation_1 && len_1 === 1 || len_1 === 0;\n        var leftBrace = n.exact ? \"{|\" : \"{\";\n        var rightBrace = n.exact ? \"|}\" : \"}\";\n        parts.push(oneLine_1 ? leftBrace : leftBrace + \"\\n\");\n        var leftBraceIndex = parts.length - 1;\n        var i_1 = 0;\n        fields.forEach(function (field) {\n          path.each(function (childPath) {\n            var lines = print(childPath);\n            if (!oneLine_1) {\n              lines = lines.indent(options.tabWidth);\n            }\n            var multiLine = !isTypeAnnotation_1 && lines.length > 1;\n            if (multiLine && allowBreak_1) {\n              // Similar to the logic for BlockStatement.\n              parts.push(\"\\n\");\n            }\n            parts.push(lines);\n            if (i_1 < len_1 - 1) {\n              // Add an extra line break if the previous object property\n              // had a multi-line value.\n              parts.push(separator_1 + (multiLine ? \"\\n\\n\" : \"\\n\"));\n              allowBreak_1 = !multiLine;\n            } else if (len_1 !== 1 && isTypeAnnotation_1) {\n              parts.push(separator_1);\n            } else if (!oneLine_1 && util.isTrailingCommaEnabled(options, \"objects\") && childPath.getValue().type !== \"RestElement\") {\n              parts.push(separator_1);\n            }\n            i_1++;\n          }, field);\n        });\n        if (n.inexact) {\n          var line = lines_1.fromString(\"...\", options);\n          if (oneLine_1) {\n            if (len_1 > 0) {\n              parts.push(separator_1, \" \");\n            }\n            parts.push(line);\n          } else {\n            // No trailing separator after ... to maintain parity with prettier.\n            parts.push(\"\\n\", line.indent(options.tabWidth));\n          }\n        }\n        parts.push(oneLine_1 ? rightBrace : \"\\n\" + rightBrace);\n        if (i_1 !== 0 && oneLine_1 && options.objectCurlySpacing) {\n          parts[leftBraceIndex] = leftBrace + \" \";\n          parts[parts.length - 1] = \" \" + rightBrace;\n        }\n        if (n.typeAnnotation) {\n          parts.push(path.call(print, \"typeAnnotation\"));\n        }\n        return lines_1.concat(parts);\n      }\n    case \"PropertyPattern\":\n      return lines_1.concat([path.call(print, \"key\"), \": \", path.call(print, \"pattern\")]);\n    case \"ObjectProperty\": // Babel 6\n    case \"Property\":\n      {\n        // Non-standard AST node type.\n        if (n.method || n.kind === \"get\" || n.kind === \"set\") {\n          return printMethod(path, options, print);\n        }\n        if (n.shorthand && n.value.type === \"AssignmentPattern\") {\n          return path.call(print, \"value\");\n        }\n        var key = path.call(print, \"key\");\n        if (n.computed) {\n          parts.push(\"[\", key, \"]\");\n        } else {\n          parts.push(key);\n        }\n        if (!n.shorthand || n.key.name !== n.value.name) {\n          parts.push(\": \", path.call(print, \"value\"));\n        }\n        return lines_1.concat(parts);\n      }\n    case \"ClassMethod\": // Babel 6\n    case \"ObjectMethod\": // Babel 6\n    case \"ClassPrivateMethod\":\n    case \"TSDeclareMethod\":\n      return printMethod(path, options, print);\n    case \"PrivateName\":\n      return lines_1.concat([\"#\", path.call(print, \"id\")]);\n    case \"Decorator\":\n      return lines_1.concat([\"@\", path.call(print, \"expression\")]);\n    case \"ArrayExpression\":\n    case \"ArrayPattern\":\n      {\n        var elems = n.elements;\n        var len_2 = elems.length;\n        var printed_1 = path.map(print, \"elements\");\n        var joined = lines_1.fromString(\", \").join(printed_1);\n        var oneLine_2 = joined.getLineLength(1) <= options.wrapColumn;\n        if (oneLine_2) {\n          if (options.arrayBracketSpacing) {\n            parts.push(\"[ \");\n          } else {\n            parts.push(\"[\");\n          }\n        } else {\n          parts.push(\"[\\n\");\n        }\n        path.each(function (elemPath) {\n          var i = elemPath.getName();\n          var elem = elemPath.getValue();\n          if (!elem) {\n            // If the array expression ends with a hole, that hole\n            // will be ignored by the interpreter, but if it ends with\n            // two (or more) holes, we need to write out two (or more)\n            // commas so that the resulting code is interpreted with\n            // both (all) of the holes.\n            parts.push(\",\");\n          } else {\n            var lines = printed_1[i];\n            if (oneLine_2) {\n              if (i > 0) parts.push(\" \");\n            } else {\n              lines = lines.indent(options.tabWidth);\n            }\n            parts.push(lines);\n            if (i < len_2 - 1 || !oneLine_2 && util.isTrailingCommaEnabled(options, \"arrays\")) parts.push(\",\");\n            if (!oneLine_2) parts.push(\"\\n\");\n          }\n        }, \"elements\");\n        if (oneLine_2 && options.arrayBracketSpacing) {\n          parts.push(\" ]\");\n        } else {\n          parts.push(\"]\");\n        }\n        if (n.typeAnnotation) {\n          parts.push(path.call(print, \"typeAnnotation\"));\n        }\n        return lines_1.concat(parts);\n      }\n    case \"SequenceExpression\":\n      return lines_1.fromString(\", \").join(path.map(print, \"expressions\"));\n    case \"ThisExpression\":\n      return lines_1.fromString(\"this\");\n    case \"Super\":\n      return lines_1.fromString(\"super\");\n    case \"NullLiteral\":\n      // Babel 6 Literal split\n      return lines_1.fromString(\"null\");\n    case \"RegExpLiteral\":\n      // Babel 6 Literal split\n      return lines_1.fromString(n.extra.raw);\n    case \"BigIntLiteral\":\n      // Babel 7 Literal split\n      return lines_1.fromString(n.value + \"n\");\n    case \"NumericLiteral\":\n      // Babel 6 Literal Split\n      // Keep original representation for numeric values not in base 10.\n      if (n.extra && typeof n.extra.raw === \"string\" && Number(n.extra.raw) === n.value) {\n        return lines_1.fromString(n.extra.raw, options);\n      }\n      return lines_1.fromString(n.value, options);\n    case \"BooleanLiteral\": // Babel 6 Literal split\n    case \"StringLiteral\": // Babel 6 Literal split\n    case \"Literal\":\n      // Numeric values may be in bases other than 10. Use their raw\n      // representation if equivalent.\n      if (typeof n.value === \"number\" && typeof n.raw === \"string\" && Number(n.raw) === n.value) {\n        return lines_1.fromString(n.raw, options);\n      }\n      if (typeof n.value !== \"string\") {\n        return lines_1.fromString(n.value, options);\n      }\n      return lines_1.fromString(nodeStr(n.value, options), options);\n    case \"Directive\":\n      // Babel 6\n      return path.call(print, \"value\");\n    case \"DirectiveLiteral\":\n      // Babel 6\n      return lines_1.fromString(nodeStr(n.value, options));\n    case \"InterpreterDirective\":\n      return lines_1.fromString(\"#!\" + n.value + \"\\n\", options);\n    case \"ModuleSpecifier\":\n      if (n.local) {\n        throw new Error(\"The ESTree ModuleSpecifier type should be abstract\");\n      }\n      // The Esprima ModuleSpecifier type is just a string-valued\n      // Literal identifying the imported-from module.\n      return lines_1.fromString(nodeStr(n.value, options), options);\n    case \"UnaryExpression\":\n      parts.push(n.operator);\n      if (/[a-z]$/.test(n.operator)) parts.push(\" \");\n      parts.push(path.call(print, \"argument\"));\n      return lines_1.concat(parts);\n    case \"UpdateExpression\":\n      parts.push(path.call(print, \"argument\"), n.operator);\n      if (n.prefix) parts.reverse();\n      return lines_1.concat(parts);\n    case \"ConditionalExpression\":\n      return lines_1.concat([path.call(print, \"test\"), \" ? \", path.call(print, \"consequent\"), \" : \", path.call(print, \"alternate\")]);\n    case \"NewExpression\":\n      {\n        parts.push(\"new \", path.call(print, \"callee\"));\n        if (n.typeParameters) {\n          parts.push(path.call(print, \"typeParameters\"));\n        }\n        if (n.typeArguments) {\n          parts.push(path.call(print, \"typeArguments\"));\n        }\n        var args = n.arguments;\n        if (args) {\n          parts.push(printArgumentsList(path, options, print));\n        }\n        return lines_1.concat(parts);\n      }\n    case \"VariableDeclaration\":\n      {\n        if (n.declare) {\n          parts.push(\"declare \");\n        }\n        parts.push(n.kind, \" \");\n        var maxLen_1 = 0;\n        var printed = path.map(function (childPath) {\n          var lines = print(childPath);\n          maxLen_1 = Math.max(lines.length, maxLen_1);\n          return lines;\n        }, \"declarations\");\n        if (maxLen_1 === 1) {\n          parts.push(lines_1.fromString(\", \").join(printed));\n        } else if (printed.length > 1) {\n          parts.push(lines_1.fromString(\",\\n\").join(printed).indentTail(n.kind.length + 1));\n        } else {\n          parts.push(printed[0]);\n        }\n        // We generally want to terminate all variable declarations with a\n        // semicolon, except when they are children of for loops.\n        var parentNode = path.getParentNode();\n        if (!namedTypes.ForStatement.check(parentNode) && !namedTypes.ForInStatement.check(parentNode) && !(namedTypes.ForOfStatement && namedTypes.ForOfStatement.check(parentNode)) && !(namedTypes.ForAwaitStatement && namedTypes.ForAwaitStatement.check(parentNode))) {\n          parts.push(\";\");\n        }\n        return lines_1.concat(parts);\n      }\n    case \"VariableDeclarator\":\n      return n.init ? lines_1.fromString(\" = \").join([path.call(print, \"id\"), path.call(print, \"init\")]) : path.call(print, \"id\");\n    case \"WithStatement\":\n      return lines_1.concat([\"with (\", path.call(print, \"object\"), \") \", path.call(print, \"body\")]);\n    case \"IfStatement\":\n      {\n        var con = adjustClause(path.call(print, \"consequent\"), options);\n        parts.push(\"if (\", path.call(print, \"test\"), \")\", con);\n        if (n.alternate) parts.push(endsWithBrace(con) ? \" else\" : \"\\nelse\", adjustClause(path.call(print, \"alternate\"), options));\n        return lines_1.concat(parts);\n      }\n    case \"ForStatement\":\n      {\n        // TODO Get the for (;;) case right.\n        var init = path.call(print, \"init\");\n        var sep = init.length > 1 ? \";\\n\" : \"; \";\n        var forParen = \"for (\";\n        var indented = lines_1.fromString(sep).join([init, path.call(print, \"test\"), path.call(print, \"update\")]).indentTail(forParen.length);\n        var head = lines_1.concat([forParen, indented, \")\"]);\n        var clause = adjustClause(path.call(print, \"body\"), options);\n        parts.push(head);\n        if (head.length > 1) {\n          parts.push(\"\\n\");\n          clause = clause.trimLeft();\n        }\n        parts.push(clause);\n        return lines_1.concat(parts);\n      }\n    case \"WhileStatement\":\n      return lines_1.concat([\"while (\", path.call(print, \"test\"), \")\", adjustClause(path.call(print, \"body\"), options)]);\n    case \"ForInStatement\":\n      // Note: esprima can't actually parse \"for each (\".\n      return lines_1.concat([n.each ? \"for each (\" : \"for (\", path.call(print, \"left\"), \" in \", path.call(print, \"right\"), \")\", adjustClause(path.call(print, \"body\"), options)]);\n    case \"ForOfStatement\":\n    case \"ForAwaitStatement\":\n      parts.push(\"for \");\n      if (n.await || n.type === \"ForAwaitStatement\") {\n        parts.push(\"await \");\n      }\n      parts.push(\"(\", path.call(print, \"left\"), \" of \", path.call(print, \"right\"), \")\", adjustClause(path.call(print, \"body\"), options));\n      return lines_1.concat(parts);\n    case \"DoWhileStatement\":\n      {\n        var doBody = lines_1.concat([\"do\", adjustClause(path.call(print, \"body\"), options)]);\n        parts.push(doBody);\n        if (endsWithBrace(doBody)) parts.push(\" while\");else parts.push(\"\\nwhile\");\n        parts.push(\" (\", path.call(print, \"test\"), \");\");\n        return lines_1.concat(parts);\n      }\n    case \"DoExpression\":\n      {\n        var statements = path.call(function (bodyPath) {\n          return printStatementSequence(bodyPath, options, print);\n        }, \"body\");\n        return lines_1.concat([\"do {\\n\", statements.indent(options.tabWidth), \"\\n}\"]);\n      }\n    case \"BreakStatement\":\n      parts.push(\"break\");\n      if (n.label) parts.push(\" \", path.call(print, \"label\"));\n      parts.push(\";\");\n      return lines_1.concat(parts);\n    case \"ContinueStatement\":\n      parts.push(\"continue\");\n      if (n.label) parts.push(\" \", path.call(print, \"label\"));\n      parts.push(\";\");\n      return lines_1.concat(parts);\n    case \"LabeledStatement\":\n      return lines_1.concat([path.call(print, \"label\"), \":\\n\", path.call(print, \"body\")]);\n    case \"TryStatement\":\n      parts.push(\"try \", path.call(print, \"block\"));\n      if (n.handler) {\n        parts.push(\" \", path.call(print, \"handler\"));\n      } else if (n.handlers) {\n        path.each(function (handlerPath) {\n          parts.push(\" \", print(handlerPath));\n        }, \"handlers\");\n      }\n      if (n.finalizer) {\n        parts.push(\" finally \", path.call(print, \"finalizer\"));\n      }\n      return lines_1.concat(parts);\n    case \"CatchClause\":\n      parts.push(\"catch \");\n      if (n.param) {\n        parts.push(\"(\", path.call(print, \"param\"));\n      }\n      if (n.guard) {\n        // Note: esprima does not recognize conditional catch clauses.\n        parts.push(\" if \", path.call(print, \"guard\"));\n      }\n      if (n.param) {\n        parts.push(\") \");\n      }\n      parts.push(path.call(print, \"body\"));\n      return lines_1.concat(parts);\n    case \"ThrowStatement\":\n      return lines_1.concat([\"throw \", path.call(print, \"argument\"), \";\"]);\n    case \"SwitchStatement\":\n      return lines_1.concat([\"switch (\", path.call(print, \"discriminant\"), \") {\\n\", lines_1.fromString(\"\\n\").join(path.map(print, \"cases\")), \"\\n}\"]);\n    // Note: ignoring n.lexical because it has no printing consequences.\n    case \"SwitchCase\":\n      if (n.test) parts.push(\"case \", path.call(print, \"test\"), \":\");else parts.push(\"default:\");\n      if (n.consequent.length > 0) {\n        parts.push(\"\\n\", path.call(function (consequentPath) {\n          return printStatementSequence(consequentPath, options, print);\n        }, \"consequent\").indent(options.tabWidth));\n      }\n      return lines_1.concat(parts);\n    case \"DebuggerStatement\":\n      return lines_1.fromString(\"debugger;\");\n    // JSX extensions below.\n    case \"JSXAttribute\":\n      parts.push(path.call(print, \"name\"));\n      if (n.value) parts.push(\"=\", path.call(print, \"value\"));\n      return lines_1.concat(parts);\n    case \"JSXIdentifier\":\n      return lines_1.fromString(n.name, options);\n    case \"JSXNamespacedName\":\n      return lines_1.fromString(\":\").join([path.call(print, \"namespace\"), path.call(print, \"name\")]);\n    case \"JSXMemberExpression\":\n      return lines_1.fromString(\".\").join([path.call(print, \"object\"), path.call(print, \"property\")]);\n    case \"JSXSpreadAttribute\":\n      return lines_1.concat([\"{...\", path.call(print, \"argument\"), \"}\"]);\n    case \"JSXSpreadChild\":\n      return lines_1.concat([\"{...\", path.call(print, \"expression\"), \"}\"]);\n    case \"JSXExpressionContainer\":\n      return lines_1.concat([\"{\", path.call(print, \"expression\"), \"}\"]);\n    case \"JSXElement\":\n    case \"JSXFragment\":\n      {\n        var openingPropName = \"opening\" + (n.type === \"JSXElement\" ? \"Element\" : \"Fragment\");\n        var closingPropName = \"closing\" + (n.type === \"JSXElement\" ? \"Element\" : \"Fragment\");\n        var openingLines = path.call(print, openingPropName);\n        if (n[openingPropName].selfClosing) {\n          assert_1.default.ok(!n[closingPropName], \"unexpected \" + closingPropName + \" element in self-closing \" + n.type);\n          return openingLines;\n        }\n        var childLines = lines_1.concat(path.map(function (childPath) {\n          var child = childPath.getValue();\n          if (namedTypes.Literal.check(child) && typeof child.value === \"string\") {\n            if (/\\S/.test(child.value)) {\n              return child.value.replace(/^\\s+|\\s+$/g, \"\");\n            } else if (/\\n/.test(child.value)) {\n              return \"\\n\";\n            }\n          }\n          return print(childPath);\n        }, \"children\")).indentTail(options.tabWidth);\n        var closingLines = path.call(print, closingPropName);\n        return lines_1.concat([openingLines, childLines, closingLines]);\n      }\n    case \"JSXOpeningElement\":\n      {\n        parts.push(\"<\", path.call(print, \"name\"));\n        var attrParts_1 = [];\n        path.each(function (attrPath) {\n          attrParts_1.push(\" \", print(attrPath));\n        }, \"attributes\");\n        var attrLines = lines_1.concat(attrParts_1);\n        var needLineWrap = attrLines.length > 1 || attrLines.getLineLength(1) > options.wrapColumn;\n        if (needLineWrap) {\n          attrParts_1.forEach(function (part, i) {\n            if (part === \" \") {\n              assert_1.default.strictEqual(i % 2, 0);\n              attrParts_1[i] = \"\\n\";\n            }\n          });\n          attrLines = lines_1.concat(attrParts_1).indentTail(options.tabWidth);\n        }\n        parts.push(attrLines, n.selfClosing ? \" />\" : \">\");\n        return lines_1.concat(parts);\n      }\n    case \"JSXClosingElement\":\n      return lines_1.concat([\"</\", path.call(print, \"name\"), \">\"]);\n    case \"JSXOpeningFragment\":\n      return lines_1.fromString(\"<>\");\n    case \"JSXClosingFragment\":\n      return lines_1.fromString(\"</>\");\n    case \"JSXText\":\n      return lines_1.fromString(n.value, options);\n    case \"JSXEmptyExpression\":\n      return lines_1.fromString(\"\");\n    case \"TypeAnnotatedIdentifier\":\n      return lines_1.concat([path.call(print, \"annotation\"), \" \", path.call(print, \"identifier\")]);\n    case \"ClassBody\":\n      if (n.body.length === 0) {\n        return lines_1.fromString(\"{}\");\n      }\n      return lines_1.concat([\"{\\n\", path.call(function (bodyPath) {\n        return printStatementSequence(bodyPath, options, print);\n      }, \"body\").indent(options.tabWidth), \"\\n}\"]);\n    case \"ClassPropertyDefinition\":\n      parts.push(\"static \", path.call(print, \"definition\"));\n      if (!namedTypes.MethodDefinition.check(n.definition)) parts.push(\";\");\n      return lines_1.concat(parts);\n    case \"ClassProperty\":\n      {\n        if (n.declare) {\n          parts.push(\"declare \");\n        }\n        var access = n.accessibility || n.access;\n        if (typeof access === \"string\") {\n          parts.push(access, \" \");\n        }\n        if (n.static) {\n          parts.push(\"static \");\n        }\n        if (n.abstract) {\n          parts.push(\"abstract \");\n        }\n        if (n.readonly) {\n          parts.push(\"readonly \");\n        }\n        var key = path.call(print, \"key\");\n        if (n.computed) {\n          key = lines_1.concat([\"[\", key, \"]\"]);\n        }\n        if (n.variance) {\n          key = lines_1.concat([printVariance(path, print), key]);\n        }\n        parts.push(key);\n        if (n.optional) {\n          parts.push(\"?\");\n        }\n        if (n.typeAnnotation) {\n          parts.push(path.call(print, \"typeAnnotation\"));\n        }\n        if (n.value) {\n          parts.push(\" = \", path.call(print, \"value\"));\n        }\n        parts.push(\";\");\n        return lines_1.concat(parts);\n      }\n    case \"ClassPrivateProperty\":\n      if (n.static) {\n        parts.push(\"static \");\n      }\n      parts.push(path.call(print, \"key\"));\n      if (n.typeAnnotation) {\n        parts.push(path.call(print, \"typeAnnotation\"));\n      }\n      if (n.value) {\n        parts.push(\" = \", path.call(print, \"value\"));\n      }\n      parts.push(\";\");\n      return lines_1.concat(parts);\n    case \"ClassDeclaration\":\n    case \"ClassExpression\":\n      if (n.declare) {\n        parts.push(\"declare \");\n      }\n      if (n.abstract) {\n        parts.push(\"abstract \");\n      }\n      parts.push(\"class\");\n      if (n.id) {\n        parts.push(\" \", path.call(print, \"id\"));\n      }\n      if (n.typeParameters) {\n        parts.push(path.call(print, \"typeParameters\"));\n      }\n      if (n.superClass) {\n        parts.push(\" extends \", path.call(print, \"superClass\"), path.call(print, \"superTypeParameters\"));\n      }\n      if (n[\"implements\"] && n[\"implements\"].length > 0) {\n        parts.push(\" implements \", lines_1.fromString(\", \").join(path.map(print, \"implements\")));\n      }\n      parts.push(\" \", path.call(print, \"body\"));\n      return lines_1.concat(parts);\n    case \"TemplateElement\":\n      return lines_1.fromString(n.value.raw, options).lockIndentTail();\n    case \"TemplateLiteral\":\n      {\n        var expressions_1 = path.map(print, \"expressions\");\n        parts.push(\"`\");\n        path.each(function (childPath) {\n          var i = childPath.getName();\n          parts.push(print(childPath));\n          if (i < expressions_1.length) {\n            parts.push(\"${\", expressions_1[i], \"}\");\n          }\n        }, \"quasis\");\n        parts.push(\"`\");\n        return lines_1.concat(parts).lockIndentTail();\n      }\n    case \"TaggedTemplateExpression\":\n      return lines_1.concat([path.call(print, \"tag\"), path.call(print, \"quasi\")]);\n    // These types are unprintable because they serve as abstract\n    // supertypes for other (printable) types.\n    case \"Node\":\n    case \"Printable\":\n    case \"SourceLocation\":\n    case \"Position\":\n    case \"Statement\":\n    case \"Function\":\n    case \"Pattern\":\n    case \"Expression\":\n    case \"Declaration\":\n    case \"Specifier\":\n    case \"NamedSpecifier\":\n    case \"Comment\": // Supertype of Block and Line\n    case \"Flow\": // Supertype of all Flow AST node types\n    case \"FlowType\": // Supertype of all Flow types\n    case \"FlowPredicate\": // Supertype of InferredPredicate and DeclaredPredicate\n    case \"MemberTypeAnnotation\": // Flow\n    case \"Type\": // Flow\n    case \"TSHasOptionalTypeParameterInstantiation\":\n    case \"TSHasOptionalTypeParameters\":\n    case \"TSHasOptionalTypeAnnotation\":\n    case \"ChainElement\":\n      // Supertype of MemberExpression and CallExpression\n      throw new Error(\"unprintable type: \" + JSON.stringify(n.type));\n    case \"CommentBlock\": // Babel block comment.\n    case \"Block\":\n      // Esprima block comment.\n      return lines_1.concat([\"/*\", lines_1.fromString(n.value, options), \"*/\"]);\n    case \"CommentLine\": // Babel line comment.\n    case \"Line\":\n      // Esprima line comment.\n      return lines_1.concat([\"//\", lines_1.fromString(n.value, options)]);\n    // Type Annotations for Facebook Flow, typically stripped out or\n    // transformed away before printing.\n    case \"TypeAnnotation\":\n      if (n.typeAnnotation) {\n        if (n.typeAnnotation.type !== \"FunctionTypeAnnotation\") {\n          parts.push(\": \");\n        }\n        parts.push(path.call(print, \"typeAnnotation\"));\n        return lines_1.concat(parts);\n      }\n      return lines_1.fromString(\"\");\n    case \"ExistentialTypeParam\":\n    case \"ExistsTypeAnnotation\":\n      return lines_1.fromString(\"*\", options);\n    case \"EmptyTypeAnnotation\":\n      return lines_1.fromString(\"empty\", options);\n    case \"AnyTypeAnnotation\":\n      return lines_1.fromString(\"any\", options);\n    case \"MixedTypeAnnotation\":\n      return lines_1.fromString(\"mixed\", options);\n    case \"ArrayTypeAnnotation\":\n      return lines_1.concat([path.call(print, \"elementType\"), \"[]\"]);\n    case \"TupleTypeAnnotation\":\n      {\n        var printed_2 = path.map(print, \"types\");\n        var joined = lines_1.fromString(\", \").join(printed_2);\n        var oneLine_3 = joined.getLineLength(1) <= options.wrapColumn;\n        if (oneLine_3) {\n          if (options.arrayBracketSpacing) {\n            parts.push(\"[ \");\n          } else {\n            parts.push(\"[\");\n          }\n        } else {\n          parts.push(\"[\\n\");\n        }\n        path.each(function (elemPath) {\n          var i = elemPath.getName();\n          var elem = elemPath.getValue();\n          if (!elem) {\n            // If the array expression ends with a hole, that hole\n            // will be ignored by the interpreter, but if it ends with\n            // two (or more) holes, we need to write out two (or more)\n            // commas so that the resulting code is interpreted with\n            // both (all) of the holes.\n            parts.push(\",\");\n          } else {\n            var lines = printed_2[i];\n            if (oneLine_3) {\n              if (i > 0) parts.push(\" \");\n            } else {\n              lines = lines.indent(options.tabWidth);\n            }\n            parts.push(lines);\n            if (i < n.types.length - 1 || !oneLine_3 && util.isTrailingCommaEnabled(options, \"arrays\")) parts.push(\",\");\n            if (!oneLine_3) parts.push(\"\\n\");\n          }\n        }, \"types\");\n        if (oneLine_3 && options.arrayBracketSpacing) {\n          parts.push(\" ]\");\n        } else {\n          parts.push(\"]\");\n        }\n        return lines_1.concat(parts);\n      }\n    case \"BooleanTypeAnnotation\":\n      return lines_1.fromString(\"boolean\", options);\n    case \"BooleanLiteralTypeAnnotation\":\n      assert_1.default.strictEqual(typeof n.value, \"boolean\");\n      return lines_1.fromString(\"\" + n.value, options);\n    case \"InterfaceTypeAnnotation\":\n      parts.push(\"interface\");\n      if (n.extends && n.extends.length > 0) {\n        parts.push(\" extends \", lines_1.fromString(\", \").join(path.map(print, \"extends\")));\n      }\n      parts.push(\" \", path.call(print, \"body\"));\n      return lines_1.concat(parts);\n    case \"DeclareClass\":\n      return printFlowDeclaration(path, [\"class \", path.call(print, \"id\"), \" \", path.call(print, \"body\")]);\n    case \"DeclareFunction\":\n      return printFlowDeclaration(path, [\"function \", path.call(print, \"id\"), \";\"]);\n    case \"DeclareModule\":\n      return printFlowDeclaration(path, [\"module \", path.call(print, \"id\"), \" \", path.call(print, \"body\")]);\n    case \"DeclareModuleExports\":\n      return printFlowDeclaration(path, [\"module.exports\", path.call(print, \"typeAnnotation\")]);\n    case \"DeclareVariable\":\n      return printFlowDeclaration(path, [\"var \", path.call(print, \"id\"), \";\"]);\n    case \"DeclareExportDeclaration\":\n    case \"DeclareExportAllDeclaration\":\n      return lines_1.concat([\"declare \", printExportDeclaration(path, options, print)]);\n    case \"EnumDeclaration\":\n      return lines_1.concat([\"enum \", path.call(print, \"id\"), path.call(print, \"body\")]);\n    case \"EnumBooleanBody\":\n    case \"EnumNumberBody\":\n    case \"EnumStringBody\":\n    case \"EnumSymbolBody\":\n      {\n        if (n.type === \"EnumSymbolBody\" || n.explicitType) {\n          parts.push(\" of \",\n          // EnumBooleanBody => boolean, etc.\n          n.type.slice(4, -4).toLowerCase());\n        }\n        parts.push(\" {\\n\", lines_1.fromString(\"\\n\").join(path.map(print, \"members\")).indent(options.tabWidth), \"\\n}\");\n        return lines_1.concat(parts);\n      }\n    case \"EnumDefaultedMember\":\n      return lines_1.concat([path.call(print, \"id\"), \",\"]);\n    case \"EnumBooleanMember\":\n    case \"EnumNumberMember\":\n    case \"EnumStringMember\":\n      return lines_1.concat([path.call(print, \"id\"), \" = \", path.call(print, \"init\"), \",\"]);\n    case \"InferredPredicate\":\n      return lines_1.fromString(\"%checks\", options);\n    case \"DeclaredPredicate\":\n      return lines_1.concat([\"%checks(\", path.call(print, \"value\"), \")\"]);\n    case \"FunctionTypeAnnotation\":\n      {\n        // FunctionTypeAnnotation is ambiguous:\n        // declare function(a: B): void; OR\n        // const A: (a: B) => void;\n        var parent = path.getParentNode(0);\n        var isArrowFunctionTypeAnnotation = !(namedTypes.ObjectTypeCallProperty.check(parent) || namedTypes.ObjectTypeInternalSlot.check(parent) && parent.method || namedTypes.DeclareFunction.check(path.getParentNode(2)));\n        var needsColon = isArrowFunctionTypeAnnotation && !namedTypes.FunctionTypeParam.check(parent) && !namedTypes.TypeAlias.check(parent);\n        if (needsColon) {\n          parts.push(\": \");\n        }\n        var hasTypeParameters = !!n.typeParameters;\n        var needsParens = hasTypeParameters || n.params.length !== 1 || n.params[0].name;\n        parts.push(hasTypeParameters ? path.call(print, \"typeParameters\") : \"\", needsParens ? \"(\" : \"\", printFunctionParams(path, options, print), needsParens ? \")\" : \"\");\n        // The returnType is not wrapped in a TypeAnnotation, so the colon\n        // needs to be added separately.\n        if (n.returnType) {\n          parts.push(isArrowFunctionTypeAnnotation ? \" => \" : \": \", path.call(print, \"returnType\"));\n        }\n        return lines_1.concat(parts);\n      }\n    case \"FunctionTypeParam\":\n      {\n        var name = path.call(print, \"name\");\n        parts.push(name);\n        if (n.optional) {\n          parts.push(\"?\");\n        }\n        if (name.infos[0].line) {\n          parts.push(\": \");\n        }\n        parts.push(path.call(print, \"typeAnnotation\"));\n        return lines_1.concat(parts);\n      }\n    case \"GenericTypeAnnotation\":\n      return lines_1.concat([path.call(print, \"id\"), path.call(print, \"typeParameters\")]);\n    case \"DeclareInterface\":\n      parts.push(\"declare \");\n    // Fall through to InterfaceDeclaration...\n    case \"InterfaceDeclaration\":\n    case \"TSInterfaceDeclaration\":\n      if (n.declare) {\n        parts.push(\"declare \");\n      }\n      parts.push(\"interface \", path.call(print, \"id\"), path.call(print, \"typeParameters\"), \" \");\n      if (n[\"extends\"] && n[\"extends\"].length > 0) {\n        parts.push(\"extends \", lines_1.fromString(\", \").join(path.map(print, \"extends\")), \" \");\n      }\n      if (n.body) {\n        parts.push(path.call(print, \"body\"));\n      }\n      return lines_1.concat(parts);\n    case \"ClassImplements\":\n    case \"InterfaceExtends\":\n      return lines_1.concat([path.call(print, \"id\"), path.call(print, \"typeParameters\")]);\n    case \"IntersectionTypeAnnotation\":\n      return lines_1.fromString(\" & \").join(path.map(print, \"types\"));\n    case \"NullableTypeAnnotation\":\n      return lines_1.concat([\"?\", path.call(print, \"typeAnnotation\")]);\n    case \"NullLiteralTypeAnnotation\":\n      return lines_1.fromString(\"null\", options);\n    case \"ThisTypeAnnotation\":\n      return lines_1.fromString(\"this\", options);\n    case \"NumberTypeAnnotation\":\n      return lines_1.fromString(\"number\", options);\n    case \"ObjectTypeCallProperty\":\n      return path.call(print, \"value\");\n    case \"ObjectTypeIndexer\":\n      if (n.static) {\n        parts.push(\"static \");\n      }\n      parts.push(printVariance(path, print), \"[\");\n      if (n.id) {\n        parts.push(path.call(print, \"id\"), \": \");\n      }\n      parts.push(path.call(print, \"key\"), \"]: \", path.call(print, \"value\"));\n      return lines_1.concat(parts);\n    case \"ObjectTypeProperty\":\n      return lines_1.concat([printVariance(path, print), path.call(print, \"key\"), n.optional ? \"?\" : \"\", \": \", path.call(print, \"value\")]);\n    case \"ObjectTypeInternalSlot\":\n      return lines_1.concat([n.static ? \"static \" : \"\", \"[[\", path.call(print, \"id\"), \"]]\", n.optional ? \"?\" : \"\", n.value.type !== \"FunctionTypeAnnotation\" ? \": \" : \"\", path.call(print, \"value\")]);\n    case \"QualifiedTypeIdentifier\":\n      return lines_1.concat([path.call(print, \"qualification\"), \".\", path.call(print, \"id\")]);\n    case \"StringLiteralTypeAnnotation\":\n      return lines_1.fromString(nodeStr(n.value, options), options);\n    case \"NumberLiteralTypeAnnotation\":\n    case \"NumericLiteralTypeAnnotation\":\n      assert_1.default.strictEqual(typeof n.value, \"number\");\n      return lines_1.fromString(JSON.stringify(n.value), options);\n    case \"BigIntLiteralTypeAnnotation\":\n      return lines_1.fromString(n.raw, options);\n    case \"StringTypeAnnotation\":\n      return lines_1.fromString(\"string\", options);\n    case \"DeclareTypeAlias\":\n      parts.push(\"declare \");\n    // Fall through to TypeAlias...\n    case \"TypeAlias\":\n      return lines_1.concat([\"type \", path.call(print, \"id\"), path.call(print, \"typeParameters\"), \" = \", path.call(print, \"right\"), \";\"]);\n    case \"DeclareOpaqueType\":\n      parts.push(\"declare \");\n    // Fall through to OpaqueType...\n    case \"OpaqueType\":\n      parts.push(\"opaque type \", path.call(print, \"id\"), path.call(print, \"typeParameters\"));\n      if (n[\"supertype\"]) {\n        parts.push(\": \", path.call(print, \"supertype\"));\n      }\n      if (n[\"impltype\"]) {\n        parts.push(\" = \", path.call(print, \"impltype\"));\n      }\n      parts.push(\";\");\n      return lines_1.concat(parts);\n    case \"TypeCastExpression\":\n      return lines_1.concat([\"(\", path.call(print, \"expression\"), path.call(print, \"typeAnnotation\"), \")\"]);\n    case \"TypeParameterDeclaration\":\n    case \"TypeParameterInstantiation\":\n      return lines_1.concat([\"<\", lines_1.fromString(\", \").join(path.map(print, \"params\")), \">\"]);\n    case \"Variance\":\n      if (n.kind === \"plus\") {\n        return lines_1.fromString(\"+\");\n      }\n      if (n.kind === \"minus\") {\n        return lines_1.fromString(\"-\");\n      }\n      return lines_1.fromString(\"\");\n    case \"TypeParameter\":\n      if (n.variance) {\n        parts.push(printVariance(path, print));\n      }\n      parts.push(path.call(print, \"name\"));\n      if (n.bound) {\n        parts.push(path.call(print, \"bound\"));\n      }\n      if (n[\"default\"]) {\n        parts.push(\"=\", path.call(print, \"default\"));\n      }\n      return lines_1.concat(parts);\n    case \"TypeofTypeAnnotation\":\n      return lines_1.concat([lines_1.fromString(\"typeof \", options), path.call(print, \"argument\")]);\n    case \"UnionTypeAnnotation\":\n      return lines_1.fromString(\" | \").join(path.map(print, \"types\"));\n    case \"VoidTypeAnnotation\":\n      return lines_1.fromString(\"void\", options);\n    case \"NullTypeAnnotation\":\n      return lines_1.fromString(\"null\", options);\n    case \"SymbolTypeAnnotation\":\n      return lines_1.fromString(\"symbol\", options);\n    case \"BigIntTypeAnnotation\":\n      return lines_1.fromString(\"bigint\", options);\n    // Type Annotations for TypeScript (when using Babylon as parser)\n    case \"TSType\":\n      throw new Error(\"unprintable type: \" + JSON.stringify(n.type));\n    case \"TSNumberKeyword\":\n      return lines_1.fromString(\"number\", options);\n    case \"TSBigIntKeyword\":\n      return lines_1.fromString(\"bigint\", options);\n    case \"TSObjectKeyword\":\n      return lines_1.fromString(\"object\", options);\n    case \"TSBooleanKeyword\":\n      return lines_1.fromString(\"boolean\", options);\n    case \"TSStringKeyword\":\n      return lines_1.fromString(\"string\", options);\n    case \"TSSymbolKeyword\":\n      return lines_1.fromString(\"symbol\", options);\n    case \"TSAnyKeyword\":\n      return lines_1.fromString(\"any\", options);\n    case \"TSVoidKeyword\":\n      return lines_1.fromString(\"void\", options);\n    case \"TSThisType\":\n      return lines_1.fromString(\"this\", options);\n    case \"TSNullKeyword\":\n      return lines_1.fromString(\"null\", options);\n    case \"TSUndefinedKeyword\":\n      return lines_1.fromString(\"undefined\", options);\n    case \"TSUnknownKeyword\":\n      return lines_1.fromString(\"unknown\", options);\n    case \"TSNeverKeyword\":\n      return lines_1.fromString(\"never\", options);\n    case \"TSArrayType\":\n      return lines_1.concat([path.call(print, \"elementType\"), \"[]\"]);\n    case \"TSLiteralType\":\n      return path.call(print, \"literal\");\n    case \"TSUnionType\":\n      return lines_1.fromString(\" | \").join(path.map(print, \"types\"));\n    case \"TSIntersectionType\":\n      return lines_1.fromString(\" & \").join(path.map(print, \"types\"));\n    case \"TSConditionalType\":\n      parts.push(path.call(print, \"checkType\"), \" extends \", path.call(print, \"extendsType\"), \" ? \", path.call(print, \"trueType\"), \" : \", path.call(print, \"falseType\"));\n      return lines_1.concat(parts);\n    case \"TSInferType\":\n      parts.push(\"infer \", path.call(print, \"typeParameter\"));\n      return lines_1.concat(parts);\n    case \"TSParenthesizedType\":\n      return lines_1.concat([\"(\", path.call(print, \"typeAnnotation\"), \")\"]);\n    case \"TSFunctionType\":\n      return lines_1.concat([path.call(print, \"typeParameters\"), \"(\", printFunctionParams(path, options, print), \") => \", path.call(print, \"typeAnnotation\", \"typeAnnotation\")]);\n    case \"TSConstructorType\":\n      return lines_1.concat([\"new \", path.call(print, \"typeParameters\"), \"(\", printFunctionParams(path, options, print), \") => \", path.call(print, \"typeAnnotation\", \"typeAnnotation\")]);\n    case \"TSMappedType\":\n      {\n        parts.push(n.readonly ? \"readonly \" : \"\", \"[\", path.call(print, \"typeParameter\"), \"]\", n.optional ? \"?\" : \"\");\n        if (n.typeAnnotation) {\n          parts.push(\": \", path.call(print, \"typeAnnotation\"), \";\");\n        }\n        return lines_1.concat([\"{\\n\", lines_1.concat(parts).indent(options.tabWidth), \"\\n}\"]);\n      }\n    case \"TSTupleType\":\n      return lines_1.concat([\"[\", lines_1.fromString(\", \").join(path.map(print, \"elementTypes\")), \"]\"]);\n    case \"TSNamedTupleMember\":\n      parts.push(path.call(print, \"label\"));\n      if (n.optional) {\n        parts.push(\"?\");\n      }\n      parts.push(\": \", path.call(print, \"elementType\"));\n      return lines_1.concat(parts);\n    case \"TSRestType\":\n      return lines_1.concat([\"...\", path.call(print, \"typeAnnotation\")]);\n    case \"TSOptionalType\":\n      return lines_1.concat([path.call(print, \"typeAnnotation\"), \"?\"]);\n    case \"TSIndexedAccessType\":\n      return lines_1.concat([path.call(print, \"objectType\"), \"[\", path.call(print, \"indexType\"), \"]\"]);\n    case \"TSTypeOperator\":\n      return lines_1.concat([path.call(print, \"operator\"), \" \", path.call(print, \"typeAnnotation\")]);\n    case \"TSTypeLiteral\":\n      {\n        var memberLines = lines_1.fromString(\",\\n\").join(path.map(print, \"members\"));\n        if (memberLines.isEmpty()) {\n          return lines_1.fromString(\"{}\", options);\n        }\n        parts.push(\"{\\n\", memberLines.indent(options.tabWidth), \"\\n}\");\n        return lines_1.concat(parts);\n      }\n    case \"TSEnumMember\":\n      parts.push(path.call(print, \"id\"));\n      if (n.initializer) {\n        parts.push(\" = \", path.call(print, \"initializer\"));\n      }\n      return lines_1.concat(parts);\n    case \"TSTypeQuery\":\n      return lines_1.concat([\"typeof \", path.call(print, \"exprName\")]);\n    case \"TSParameterProperty\":\n      if (n.accessibility) {\n        parts.push(n.accessibility, \" \");\n      }\n      if (n.export) {\n        parts.push(\"export \");\n      }\n      if (n.static) {\n        parts.push(\"static \");\n      }\n      if (n.readonly) {\n        parts.push(\"readonly \");\n      }\n      parts.push(path.call(print, \"parameter\"));\n      return lines_1.concat(parts);\n    case \"TSTypeReference\":\n      return lines_1.concat([path.call(print, \"typeName\"), path.call(print, \"typeParameters\")]);\n    case \"TSQualifiedName\":\n      return lines_1.concat([path.call(print, \"left\"), \".\", path.call(print, \"right\")]);\n    case \"TSAsExpression\":\n      {\n        var expression = path.call(print, \"expression\");\n        parts.push(expression, lines_1.fromString(\" as \"), path.call(print, \"typeAnnotation\"));\n        return lines_1.concat(parts);\n      }\n    case \"TSNonNullExpression\":\n      return lines_1.concat([path.call(print, \"expression\"), \"!\"]);\n    case \"TSTypeAnnotation\":\n      return lines_1.concat([\": \", path.call(print, \"typeAnnotation\")]);\n    case \"TSIndexSignature\":\n      return lines_1.concat([n.readonly ? \"readonly \" : \"\", \"[\", path.map(print, \"parameters\"), \"]\", path.call(print, \"typeAnnotation\")]);\n    case \"TSPropertySignature\":\n      parts.push(printVariance(path, print), n.readonly ? \"readonly \" : \"\");\n      if (n.computed) {\n        parts.push(\"[\", path.call(print, \"key\"), \"]\");\n      } else {\n        parts.push(path.call(print, \"key\"));\n      }\n      parts.push(n.optional ? \"?\" : \"\", path.call(print, \"typeAnnotation\"));\n      return lines_1.concat(parts);\n    case \"TSMethodSignature\":\n      if (n.computed) {\n        parts.push(\"[\", path.call(print, \"key\"), \"]\");\n      } else {\n        parts.push(path.call(print, \"key\"));\n      }\n      if (n.optional) {\n        parts.push(\"?\");\n      }\n      parts.push(path.call(print, \"typeParameters\"), \"(\", printFunctionParams(path, options, print), \")\", path.call(print, \"typeAnnotation\"));\n      return lines_1.concat(parts);\n    case \"TSTypePredicate\":\n      if (n.asserts) {\n        parts.push(\"asserts \");\n      }\n      parts.push(path.call(print, \"parameterName\"));\n      if (n.typeAnnotation) {\n        parts.push(\" is \", path.call(print, \"typeAnnotation\", \"typeAnnotation\"));\n      }\n      return lines_1.concat(parts);\n    case \"TSCallSignatureDeclaration\":\n      return lines_1.concat([path.call(print, \"typeParameters\"), \"(\", printFunctionParams(path, options, print), \")\", path.call(print, \"typeAnnotation\")]);\n    case \"TSConstructSignatureDeclaration\":\n      if (n.typeParameters) {\n        parts.push(\"new\", path.call(print, \"typeParameters\"));\n      } else {\n        parts.push(\"new \");\n      }\n      parts.push(\"(\", printFunctionParams(path, options, print), \")\", path.call(print, \"typeAnnotation\"));\n      return lines_1.concat(parts);\n    case \"TSTypeAliasDeclaration\":\n      return lines_1.concat([n.declare ? \"declare \" : \"\", \"type \", path.call(print, \"id\"), path.call(print, \"typeParameters\"), \" = \", path.call(print, \"typeAnnotation\"), \";\"]);\n    case \"TSTypeParameter\":\n      {\n        parts.push(path.call(print, \"name\"));\n        // ambiguous because of TSMappedType\n        var parent = path.getParentNode(0);\n        var isInMappedType = namedTypes.TSMappedType.check(parent);\n        if (n.constraint) {\n          parts.push(isInMappedType ? \" in \" : \" extends \", path.call(print, \"constraint\"));\n        }\n        if (n[\"default\"]) {\n          parts.push(\" = \", path.call(print, \"default\"));\n        }\n        return lines_1.concat(parts);\n      }\n    case \"TSTypeAssertion\":\n      {\n        parts.push(\"<\", path.call(print, \"typeAnnotation\"), \"> \", path.call(print, \"expression\"));\n        return lines_1.concat(parts);\n      }\n    case \"TSTypeParameterDeclaration\":\n    case \"TSTypeParameterInstantiation\":\n      return lines_1.concat([\"<\", lines_1.fromString(\", \").join(path.map(print, \"params\")), \">\"]);\n    case \"TSEnumDeclaration\":\n      {\n        parts.push(n.declare ? \"declare \" : \"\", n.const ? \"const \" : \"\", \"enum \", path.call(print, \"id\"));\n        var memberLines = lines_1.fromString(\",\\n\").join(path.map(print, \"members\"));\n        if (memberLines.isEmpty()) {\n          parts.push(\" {}\");\n        } else {\n          parts.push(\" {\\n\", memberLines.indent(options.tabWidth), \"\\n}\");\n        }\n        return lines_1.concat(parts);\n      }\n    case \"TSExpressionWithTypeArguments\":\n      return lines_1.concat([path.call(print, \"expression\"), path.call(print, \"typeParameters\")]);\n    case \"TSInterfaceBody\":\n      {\n        var lines = lines_1.fromString(\";\\n\").join(path.map(print, \"body\"));\n        if (lines.isEmpty()) {\n          return lines_1.fromString(\"{}\", options);\n        }\n        return lines_1.concat([\"{\\n\", lines.indent(options.tabWidth), \";\", \"\\n}\"]);\n      }\n    case \"TSImportType\":\n      parts.push(\"import(\", path.call(print, \"argument\"), \")\");\n      if (n.qualifier) {\n        parts.push(\".\", path.call(print, \"qualifier\"));\n      }\n      if (n.typeParameters) {\n        parts.push(path.call(print, \"typeParameters\"));\n      }\n      return lines_1.concat(parts);\n    case \"TSImportEqualsDeclaration\":\n      if (n.isExport) {\n        parts.push(\"export \");\n      }\n      parts.push(\"import \", path.call(print, \"id\"), \" = \", path.call(print, \"moduleReference\"));\n      return maybeAddSemicolon(lines_1.concat(parts));\n    case \"TSExternalModuleReference\":\n      return lines_1.concat([\"require(\", path.call(print, \"expression\"), \")\"]);\n    case \"TSModuleDeclaration\":\n      {\n        var parent = path.getParentNode();\n        if (parent.type === \"TSModuleDeclaration\") {\n          parts.push(\".\");\n        } else {\n          if (n.declare) {\n            parts.push(\"declare \");\n          }\n          if (!n.global) {\n            var isExternal = n.id.type === \"StringLiteral\" || n.id.type === \"Literal\" && typeof n.id.value === \"string\";\n            if (isExternal) {\n              parts.push(\"module \");\n            } else if (n.loc && n.loc.lines && n.id.loc) {\n              var prefix = n.loc.lines.sliceString(n.loc.start, n.id.loc.start);\n              // These keywords are fundamentally ambiguous in the\n              // Babylon parser, and not reflected in the AST, so\n              // the best we can do is to match the original code,\n              // when possible.\n              if (prefix.indexOf(\"module\") >= 0) {\n                parts.push(\"module \");\n              } else {\n                parts.push(\"namespace \");\n              }\n            } else {\n              parts.push(\"namespace \");\n            }\n          }\n        }\n        parts.push(path.call(print, \"id\"));\n        if (n.body && n.body.type === \"TSModuleDeclaration\") {\n          parts.push(path.call(print, \"body\"));\n        } else if (n.body) {\n          var bodyLines = path.call(print, \"body\");\n          if (bodyLines.isEmpty()) {\n            parts.push(\" {}\");\n          } else {\n            parts.push(\" {\\n\", bodyLines.indent(options.tabWidth), \"\\n}\");\n          }\n        }\n        return lines_1.concat(parts);\n      }\n    case \"TSModuleBlock\":\n      return path.call(function (bodyPath) {\n        return printStatementSequence(bodyPath, options, print);\n      }, \"body\");\n    // Unhandled types below. If encountered, nodes of these types should\n    // be either left alone or desugared into AST types that are fully\n    // supported by the pretty-printer.\n    case \"ClassHeritage\": // TODO\n    case \"ComprehensionBlock\": // TODO\n    case \"ComprehensionExpression\": // TODO\n    case \"Glob\": // TODO\n    case \"GeneratorExpression\": // TODO\n    case \"LetStatement\": // TODO\n    case \"LetExpression\": // TODO\n    case \"GraphExpression\": // TODO\n    case \"GraphIndexExpression\": // TODO\n    case \"XMLDefaultDeclaration\":\n    case \"XMLAnyName\":\n    case \"XMLQualifiedIdentifier\":\n    case \"XMLFunctionQualifiedIdentifier\":\n    case \"XMLAttributeSelector\":\n    case \"XMLFilterExpression\":\n    case \"XML\":\n    case \"XMLElement\":\n    case \"XMLList\":\n    case \"XMLEscape\":\n    case \"XMLText\":\n    case \"XMLStartTag\":\n    case \"XMLEndTag\":\n    case \"XMLPointTag\":\n    case \"XMLName\":\n    case \"XMLAttribute\":\n    case \"XMLCdata\":\n    case \"XMLComment\":\n    case \"XMLProcessingInstruction\":\n    default:\n      debugger;\n      throw new Error(\"unknown type: \" + JSON.stringify(n.type));\n  }\n}\nfunction printDecorators(path, printPath) {\n  var parts = [];\n  var node = path.getValue();\n  if (node.decorators && node.decorators.length > 0 &&\n  // If the parent node is an export declaration, it will be\n  // responsible for printing node.decorators.\n  !util.getParentExportDeclaration(path)) {\n    path.each(function (decoratorPath) {\n      parts.push(printPath(decoratorPath), \"\\n\");\n    }, \"decorators\");\n  } else if (util.isExportDeclaration(node) && node.declaration && node.declaration.decorators) {\n    // Export declarations are responsible for printing any decorators\n    // that logically apply to node.declaration.\n    path.each(function (decoratorPath) {\n      parts.push(printPath(decoratorPath), \"\\n\");\n    }, \"declaration\", \"decorators\");\n  }\n  return lines_1.concat(parts);\n}\nfunction printStatementSequence(path, options, print) {\n  var filtered = [];\n  var sawComment = false;\n  var sawStatement = false;\n  path.each(function (stmtPath) {\n    var stmt = stmtPath.getValue();\n    // Just in case the AST has been modified to contain falsy\n    // \"statements,\" it's safer simply to skip them.\n    if (!stmt) {\n      return;\n    }\n    // Skip printing EmptyStatement nodes to avoid leaving stray\n    // semicolons lying around.\n    if (stmt.type === \"EmptyStatement\" && !(stmt.comments && stmt.comments.length > 0)) {\n      return;\n    }\n    if (namedTypes.Comment.check(stmt)) {\n      // The pretty printer allows a dangling Comment node to act as\n      // a Statement when the Comment can't be attached to any other\n      // non-Comment node in the tree.\n      sawComment = true;\n    } else if (namedTypes.Statement.check(stmt)) {\n      sawStatement = true;\n    } else {\n      // When the pretty printer encounters a string instead of an\n      // AST node, it just prints the string. This behavior can be\n      // useful for fine-grained formatting decisions like inserting\n      // blank lines.\n      isString.assert(stmt);\n    }\n    // We can't hang onto stmtPath outside of this function, because\n    // it's just a reference to a mutable FastPath object, so we have\n    // to go ahead and print it here.\n    filtered.push({\n      node: stmt,\n      printed: print(stmtPath)\n    });\n  });\n  if (sawComment) {\n    assert_1.default.strictEqual(sawStatement, false, \"Comments may appear as statements in otherwise empty statement \" + \"lists, but may not coexist with non-Comment nodes.\");\n  }\n  var prevTrailingSpace = null;\n  var len = filtered.length;\n  var parts = [];\n  filtered.forEach(function (info, i) {\n    var printed = info.printed;\n    var stmt = info.node;\n    var multiLine = printed.length > 1;\n    var notFirst = i > 0;\n    var notLast = i < len - 1;\n    var leadingSpace;\n    var trailingSpace;\n    var lines = stmt && stmt.loc && stmt.loc.lines;\n    var trueLoc = lines && options.reuseWhitespace && util.getTrueLoc(stmt, lines);\n    if (notFirst) {\n      if (trueLoc) {\n        var beforeStart = lines.skipSpaces(trueLoc.start, true);\n        var beforeStartLine = beforeStart ? beforeStart.line : 1;\n        var leadingGap = trueLoc.start.line - beforeStartLine;\n        leadingSpace = Array(leadingGap + 1).join(\"\\n\");\n      } else {\n        leadingSpace = multiLine ? \"\\n\\n\" : \"\\n\";\n      }\n    } else {\n      leadingSpace = \"\";\n    }\n    if (notLast) {\n      if (trueLoc) {\n        var afterEnd = lines.skipSpaces(trueLoc.end);\n        var afterEndLine = afterEnd ? afterEnd.line : lines.length;\n        var trailingGap = afterEndLine - trueLoc.end.line;\n        trailingSpace = Array(trailingGap + 1).join(\"\\n\");\n      } else {\n        trailingSpace = multiLine ? \"\\n\\n\" : \"\\n\";\n      }\n    } else {\n      trailingSpace = \"\";\n    }\n    parts.push(maxSpace(prevTrailingSpace, leadingSpace), printed);\n    if (notLast) {\n      prevTrailingSpace = trailingSpace;\n    } else if (trailingSpace) {\n      parts.push(trailingSpace);\n    }\n  });\n  return lines_1.concat(parts);\n}\nfunction maxSpace(s1, s2) {\n  if (!s1 && !s2) {\n    return lines_1.fromString(\"\");\n  }\n  if (!s1) {\n    return lines_1.fromString(s2);\n  }\n  if (!s2) {\n    return lines_1.fromString(s1);\n  }\n  var spaceLines1 = lines_1.fromString(s1);\n  var spaceLines2 = lines_1.fromString(s2);\n  if (spaceLines2.length > spaceLines1.length) {\n    return spaceLines2;\n  }\n  return spaceLines1;\n}\nfunction printMethod(path, options, print) {\n  var node = path.getNode();\n  var kind = node.kind;\n  var parts = [];\n  var nodeValue = node.value;\n  if (!namedTypes.FunctionExpression.check(nodeValue)) {\n    nodeValue = node;\n  }\n  var access = node.accessibility || node.access;\n  if (typeof access === \"string\") {\n    parts.push(access, \" \");\n  }\n  if (node.static) {\n    parts.push(\"static \");\n  }\n  if (node.abstract) {\n    parts.push(\"abstract \");\n  }\n  if (node.readonly) {\n    parts.push(\"readonly \");\n  }\n  if (nodeValue.async) {\n    parts.push(\"async \");\n  }\n  if (nodeValue.generator) {\n    parts.push(\"*\");\n  }\n  if (kind === \"get\" || kind === \"set\") {\n    parts.push(kind, \" \");\n  }\n  var key = path.call(print, \"key\");\n  if (node.computed) {\n    key = lines_1.concat([\"[\", key, \"]\"]);\n  }\n  parts.push(key);\n  if (node.optional) {\n    parts.push(\"?\");\n  }\n  if (node === nodeValue) {\n    parts.push(path.call(print, \"typeParameters\"), \"(\", printFunctionParams(path, options, print), \")\", path.call(print, \"returnType\"));\n    if (node.body) {\n      parts.push(\" \", path.call(print, \"body\"));\n    } else {\n      parts.push(\";\");\n    }\n  } else {\n    parts.push(path.call(print, \"value\", \"typeParameters\"), \"(\", path.call(function (valuePath) {\n      return printFunctionParams(valuePath, options, print);\n    }, \"value\"), \")\", path.call(print, \"value\", \"returnType\"));\n    if (nodeValue.body) {\n      parts.push(\" \", path.call(print, \"value\", \"body\"));\n    } else {\n      parts.push(\";\");\n    }\n  }\n  return lines_1.concat(parts);\n}\nfunction printArgumentsList(path, options, print) {\n  var printed = path.map(print, \"arguments\");\n  var trailingComma = util.isTrailingCommaEnabled(options, \"parameters\");\n  var joined = lines_1.fromString(\", \").join(printed);\n  if (joined.getLineLength(1) > options.wrapColumn) {\n    joined = lines_1.fromString(\",\\n\").join(printed);\n    return lines_1.concat([\"(\\n\", joined.indent(options.tabWidth), trailingComma ? \",\\n)\" : \"\\n)\"]);\n  }\n  return lines_1.concat([\"(\", joined, \")\"]);\n}\nfunction printFunctionParams(path, options, print) {\n  var fun = path.getValue();\n  var params;\n  var printed = [];\n  if (fun.params) {\n    params = fun.params;\n    printed = path.map(print, \"params\");\n  } else if (fun.parameters) {\n    params = fun.parameters;\n    printed = path.map(print, \"parameters\");\n  }\n  if (fun.defaults) {\n    path.each(function (defExprPath) {\n      var i = defExprPath.getName();\n      var p = printed[i];\n      if (p && defExprPath.getValue()) {\n        printed[i] = lines_1.concat([p, \" = \", print(defExprPath)]);\n      }\n    }, \"defaults\");\n  }\n  if (fun.rest) {\n    printed.push(lines_1.concat([\"...\", path.call(print, \"rest\")]));\n  }\n  var joined = lines_1.fromString(\", \").join(printed);\n  if (joined.length > 1 || joined.getLineLength(1) > options.wrapColumn) {\n    joined = lines_1.fromString(\",\\n\").join(printed);\n    if (util.isTrailingCommaEnabled(options, \"parameters\") && !fun.rest && params[params.length - 1].type !== \"RestElement\") {\n      joined = lines_1.concat([joined, \",\\n\"]);\n    } else {\n      joined = lines_1.concat([joined, \"\\n\"]);\n    }\n    return lines_1.concat([\"\\n\", joined.indent(options.tabWidth)]);\n  }\n  return joined;\n}\nfunction printExportDeclaration(path, options, print) {\n  var decl = path.getValue();\n  var parts = [\"export \"];\n  if (decl.exportKind && decl.exportKind === \"type\") {\n    if (!decl.declaration) {\n      parts.push(\"type \");\n    }\n  }\n  var shouldPrintSpaces = options.objectCurlySpacing;\n  namedTypes.Declaration.assert(decl);\n  if (decl[\"default\"] || decl.type === \"ExportDefaultDeclaration\") {\n    parts.push(\"default \");\n  }\n  if (decl.declaration) {\n    parts.push(path.call(print, \"declaration\"));\n  } else if (decl.specifiers) {\n    if (decl.specifiers.length === 1 && decl.specifiers[0].type === \"ExportBatchSpecifier\") {\n      parts.push(\"*\");\n    } else if (decl.specifiers.length === 0) {\n      parts.push(\"{}\");\n    } else if (decl.specifiers[0].type === \"ExportDefaultSpecifier\") {\n      var unbracedSpecifiers_2 = [];\n      var bracedSpecifiers_2 = [];\n      path.each(function (specifierPath) {\n        var spec = specifierPath.getValue();\n        if (spec.type === \"ExportDefaultSpecifier\") {\n          unbracedSpecifiers_2.push(print(specifierPath));\n        } else {\n          bracedSpecifiers_2.push(print(specifierPath));\n        }\n      }, \"specifiers\");\n      unbracedSpecifiers_2.forEach(function (lines, i) {\n        if (i > 0) {\n          parts.push(\", \");\n        }\n        parts.push(lines);\n      });\n      if (bracedSpecifiers_2.length > 0) {\n        var lines_2 = lines_1.fromString(\", \").join(bracedSpecifiers_2);\n        if (lines_2.getLineLength(1) > options.wrapColumn) {\n          lines_2 = lines_1.concat([lines_1.fromString(\",\\n\").join(bracedSpecifiers_2).indent(options.tabWidth), \",\"]);\n        }\n        if (unbracedSpecifiers_2.length > 0) {\n          parts.push(\", \");\n        }\n        if (lines_2.length > 1) {\n          parts.push(\"{\\n\", lines_2, \"\\n}\");\n        } else if (options.objectCurlySpacing) {\n          parts.push(\"{ \", lines_2, \" }\");\n        } else {\n          parts.push(\"{\", lines_2, \"}\");\n        }\n      }\n    } else {\n      parts.push(shouldPrintSpaces ? \"{ \" : \"{\", lines_1.fromString(\", \").join(path.map(print, \"specifiers\")), shouldPrintSpaces ? \" }\" : \"}\");\n    }\n    if (decl.source) {\n      parts.push(\" from \", path.call(print, \"source\"));\n    }\n  }\n  var lines = lines_1.concat(parts);\n  if (lastNonSpaceCharacter(lines) !== \";\" && !(decl.declaration && (decl.declaration.type === \"FunctionDeclaration\" || decl.declaration.type === \"ClassDeclaration\" || decl.declaration.type === \"TSModuleDeclaration\" || decl.declaration.type === \"TSInterfaceDeclaration\" || decl.declaration.type === \"TSEnumDeclaration\"))) {\n    lines = lines_1.concat([lines, \";\"]);\n  }\n  return lines;\n}\nfunction printFlowDeclaration(path, parts) {\n  var parentExportDecl = util.getParentExportDeclaration(path);\n  if (parentExportDecl) {\n    assert_1.default.strictEqual(parentExportDecl.type, \"DeclareExportDeclaration\");\n  } else {\n    // If the parent node has type DeclareExportDeclaration, then it\n    // will be responsible for printing the \"declare\" token. Otherwise\n    // it needs to be printed with this non-exported declaration node.\n    parts.unshift(\"declare \");\n  }\n  return lines_1.concat(parts);\n}\nfunction printVariance(path, print) {\n  return path.call(function (variancePath) {\n    var value = variancePath.getValue();\n    if (value) {\n      if (value === \"plus\") {\n        return lines_1.fromString(\"+\");\n      }\n      if (value === \"minus\") {\n        return lines_1.fromString(\"-\");\n      }\n      return print(variancePath);\n    }\n    return lines_1.fromString(\"\");\n  }, \"variance\");\n}\nfunction adjustClause(clause, options) {\n  if (clause.length > 1) return lines_1.concat([\" \", clause]);\n  return lines_1.concat([\"\\n\", maybeAddSemicolon(clause).indent(options.tabWidth)]);\n}\nfunction lastNonSpaceCharacter(lines) {\n  var pos = lines.lastPos();\n  do {\n    var ch = lines.charAt(pos);\n    if (/\\S/.test(ch)) return ch;\n  } while (lines.prevPos(pos));\n}\nfunction endsWithBrace(lines) {\n  return lastNonSpaceCharacter(lines) === \"}\";\n}\nfunction swapQuotes(str) {\n  return str.replace(/['\"]/g, function (m) {\n    return m === '\"' ? \"'\" : '\"';\n  });\n}\nfunction nodeStr(str, options) {\n  isString.assert(str);\n  switch (options.quote) {\n    case \"auto\":\n      {\n        var double = JSON.stringify(str);\n        var single = swapQuotes(JSON.stringify(swapQuotes(str)));\n        return double.length > single.length ? single : double;\n      }\n    case \"single\":\n      return swapQuotes(JSON.stringify(swapQuotes(str)));\n    case \"double\":\n    default:\n      return JSON.stringify(str);\n  }\n}\nfunction maybeAddSemicolon(lines) {\n  var eoc = lastNonSpaceCharacter(lines);\n  if (!eoc || \"\\n};\".indexOf(eoc) < 0) return lines_1.concat([lines, \";\"]);\n  return lines;\n}","map":{"version":3,"names":["Object","defineProperty","exports","value","Printer","tslib_1","require","assert_1","__importDefault","comments_1","lines_1","options_1","patcher_1","types","__importStar","namedTypes","isString","builtInTypes","string","isObject","object","fast_path_1","util","PrintResult","code","sourceMap","default","ok","assert","map","PRp","prototype","warnedAboutToString","toString","console","warn","emptyPrintResult","config","explicitTabWidth","tabWidth","normalize","sourceFileName","makePrintFunctionWith","options","overrides","assign","path","print","includeComments","printComments","oldTabWidth","loc","getNode","lines","guessTabWidth","reprinter","getReprinter","genericPrint","avoidRootParens","ast","from","composeSourceMaps","inputSourceMap","getSourceMap","sourceMapName","sourceRoot","printGenerically","oldReuseWhitespace","reuseWhitespace","pr","printPath","node","getValue","parts","linesWithoutParens","genericPrintNoParens","isEmpty","shouldAddParens","extra","parenthesized","decoratorsLines","printDecorators","needsParens","push","unshift","concat","n","fromString","Printable","type","call","directives","each","childPath","interpreter","bodyPath","printStatementSequence","join","operator","property","optional","getFieldValue","computed","body","name","declare","async","generator","id","typeParameters","printFunctionParams","arrowParensAlways","params","length","rest","typeAnnotation","returnType","printMethod","delegate","argument","all","source","importKind","imported","local","exported","printExportDeclaration","maybeAddSemicolon","specifiers","unbracedSpecifiers_1","bracedSpecifiers_1","specifierPath","spec","forEach","i","getLineLength","wrapColumn","indent","objectCurlySpacing","naked_1","argLines","startsWithComment","JSXElement","check","typeArguments","printArgumentsList","isTypeAnnotation_1","separator_1","flowObjectCommas","fields","allowBreak_1","internalSlots","len_1","field","oneLine_1","leftBrace","exact","rightBrace","leftBraceIndex","i_1","multiLine","isTrailingCommaEnabled","inexact","line","method","kind","shorthand","key","elems","elements","len_2","printed_1","joined","oneLine_2","arrayBracketSpacing","elemPath","getName","elem","raw","Number","nodeStr","Error","test","prefix","reverse","args","arguments","maxLen_1","printed","Math","max","indentTail","parentNode","getParentNode","ForStatement","ForInStatement","ForOfStatement","ForAwaitStatement","init","con","adjustClause","alternate","endsWithBrace","sep","forParen","indented","head","clause","trimLeft","await","doBody","statements","label","handler","handlers","handlerPath","finalizer","param","guard","consequent","consequentPath","openingPropName","closingPropName","openingLines","selfClosing","childLines","child","Literal","replace","closingLines","attrParts_1","attrPath","attrLines","needLineWrap","part","strictEqual","MethodDefinition","definition","access","accessibility","static","abstract","readonly","variance","printVariance","superClass","lockIndentTail","expressions_1","JSON","stringify","printed_2","oneLine_3","extends","printFlowDeclaration","explicitType","slice","toLowerCase","parent","isArrowFunctionTypeAnnotation","ObjectTypeCallProperty","ObjectTypeInternalSlot","DeclareFunction","needsColon","FunctionTypeParam","TypeAlias","hasTypeParameters","infos","bound","memberLines","initializer","export","expression","asserts","isInMappedType","TSMappedType","constraint","const","qualifier","isExport","global","isExternal","sliceString","start","indexOf","bodyLines","decorators","getParentExportDeclaration","decoratorPath","isExportDeclaration","declaration","filtered","sawComment","sawStatement","stmtPath","stmt","comments","Comment","Statement","prevTrailingSpace","len","info","notFirst","notLast","leadingSpace","trailingSpace","trueLoc","getTrueLoc","beforeStart","skipSpaces","beforeStartLine","leadingGap","Array","afterEnd","end","afterEndLine","trailingGap","maxSpace","s1","s2","spaceLines1","spaceLines2","nodeValue","FunctionExpression","valuePath","trailingComma","fun","parameters","defaults","defExprPath","p","decl","exportKind","shouldPrintSpaces","Declaration","unbracedSpecifiers_2","bracedSpecifiers_2","lines_2","lastNonSpaceCharacter","parentExportDecl","variancePath","pos","lastPos","ch","charAt","prevPos","swapQuotes","str","m","quote","double","single","eoc"],"sources":["C:/Users/Acer/Desktop/dev__book/dev__book/node_modules/jscodeshift/node_modules/recast/lib/printer.js"],"sourcesContent":["\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.Printer = void 0;\nvar tslib_1 = require(\"tslib\");\nvar assert_1 = tslib_1.__importDefault(require(\"assert\"));\nvar comments_1 = require(\"./comments\");\nvar lines_1 = require(\"./lines\");\nvar options_1 = require(\"./options\");\nvar patcher_1 = require(\"./patcher\");\nvar types = tslib_1.__importStar(require(\"ast-types\"));\nvar namedTypes = types.namedTypes;\nvar isString = types.builtInTypes.string;\nvar isObject = types.builtInTypes.object;\nvar fast_path_1 = tslib_1.__importDefault(require(\"./fast-path\"));\nvar util = tslib_1.__importStar(require(\"./util\"));\nvar PrintResult = function PrintResult(code, sourceMap) {\n    assert_1.default.ok(this instanceof PrintResult);\n    isString.assert(code);\n    this.code = code;\n    if (sourceMap) {\n        isObject.assert(sourceMap);\n        this.map = sourceMap;\n    }\n};\nvar PRp = PrintResult.prototype;\nvar warnedAboutToString = false;\nPRp.toString = function () {\n    if (!warnedAboutToString) {\n        console.warn(\"Deprecation warning: recast.print now returns an object with \" +\n            \"a .code property. You appear to be treating the object as a \" +\n            \"string, which might still work but is strongly discouraged.\");\n        warnedAboutToString = true;\n    }\n    return this.code;\n};\nvar emptyPrintResult = new PrintResult(\"\");\nvar Printer = function Printer(config) {\n    assert_1.default.ok(this instanceof Printer);\n    var explicitTabWidth = config && config.tabWidth;\n    config = options_1.normalize(config);\n    // It's common for client code to pass the same options into both\n    // recast.parse and recast.print, but the Printer doesn't need (and\n    // can be confused by) config.sourceFileName, so we null it out.\n    config.sourceFileName = null;\n    // Non-destructively modifies options with overrides, and returns a\n    // new print function that uses the modified options.\n    function makePrintFunctionWith(options, overrides) {\n        options = Object.assign({}, options, overrides);\n        return function (path) { return print(path, options); };\n    }\n    function print(path, options) {\n        assert_1.default.ok(path instanceof fast_path_1.default);\n        options = options || {};\n        if (options.includeComments) {\n            return comments_1.printComments(path, makePrintFunctionWith(options, {\n                includeComments: false,\n            }));\n        }\n        var oldTabWidth = config.tabWidth;\n        if (!explicitTabWidth) {\n            var loc = path.getNode().loc;\n            if (loc && loc.lines && loc.lines.guessTabWidth) {\n                config.tabWidth = loc.lines.guessTabWidth();\n            }\n        }\n        var reprinter = patcher_1.getReprinter(path);\n        var lines = reprinter\n            ? // Since the print function that we pass to the reprinter will\n                // be used to print \"new\" nodes, it's tempting to think we\n                // should pass printRootGenerically instead of print, to avoid\n                // calling maybeReprint again, but that would be a mistake\n                // because the new nodes might not be entirely new, but merely\n                // moved from elsewhere in the AST. The print function is the\n                // right choice because it gives us the opportunity to reprint\n                // such nodes using their original source.\n                reprinter(print)\n            : genericPrint(path, config, options, makePrintFunctionWith(options, {\n                includeComments: true,\n                avoidRootParens: false,\n            }));\n        config.tabWidth = oldTabWidth;\n        return lines;\n    }\n    this.print = function (ast) {\n        if (!ast) {\n            return emptyPrintResult;\n        }\n        var lines = print(fast_path_1.default.from(ast), {\n            includeComments: true,\n            avoidRootParens: false,\n        });\n        return new PrintResult(lines.toString(config), util.composeSourceMaps(config.inputSourceMap, lines.getSourceMap(config.sourceMapName, config.sourceRoot)));\n    };\n    this.printGenerically = function (ast) {\n        if (!ast) {\n            return emptyPrintResult;\n        }\n        // Print the entire AST generically.\n        function printGenerically(path) {\n            return comments_1.printComments(path, function (path) {\n                return genericPrint(path, config, {\n                    includeComments: true,\n                    avoidRootParens: false,\n                }, printGenerically);\n            });\n        }\n        var path = fast_path_1.default.from(ast);\n        var oldReuseWhitespace = config.reuseWhitespace;\n        // Do not reuse whitespace (or anything else, for that matter)\n        // when printing generically.\n        config.reuseWhitespace = false;\n        // TODO Allow printing of comments?\n        var pr = new PrintResult(printGenerically(path).toString(config));\n        config.reuseWhitespace = oldReuseWhitespace;\n        return pr;\n    };\n};\nexports.Printer = Printer;\nfunction genericPrint(path, config, options, printPath) {\n    assert_1.default.ok(path instanceof fast_path_1.default);\n    var node = path.getValue();\n    var parts = [];\n    var linesWithoutParens = genericPrintNoParens(path, config, printPath);\n    if (!node || linesWithoutParens.isEmpty()) {\n        return linesWithoutParens;\n    }\n    var shouldAddParens = node.extra ? node.extra.parenthesized : false;\n    var decoratorsLines = printDecorators(path, printPath);\n    if (decoratorsLines.isEmpty()) {\n        // Nodes with decorators can't have parentheses, so we can avoid\n        // computing path.needsParens() except in this case.\n        if (!options.avoidRootParens) {\n            shouldAddParens = shouldAddParens || path.needsParens();\n        }\n    }\n    else {\n        parts.push(decoratorsLines);\n    }\n    if (shouldAddParens) {\n        parts.unshift(\"(\");\n    }\n    parts.push(linesWithoutParens);\n    if (shouldAddParens) {\n        parts.push(\")\");\n    }\n    return lines_1.concat(parts);\n}\n// Note that the `options` parameter of this function is what other\n// functions in this file call the `config` object (that is, the\n// configuration object originally passed into the Printer constructor).\n// Its properties are documented in lib/options.js.\nfunction genericPrintNoParens(path, options, print) {\n    var n = path.getValue();\n    if (!n) {\n        return lines_1.fromString(\"\");\n    }\n    if (typeof n === \"string\") {\n        return lines_1.fromString(n, options);\n    }\n    namedTypes.Printable.assert(n);\n    var parts = [];\n    switch (n.type) {\n        case \"File\":\n            return path.call(print, \"program\");\n        case \"Program\":\n            // Babel 6\n            if (n.directives) {\n                path.each(function (childPath) {\n                    parts.push(print(childPath), \";\\n\");\n                }, \"directives\");\n            }\n            if (n.interpreter) {\n                parts.push(path.call(print, \"interpreter\"));\n            }\n            parts.push(path.call(function (bodyPath) { return printStatementSequence(bodyPath, options, print); }, \"body\"));\n            return lines_1.concat(parts);\n        case \"Noop\": // Babel extension.\n        case \"EmptyStatement\":\n            return lines_1.fromString(\"\");\n        case \"ExpressionStatement\":\n            return lines_1.concat([path.call(print, \"expression\"), \";\"]);\n        case \"ParenthesizedExpression\": // Babel extension.\n            return lines_1.concat([\"(\", path.call(print, \"expression\"), \")\"]);\n        case \"BinaryExpression\":\n        case \"LogicalExpression\":\n        case \"AssignmentExpression\":\n            return lines_1.fromString(\" \").join([\n                path.call(print, \"left\"),\n                n.operator,\n                path.call(print, \"right\"),\n            ]);\n        case \"AssignmentPattern\":\n            return lines_1.concat([\n                path.call(print, \"left\"),\n                \" = \",\n                path.call(print, \"right\"),\n            ]);\n        case \"MemberExpression\":\n        case \"OptionalMemberExpression\": {\n            parts.push(path.call(print, \"object\"));\n            var property = path.call(print, \"property\");\n            // Like n.optional, except with defaults applied, so optional\n            // defaults to true for OptionalMemberExpression nodes.\n            var optional = types.getFieldValue(n, \"optional\");\n            if (n.computed) {\n                parts.push(optional ? \"?.[\" : \"[\", property, \"]\");\n            }\n            else {\n                parts.push(optional ? \"?.\" : \".\", property);\n            }\n            return lines_1.concat(parts);\n        }\n        case \"ChainExpression\":\n            return path.call(print, \"expression\");\n        case \"MetaProperty\":\n            return lines_1.concat([\n                path.call(print, \"meta\"),\n                \".\",\n                path.call(print, \"property\"),\n            ]);\n        case \"BindExpression\":\n            if (n.object) {\n                parts.push(path.call(print, \"object\"));\n            }\n            parts.push(\"::\", path.call(print, \"callee\"));\n            return lines_1.concat(parts);\n        case \"Path\":\n            return lines_1.fromString(\".\").join(n.body);\n        case \"Identifier\":\n            return lines_1.concat([\n                lines_1.fromString(n.name, options),\n                n.optional ? \"?\" : \"\",\n                path.call(print, \"typeAnnotation\"),\n            ]);\n        case \"SpreadElement\":\n        case \"SpreadElementPattern\":\n        case \"RestProperty\": // Babel 6 for ObjectPattern\n        case \"SpreadProperty\":\n        case \"SpreadPropertyPattern\":\n        case \"ObjectTypeSpreadProperty\":\n        case \"RestElement\":\n            return lines_1.concat([\n                \"...\",\n                path.call(print, \"argument\"),\n                path.call(print, \"typeAnnotation\"),\n            ]);\n        case \"FunctionDeclaration\":\n        case \"FunctionExpression\":\n        case \"TSDeclareFunction\":\n            if (n.declare) {\n                parts.push(\"declare \");\n            }\n            if (n.async) {\n                parts.push(\"async \");\n            }\n            parts.push(\"function\");\n            if (n.generator)\n                parts.push(\"*\");\n            if (n.id) {\n                parts.push(\" \", path.call(print, \"id\"), path.call(print, \"typeParameters\"));\n            }\n            else {\n                if (n.typeParameters) {\n                    parts.push(path.call(print, \"typeParameters\"));\n                }\n            }\n            parts.push(\"(\", printFunctionParams(path, options, print), \")\", path.call(print, \"returnType\"));\n            if (n.body) {\n                parts.push(\" \", path.call(print, \"body\"));\n            }\n            return lines_1.concat(parts);\n        case \"ArrowFunctionExpression\":\n            if (n.async) {\n                parts.push(\"async \");\n            }\n            if (n.typeParameters) {\n                parts.push(path.call(print, \"typeParameters\"));\n            }\n            if (!options.arrowParensAlways &&\n                n.params.length === 1 &&\n                !n.rest &&\n                n.params[0].type === \"Identifier\" &&\n                !n.params[0].typeAnnotation &&\n                !n.returnType) {\n                parts.push(path.call(print, \"params\", 0));\n            }\n            else {\n                parts.push(\"(\", printFunctionParams(path, options, print), \")\", path.call(print, \"returnType\"));\n            }\n            parts.push(\" => \", path.call(print, \"body\"));\n            return lines_1.concat(parts);\n        case \"MethodDefinition\":\n            return printMethod(path, options, print);\n        case \"YieldExpression\":\n            parts.push(\"yield\");\n            if (n.delegate)\n                parts.push(\"*\");\n            if (n.argument)\n                parts.push(\" \", path.call(print, \"argument\"));\n            return lines_1.concat(parts);\n        case \"AwaitExpression\":\n            parts.push(\"await\");\n            if (n.all)\n                parts.push(\"*\");\n            if (n.argument)\n                parts.push(\" \", path.call(print, \"argument\"));\n            return lines_1.concat(parts);\n        case \"ModuleDeclaration\":\n            parts.push(\"module\", path.call(print, \"id\"));\n            if (n.source) {\n                assert_1.default.ok(!n.body);\n                parts.push(\"from\", path.call(print, \"source\"));\n            }\n            else {\n                parts.push(path.call(print, \"body\"));\n            }\n            return lines_1.fromString(\" \").join(parts);\n        case \"ImportSpecifier\":\n            if (n.importKind && n.importKind !== \"value\") {\n                parts.push(n.importKind + \" \");\n            }\n            if (n.imported) {\n                parts.push(path.call(print, \"imported\"));\n                if (n.local && n.local.name !== n.imported.name) {\n                    parts.push(\" as \", path.call(print, \"local\"));\n                }\n            }\n            else if (n.id) {\n                parts.push(path.call(print, \"id\"));\n                if (n.name) {\n                    parts.push(\" as \", path.call(print, \"name\"));\n                }\n            }\n            return lines_1.concat(parts);\n        case \"ExportSpecifier\":\n            if (n.local) {\n                parts.push(path.call(print, \"local\"));\n                if (n.exported && n.exported.name !== n.local.name) {\n                    parts.push(\" as \", path.call(print, \"exported\"));\n                }\n            }\n            else if (n.id) {\n                parts.push(path.call(print, \"id\"));\n                if (n.name) {\n                    parts.push(\" as \", path.call(print, \"name\"));\n                }\n            }\n            return lines_1.concat(parts);\n        case \"ExportBatchSpecifier\":\n            return lines_1.fromString(\"*\");\n        case \"ImportNamespaceSpecifier\":\n            parts.push(\"* as \");\n            if (n.local) {\n                parts.push(path.call(print, \"local\"));\n            }\n            else if (n.id) {\n                parts.push(path.call(print, \"id\"));\n            }\n            return lines_1.concat(parts);\n        case \"ImportDefaultSpecifier\":\n            if (n.local) {\n                return path.call(print, \"local\");\n            }\n            return path.call(print, \"id\");\n        case \"TSExportAssignment\":\n            return lines_1.concat([\"export = \", path.call(print, \"expression\")]);\n        case \"ExportDeclaration\":\n        case \"ExportDefaultDeclaration\":\n        case \"ExportNamedDeclaration\":\n            return printExportDeclaration(path, options, print);\n        case \"ExportAllDeclaration\":\n            parts.push(\"export *\");\n            if (n.exported) {\n                parts.push(\" as \", path.call(print, \"exported\"));\n            }\n            parts.push(\" from \", path.call(print, \"source\"), \";\");\n            return lines_1.concat(parts);\n        case \"TSNamespaceExportDeclaration\":\n            parts.push(\"export as namespace \", path.call(print, \"id\"));\n            return maybeAddSemicolon(lines_1.concat(parts));\n        case \"ExportNamespaceSpecifier\":\n            return lines_1.concat([\"* as \", path.call(print, \"exported\")]);\n        case \"ExportDefaultSpecifier\":\n            return path.call(print, \"exported\");\n        case \"Import\":\n            return lines_1.fromString(\"import\", options);\n        // Recast and ast-types currently support dynamic import(...) using\n        // either this dedicated ImportExpression type or a CallExpression\n        // whose callee has type Import.\n        // https://github.com/benjamn/ast-types/pull/365#issuecomment-605214486\n        case \"ImportExpression\":\n            return lines_1.concat([\"import(\", path.call(print, \"source\"), \")\"]);\n        case \"ImportDeclaration\": {\n            parts.push(\"import \");\n            if (n.importKind && n.importKind !== \"value\") {\n                parts.push(n.importKind + \" \");\n            }\n            if (n.specifiers && n.specifiers.length > 0) {\n                var unbracedSpecifiers_1 = [];\n                var bracedSpecifiers_1 = [];\n                path.each(function (specifierPath) {\n                    var spec = specifierPath.getValue();\n                    if (spec.type === \"ImportSpecifier\") {\n                        bracedSpecifiers_1.push(print(specifierPath));\n                    }\n                    else if (spec.type === \"ImportDefaultSpecifier\" ||\n                        spec.type === \"ImportNamespaceSpecifier\") {\n                        unbracedSpecifiers_1.push(print(specifierPath));\n                    }\n                }, \"specifiers\");\n                unbracedSpecifiers_1.forEach(function (lines, i) {\n                    if (i > 0) {\n                        parts.push(\", \");\n                    }\n                    parts.push(lines);\n                });\n                if (bracedSpecifiers_1.length > 0) {\n                    var lines = lines_1.fromString(\", \").join(bracedSpecifiers_1);\n                    if (lines.getLineLength(1) > options.wrapColumn) {\n                        lines = lines_1.concat([\n                            lines_1.fromString(\",\\n\").join(bracedSpecifiers_1).indent(options.tabWidth),\n                            \",\",\n                        ]);\n                    }\n                    if (unbracedSpecifiers_1.length > 0) {\n                        parts.push(\", \");\n                    }\n                    if (lines.length > 1) {\n                        parts.push(\"{\\n\", lines, \"\\n}\");\n                    }\n                    else if (options.objectCurlySpacing) {\n                        parts.push(\"{ \", lines, \" }\");\n                    }\n                    else {\n                        parts.push(\"{\", lines, \"}\");\n                    }\n                }\n                parts.push(\" from \");\n            }\n            parts.push(path.call(print, \"source\"), \";\");\n            return lines_1.concat(parts);\n        }\n        case \"BlockStatement\": {\n            var naked_1 = path.call(function (bodyPath) { return printStatementSequence(bodyPath, options, print); }, \"body\");\n            if (naked_1.isEmpty()) {\n                if (!n.directives || n.directives.length === 0) {\n                    return lines_1.fromString(\"{}\");\n                }\n            }\n            parts.push(\"{\\n\");\n            // Babel 6\n            if (n.directives) {\n                path.each(function (childPath) {\n                    parts.push(maybeAddSemicolon(print(childPath).indent(options.tabWidth)), n.directives.length > 1 || !naked_1.isEmpty() ? \"\\n\" : \"\");\n                }, \"directives\");\n            }\n            parts.push(naked_1.indent(options.tabWidth));\n            parts.push(\"\\n}\");\n            return lines_1.concat(parts);\n        }\n        case \"ReturnStatement\": {\n            parts.push(\"return\");\n            if (n.argument) {\n                var argLines = path.call(print, \"argument\");\n                if (argLines.startsWithComment() ||\n                    (argLines.length > 1 &&\n                        namedTypes.JSXElement &&\n                        namedTypes.JSXElement.check(n.argument))) {\n                    parts.push(\" (\\n\", argLines.indent(options.tabWidth), \"\\n)\");\n                }\n                else {\n                    parts.push(\" \", argLines);\n                }\n            }\n            parts.push(\";\");\n            return lines_1.concat(parts);\n        }\n        case \"CallExpression\":\n        case \"OptionalCallExpression\":\n            parts.push(path.call(print, \"callee\"));\n            if (n.typeParameters) {\n                parts.push(path.call(print, \"typeParameters\"));\n            }\n            if (n.typeArguments) {\n                parts.push(path.call(print, \"typeArguments\"));\n            }\n            // Like n.optional, but defaults to true for OptionalCallExpression\n            // nodes that are missing an n.optional property (unusual),\n            // according to the OptionalCallExpression definition in ast-types.\n            if (types.getFieldValue(n, \"optional\")) {\n                parts.push(\"?.\");\n            }\n            parts.push(printArgumentsList(path, options, print));\n            return lines_1.concat(parts);\n        case \"ObjectExpression\":\n        case \"ObjectPattern\":\n        case \"ObjectTypeAnnotation\": {\n            var isTypeAnnotation_1 = n.type === \"ObjectTypeAnnotation\";\n            var separator_1 = options.flowObjectCommas\n                ? \",\"\n                : isTypeAnnotation_1\n                    ? \";\"\n                    : \",\";\n            var fields = [];\n            var allowBreak_1 = false;\n            if (isTypeAnnotation_1) {\n                fields.push(\"indexers\", \"callProperties\");\n                if (n.internalSlots != null) {\n                    fields.push(\"internalSlots\");\n                }\n            }\n            fields.push(\"properties\");\n            var len_1 = 0;\n            fields.forEach(function (field) {\n                len_1 += n[field].length;\n            });\n            var oneLine_1 = (isTypeAnnotation_1 && len_1 === 1) || len_1 === 0;\n            var leftBrace = n.exact ? \"{|\" : \"{\";\n            var rightBrace = n.exact ? \"|}\" : \"}\";\n            parts.push(oneLine_1 ? leftBrace : leftBrace + \"\\n\");\n            var leftBraceIndex = parts.length - 1;\n            var i_1 = 0;\n            fields.forEach(function (field) {\n                path.each(function (childPath) {\n                    var lines = print(childPath);\n                    if (!oneLine_1) {\n                        lines = lines.indent(options.tabWidth);\n                    }\n                    var multiLine = !isTypeAnnotation_1 && lines.length > 1;\n                    if (multiLine && allowBreak_1) {\n                        // Similar to the logic for BlockStatement.\n                        parts.push(\"\\n\");\n                    }\n                    parts.push(lines);\n                    if (i_1 < len_1 - 1) {\n                        // Add an extra line break if the previous object property\n                        // had a multi-line value.\n                        parts.push(separator_1 + (multiLine ? \"\\n\\n\" : \"\\n\"));\n                        allowBreak_1 = !multiLine;\n                    }\n                    else if (len_1 !== 1 && isTypeAnnotation_1) {\n                        parts.push(separator_1);\n                    }\n                    else if (!oneLine_1 &&\n                        util.isTrailingCommaEnabled(options, \"objects\") &&\n                        childPath.getValue().type !== \"RestElement\") {\n                        parts.push(separator_1);\n                    }\n                    i_1++;\n                }, field);\n            });\n            if (n.inexact) {\n                var line = lines_1.fromString(\"...\", options);\n                if (oneLine_1) {\n                    if (len_1 > 0) {\n                        parts.push(separator_1, \" \");\n                    }\n                    parts.push(line);\n                }\n                else {\n                    // No trailing separator after ... to maintain parity with prettier.\n                    parts.push(\"\\n\", line.indent(options.tabWidth));\n                }\n            }\n            parts.push(oneLine_1 ? rightBrace : \"\\n\" + rightBrace);\n            if (i_1 !== 0 && oneLine_1 && options.objectCurlySpacing) {\n                parts[leftBraceIndex] = leftBrace + \" \";\n                parts[parts.length - 1] = \" \" + rightBrace;\n            }\n            if (n.typeAnnotation) {\n                parts.push(path.call(print, \"typeAnnotation\"));\n            }\n            return lines_1.concat(parts);\n        }\n        case \"PropertyPattern\":\n            return lines_1.concat([\n                path.call(print, \"key\"),\n                \": \",\n                path.call(print, \"pattern\"),\n            ]);\n        case \"ObjectProperty\": // Babel 6\n        case \"Property\": {\n            // Non-standard AST node type.\n            if (n.method || n.kind === \"get\" || n.kind === \"set\") {\n                return printMethod(path, options, print);\n            }\n            if (n.shorthand && n.value.type === \"AssignmentPattern\") {\n                return path.call(print, \"value\");\n            }\n            var key = path.call(print, \"key\");\n            if (n.computed) {\n                parts.push(\"[\", key, \"]\");\n            }\n            else {\n                parts.push(key);\n            }\n            if (!n.shorthand || n.key.name !== n.value.name) {\n                parts.push(\": \", path.call(print, \"value\"));\n            }\n            return lines_1.concat(parts);\n        }\n        case \"ClassMethod\": // Babel 6\n        case \"ObjectMethod\": // Babel 6\n        case \"ClassPrivateMethod\":\n        case \"TSDeclareMethod\":\n            return printMethod(path, options, print);\n        case \"PrivateName\":\n            return lines_1.concat([\"#\", path.call(print, \"id\")]);\n        case \"Decorator\":\n            return lines_1.concat([\"@\", path.call(print, \"expression\")]);\n        case \"ArrayExpression\":\n        case \"ArrayPattern\": {\n            var elems = n.elements;\n            var len_2 = elems.length;\n            var printed_1 = path.map(print, \"elements\");\n            var joined = lines_1.fromString(\", \").join(printed_1);\n            var oneLine_2 = joined.getLineLength(1) <= options.wrapColumn;\n            if (oneLine_2) {\n                if (options.arrayBracketSpacing) {\n                    parts.push(\"[ \");\n                }\n                else {\n                    parts.push(\"[\");\n                }\n            }\n            else {\n                parts.push(\"[\\n\");\n            }\n            path.each(function (elemPath) {\n                var i = elemPath.getName();\n                var elem = elemPath.getValue();\n                if (!elem) {\n                    // If the array expression ends with a hole, that hole\n                    // will be ignored by the interpreter, but if it ends with\n                    // two (or more) holes, we need to write out two (or more)\n                    // commas so that the resulting code is interpreted with\n                    // both (all) of the holes.\n                    parts.push(\",\");\n                }\n                else {\n                    var lines = printed_1[i];\n                    if (oneLine_2) {\n                        if (i > 0)\n                            parts.push(\" \");\n                    }\n                    else {\n                        lines = lines.indent(options.tabWidth);\n                    }\n                    parts.push(lines);\n                    if (i < len_2 - 1 ||\n                        (!oneLine_2 && util.isTrailingCommaEnabled(options, \"arrays\")))\n                        parts.push(\",\");\n                    if (!oneLine_2)\n                        parts.push(\"\\n\");\n                }\n            }, \"elements\");\n            if (oneLine_2 && options.arrayBracketSpacing) {\n                parts.push(\" ]\");\n            }\n            else {\n                parts.push(\"]\");\n            }\n            if (n.typeAnnotation) {\n                parts.push(path.call(print, \"typeAnnotation\"));\n            }\n            return lines_1.concat(parts);\n        }\n        case \"SequenceExpression\":\n            return lines_1.fromString(\", \").join(path.map(print, \"expressions\"));\n        case \"ThisExpression\":\n            return lines_1.fromString(\"this\");\n        case \"Super\":\n            return lines_1.fromString(\"super\");\n        case \"NullLiteral\": // Babel 6 Literal split\n            return lines_1.fromString(\"null\");\n        case \"RegExpLiteral\": // Babel 6 Literal split\n            return lines_1.fromString(n.extra.raw);\n        case \"BigIntLiteral\": // Babel 7 Literal split\n            return lines_1.fromString(n.value + \"n\");\n        case \"NumericLiteral\": // Babel 6 Literal Split\n            // Keep original representation for numeric values not in base 10.\n            if (n.extra &&\n                typeof n.extra.raw === \"string\" &&\n                Number(n.extra.raw) === n.value) {\n                return lines_1.fromString(n.extra.raw, options);\n            }\n            return lines_1.fromString(n.value, options);\n        case \"BooleanLiteral\": // Babel 6 Literal split\n        case \"StringLiteral\": // Babel 6 Literal split\n        case \"Literal\":\n            // Numeric values may be in bases other than 10. Use their raw\n            // representation if equivalent.\n            if (typeof n.value === \"number\" &&\n                typeof n.raw === \"string\" &&\n                Number(n.raw) === n.value) {\n                return lines_1.fromString(n.raw, options);\n            }\n            if (typeof n.value !== \"string\") {\n                return lines_1.fromString(n.value, options);\n            }\n            return lines_1.fromString(nodeStr(n.value, options), options);\n        case \"Directive\": // Babel 6\n            return path.call(print, \"value\");\n        case \"DirectiveLiteral\": // Babel 6\n            return lines_1.fromString(nodeStr(n.value, options));\n        case \"InterpreterDirective\":\n            return lines_1.fromString(\"#!\" + n.value + \"\\n\", options);\n        case \"ModuleSpecifier\":\n            if (n.local) {\n                throw new Error(\"The ESTree ModuleSpecifier type should be abstract\");\n            }\n            // The Esprima ModuleSpecifier type is just a string-valued\n            // Literal identifying the imported-from module.\n            return lines_1.fromString(nodeStr(n.value, options), options);\n        case \"UnaryExpression\":\n            parts.push(n.operator);\n            if (/[a-z]$/.test(n.operator))\n                parts.push(\" \");\n            parts.push(path.call(print, \"argument\"));\n            return lines_1.concat(parts);\n        case \"UpdateExpression\":\n            parts.push(path.call(print, \"argument\"), n.operator);\n            if (n.prefix)\n                parts.reverse();\n            return lines_1.concat(parts);\n        case \"ConditionalExpression\":\n            return lines_1.concat([\n                path.call(print, \"test\"),\n                \" ? \",\n                path.call(print, \"consequent\"),\n                \" : \",\n                path.call(print, \"alternate\"),\n            ]);\n        case \"NewExpression\": {\n            parts.push(\"new \", path.call(print, \"callee\"));\n            if (n.typeParameters) {\n                parts.push(path.call(print, \"typeParameters\"));\n            }\n            if (n.typeArguments) {\n                parts.push(path.call(print, \"typeArguments\"));\n            }\n            var args = n.arguments;\n            if (args) {\n                parts.push(printArgumentsList(path, options, print));\n            }\n            return lines_1.concat(parts);\n        }\n        case \"VariableDeclaration\": {\n            if (n.declare) {\n                parts.push(\"declare \");\n            }\n            parts.push(n.kind, \" \");\n            var maxLen_1 = 0;\n            var printed = path.map(function (childPath) {\n                var lines = print(childPath);\n                maxLen_1 = Math.max(lines.length, maxLen_1);\n                return lines;\n            }, \"declarations\");\n            if (maxLen_1 === 1) {\n                parts.push(lines_1.fromString(\", \").join(printed));\n            }\n            else if (printed.length > 1) {\n                parts.push(lines_1.fromString(\",\\n\")\n                    .join(printed)\n                    .indentTail(n.kind.length + 1));\n            }\n            else {\n                parts.push(printed[0]);\n            }\n            // We generally want to terminate all variable declarations with a\n            // semicolon, except when they are children of for loops.\n            var parentNode = path.getParentNode();\n            if (!namedTypes.ForStatement.check(parentNode) &&\n                !namedTypes.ForInStatement.check(parentNode) &&\n                !(namedTypes.ForOfStatement &&\n                    namedTypes.ForOfStatement.check(parentNode)) &&\n                !(namedTypes.ForAwaitStatement &&\n                    namedTypes.ForAwaitStatement.check(parentNode))) {\n                parts.push(\";\");\n            }\n            return lines_1.concat(parts);\n        }\n        case \"VariableDeclarator\":\n            return n.init\n                ? lines_1.fromString(\" = \").join([\n                    path.call(print, \"id\"),\n                    path.call(print, \"init\"),\n                ])\n                : path.call(print, \"id\");\n        case \"WithStatement\":\n            return lines_1.concat([\n                \"with (\",\n                path.call(print, \"object\"),\n                \") \",\n                path.call(print, \"body\"),\n            ]);\n        case \"IfStatement\": {\n            var con = adjustClause(path.call(print, \"consequent\"), options);\n            parts.push(\"if (\", path.call(print, \"test\"), \")\", con);\n            if (n.alternate)\n                parts.push(endsWithBrace(con) ? \" else\" : \"\\nelse\", adjustClause(path.call(print, \"alternate\"), options));\n            return lines_1.concat(parts);\n        }\n        case \"ForStatement\": {\n            // TODO Get the for (;;) case right.\n            var init = path.call(print, \"init\");\n            var sep = init.length > 1 ? \";\\n\" : \"; \";\n            var forParen = \"for (\";\n            var indented = lines_1.fromString(sep)\n                .join([init, path.call(print, \"test\"), path.call(print, \"update\")])\n                .indentTail(forParen.length);\n            var head = lines_1.concat([forParen, indented, \")\"]);\n            var clause = adjustClause(path.call(print, \"body\"), options);\n            parts.push(head);\n            if (head.length > 1) {\n                parts.push(\"\\n\");\n                clause = clause.trimLeft();\n            }\n            parts.push(clause);\n            return lines_1.concat(parts);\n        }\n        case \"WhileStatement\":\n            return lines_1.concat([\n                \"while (\",\n                path.call(print, \"test\"),\n                \")\",\n                adjustClause(path.call(print, \"body\"), options),\n            ]);\n        case \"ForInStatement\":\n            // Note: esprima can't actually parse \"for each (\".\n            return lines_1.concat([\n                n.each ? \"for each (\" : \"for (\",\n                path.call(print, \"left\"),\n                \" in \",\n                path.call(print, \"right\"),\n                \")\",\n                adjustClause(path.call(print, \"body\"), options),\n            ]);\n        case \"ForOfStatement\":\n        case \"ForAwaitStatement\":\n            parts.push(\"for \");\n            if (n.await || n.type === \"ForAwaitStatement\") {\n                parts.push(\"await \");\n            }\n            parts.push(\"(\", path.call(print, \"left\"), \" of \", path.call(print, \"right\"), \")\", adjustClause(path.call(print, \"body\"), options));\n            return lines_1.concat(parts);\n        case \"DoWhileStatement\": {\n            var doBody = lines_1.concat([\n                \"do\",\n                adjustClause(path.call(print, \"body\"), options),\n            ]);\n            parts.push(doBody);\n            if (endsWithBrace(doBody))\n                parts.push(\" while\");\n            else\n                parts.push(\"\\nwhile\");\n            parts.push(\" (\", path.call(print, \"test\"), \");\");\n            return lines_1.concat(parts);\n        }\n        case \"DoExpression\": {\n            var statements = path.call(function (bodyPath) { return printStatementSequence(bodyPath, options, print); }, \"body\");\n            return lines_1.concat([\"do {\\n\", statements.indent(options.tabWidth), \"\\n}\"]);\n        }\n        case \"BreakStatement\":\n            parts.push(\"break\");\n            if (n.label)\n                parts.push(\" \", path.call(print, \"label\"));\n            parts.push(\";\");\n            return lines_1.concat(parts);\n        case \"ContinueStatement\":\n            parts.push(\"continue\");\n            if (n.label)\n                parts.push(\" \", path.call(print, \"label\"));\n            parts.push(\";\");\n            return lines_1.concat(parts);\n        case \"LabeledStatement\":\n            return lines_1.concat([\n                path.call(print, \"label\"),\n                \":\\n\",\n                path.call(print, \"body\"),\n            ]);\n        case \"TryStatement\":\n            parts.push(\"try \", path.call(print, \"block\"));\n            if (n.handler) {\n                parts.push(\" \", path.call(print, \"handler\"));\n            }\n            else if (n.handlers) {\n                path.each(function (handlerPath) {\n                    parts.push(\" \", print(handlerPath));\n                }, \"handlers\");\n            }\n            if (n.finalizer) {\n                parts.push(\" finally \", path.call(print, \"finalizer\"));\n            }\n            return lines_1.concat(parts);\n        case \"CatchClause\":\n            parts.push(\"catch \");\n            if (n.param) {\n                parts.push(\"(\", path.call(print, \"param\"));\n            }\n            if (n.guard) {\n                // Note: esprima does not recognize conditional catch clauses.\n                parts.push(\" if \", path.call(print, \"guard\"));\n            }\n            if (n.param) {\n                parts.push(\") \");\n            }\n            parts.push(path.call(print, \"body\"));\n            return lines_1.concat(parts);\n        case \"ThrowStatement\":\n            return lines_1.concat([\"throw \", path.call(print, \"argument\"), \";\"]);\n        case \"SwitchStatement\":\n            return lines_1.concat([\n                \"switch (\",\n                path.call(print, \"discriminant\"),\n                \") {\\n\",\n                lines_1.fromString(\"\\n\").join(path.map(print, \"cases\")),\n                \"\\n}\",\n            ]);\n        // Note: ignoring n.lexical because it has no printing consequences.\n        case \"SwitchCase\":\n            if (n.test)\n                parts.push(\"case \", path.call(print, \"test\"), \":\");\n            else\n                parts.push(\"default:\");\n            if (n.consequent.length > 0) {\n                parts.push(\"\\n\", path\n                    .call(function (consequentPath) {\n                    return printStatementSequence(consequentPath, options, print);\n                }, \"consequent\")\n                    .indent(options.tabWidth));\n            }\n            return lines_1.concat(parts);\n        case \"DebuggerStatement\":\n            return lines_1.fromString(\"debugger;\");\n        // JSX extensions below.\n        case \"JSXAttribute\":\n            parts.push(path.call(print, \"name\"));\n            if (n.value)\n                parts.push(\"=\", path.call(print, \"value\"));\n            return lines_1.concat(parts);\n        case \"JSXIdentifier\":\n            return lines_1.fromString(n.name, options);\n        case \"JSXNamespacedName\":\n            return lines_1.fromString(\":\").join([\n                path.call(print, \"namespace\"),\n                path.call(print, \"name\"),\n            ]);\n        case \"JSXMemberExpression\":\n            return lines_1.fromString(\".\").join([\n                path.call(print, \"object\"),\n                path.call(print, \"property\"),\n            ]);\n        case \"JSXSpreadAttribute\":\n            return lines_1.concat([\"{...\", path.call(print, \"argument\"), \"}\"]);\n        case \"JSXSpreadChild\":\n            return lines_1.concat([\"{...\", path.call(print, \"expression\"), \"}\"]);\n        case \"JSXExpressionContainer\":\n            return lines_1.concat([\"{\", path.call(print, \"expression\"), \"}\"]);\n        case \"JSXElement\":\n        case \"JSXFragment\": {\n            var openingPropName = \"opening\" + (n.type === \"JSXElement\" ? \"Element\" : \"Fragment\");\n            var closingPropName = \"closing\" + (n.type === \"JSXElement\" ? \"Element\" : \"Fragment\");\n            var openingLines = path.call(print, openingPropName);\n            if (n[openingPropName].selfClosing) {\n                assert_1.default.ok(!n[closingPropName], \"unexpected \" +\n                    closingPropName +\n                    \" element in self-closing \" +\n                    n.type);\n                return openingLines;\n            }\n            var childLines = lines_1.concat(path.map(function (childPath) {\n                var child = childPath.getValue();\n                if (namedTypes.Literal.check(child) &&\n                    typeof child.value === \"string\") {\n                    if (/\\S/.test(child.value)) {\n                        return child.value.replace(/^\\s+|\\s+$/g, \"\");\n                    }\n                    else if (/\\n/.test(child.value)) {\n                        return \"\\n\";\n                    }\n                }\n                return print(childPath);\n            }, \"children\")).indentTail(options.tabWidth);\n            var closingLines = path.call(print, closingPropName);\n            return lines_1.concat([openingLines, childLines, closingLines]);\n        }\n        case \"JSXOpeningElement\": {\n            parts.push(\"<\", path.call(print, \"name\"));\n            var attrParts_1 = [];\n            path.each(function (attrPath) {\n                attrParts_1.push(\" \", print(attrPath));\n            }, \"attributes\");\n            var attrLines = lines_1.concat(attrParts_1);\n            var needLineWrap = attrLines.length > 1 || attrLines.getLineLength(1) > options.wrapColumn;\n            if (needLineWrap) {\n                attrParts_1.forEach(function (part, i) {\n                    if (part === \" \") {\n                        assert_1.default.strictEqual(i % 2, 0);\n                        attrParts_1[i] = \"\\n\";\n                    }\n                });\n                attrLines = lines_1.concat(attrParts_1).indentTail(options.tabWidth);\n            }\n            parts.push(attrLines, n.selfClosing ? \" />\" : \">\");\n            return lines_1.concat(parts);\n        }\n        case \"JSXClosingElement\":\n            return lines_1.concat([\"</\", path.call(print, \"name\"), \">\"]);\n        case \"JSXOpeningFragment\":\n            return lines_1.fromString(\"<>\");\n        case \"JSXClosingFragment\":\n            return lines_1.fromString(\"</>\");\n        case \"JSXText\":\n            return lines_1.fromString(n.value, options);\n        case \"JSXEmptyExpression\":\n            return lines_1.fromString(\"\");\n        case \"TypeAnnotatedIdentifier\":\n            return lines_1.concat([\n                path.call(print, \"annotation\"),\n                \" \",\n                path.call(print, \"identifier\"),\n            ]);\n        case \"ClassBody\":\n            if (n.body.length === 0) {\n                return lines_1.fromString(\"{}\");\n            }\n            return lines_1.concat([\n                \"{\\n\",\n                path\n                    .call(function (bodyPath) { return printStatementSequence(bodyPath, options, print); }, \"body\")\n                    .indent(options.tabWidth),\n                \"\\n}\",\n            ]);\n        case \"ClassPropertyDefinition\":\n            parts.push(\"static \", path.call(print, \"definition\"));\n            if (!namedTypes.MethodDefinition.check(n.definition))\n                parts.push(\";\");\n            return lines_1.concat(parts);\n        case \"ClassProperty\": {\n            if (n.declare) {\n                parts.push(\"declare \");\n            }\n            var access = n.accessibility || n.access;\n            if (typeof access === \"string\") {\n                parts.push(access, \" \");\n            }\n            if (n.static) {\n                parts.push(\"static \");\n            }\n            if (n.abstract) {\n                parts.push(\"abstract \");\n            }\n            if (n.readonly) {\n                parts.push(\"readonly \");\n            }\n            var key = path.call(print, \"key\");\n            if (n.computed) {\n                key = lines_1.concat([\"[\", key, \"]\"]);\n            }\n            if (n.variance) {\n                key = lines_1.concat([printVariance(path, print), key]);\n            }\n            parts.push(key);\n            if (n.optional) {\n                parts.push(\"?\");\n            }\n            if (n.typeAnnotation) {\n                parts.push(path.call(print, \"typeAnnotation\"));\n            }\n            if (n.value) {\n                parts.push(\" = \", path.call(print, \"value\"));\n            }\n            parts.push(\";\");\n            return lines_1.concat(parts);\n        }\n        case \"ClassPrivateProperty\":\n            if (n.static) {\n                parts.push(\"static \");\n            }\n            parts.push(path.call(print, \"key\"));\n            if (n.typeAnnotation) {\n                parts.push(path.call(print, \"typeAnnotation\"));\n            }\n            if (n.value) {\n                parts.push(\" = \", path.call(print, \"value\"));\n            }\n            parts.push(\";\");\n            return lines_1.concat(parts);\n        case \"ClassDeclaration\":\n        case \"ClassExpression\":\n            if (n.declare) {\n                parts.push(\"declare \");\n            }\n            if (n.abstract) {\n                parts.push(\"abstract \");\n            }\n            parts.push(\"class\");\n            if (n.id) {\n                parts.push(\" \", path.call(print, \"id\"));\n            }\n            if (n.typeParameters) {\n                parts.push(path.call(print, \"typeParameters\"));\n            }\n            if (n.superClass) {\n                parts.push(\" extends \", path.call(print, \"superClass\"), path.call(print, \"superTypeParameters\"));\n            }\n            if (n[\"implements\"] && n[\"implements\"].length > 0) {\n                parts.push(\" implements \", lines_1.fromString(\", \").join(path.map(print, \"implements\")));\n            }\n            parts.push(\" \", path.call(print, \"body\"));\n            return lines_1.concat(parts);\n        case \"TemplateElement\":\n            return lines_1.fromString(n.value.raw, options).lockIndentTail();\n        case \"TemplateLiteral\": {\n            var expressions_1 = path.map(print, \"expressions\");\n            parts.push(\"`\");\n            path.each(function (childPath) {\n                var i = childPath.getName();\n                parts.push(print(childPath));\n                if (i < expressions_1.length) {\n                    parts.push(\"${\", expressions_1[i], \"}\");\n                }\n            }, \"quasis\");\n            parts.push(\"`\");\n            return lines_1.concat(parts).lockIndentTail();\n        }\n        case \"TaggedTemplateExpression\":\n            return lines_1.concat([path.call(print, \"tag\"), path.call(print, \"quasi\")]);\n        // These types are unprintable because they serve as abstract\n        // supertypes for other (printable) types.\n        case \"Node\":\n        case \"Printable\":\n        case \"SourceLocation\":\n        case \"Position\":\n        case \"Statement\":\n        case \"Function\":\n        case \"Pattern\":\n        case \"Expression\":\n        case \"Declaration\":\n        case \"Specifier\":\n        case \"NamedSpecifier\":\n        case \"Comment\": // Supertype of Block and Line\n        case \"Flow\": // Supertype of all Flow AST node types\n        case \"FlowType\": // Supertype of all Flow types\n        case \"FlowPredicate\": // Supertype of InferredPredicate and DeclaredPredicate\n        case \"MemberTypeAnnotation\": // Flow\n        case \"Type\": // Flow\n        case \"TSHasOptionalTypeParameterInstantiation\":\n        case \"TSHasOptionalTypeParameters\":\n        case \"TSHasOptionalTypeAnnotation\":\n        case \"ChainElement\": // Supertype of MemberExpression and CallExpression\n            throw new Error(\"unprintable type: \" + JSON.stringify(n.type));\n        case \"CommentBlock\": // Babel block comment.\n        case \"Block\": // Esprima block comment.\n            return lines_1.concat([\"/*\", lines_1.fromString(n.value, options), \"*/\"]);\n        case \"CommentLine\": // Babel line comment.\n        case \"Line\": // Esprima line comment.\n            return lines_1.concat([\"//\", lines_1.fromString(n.value, options)]);\n        // Type Annotations for Facebook Flow, typically stripped out or\n        // transformed away before printing.\n        case \"TypeAnnotation\":\n            if (n.typeAnnotation) {\n                if (n.typeAnnotation.type !== \"FunctionTypeAnnotation\") {\n                    parts.push(\": \");\n                }\n                parts.push(path.call(print, \"typeAnnotation\"));\n                return lines_1.concat(parts);\n            }\n            return lines_1.fromString(\"\");\n        case \"ExistentialTypeParam\":\n        case \"ExistsTypeAnnotation\":\n            return lines_1.fromString(\"*\", options);\n        case \"EmptyTypeAnnotation\":\n            return lines_1.fromString(\"empty\", options);\n        case \"AnyTypeAnnotation\":\n            return lines_1.fromString(\"any\", options);\n        case \"MixedTypeAnnotation\":\n            return lines_1.fromString(\"mixed\", options);\n        case \"ArrayTypeAnnotation\":\n            return lines_1.concat([path.call(print, \"elementType\"), \"[]\"]);\n        case \"TupleTypeAnnotation\": {\n            var printed_2 = path.map(print, \"types\");\n            var joined = lines_1.fromString(\", \").join(printed_2);\n            var oneLine_3 = joined.getLineLength(1) <= options.wrapColumn;\n            if (oneLine_3) {\n                if (options.arrayBracketSpacing) {\n                    parts.push(\"[ \");\n                }\n                else {\n                    parts.push(\"[\");\n                }\n            }\n            else {\n                parts.push(\"[\\n\");\n            }\n            path.each(function (elemPath) {\n                var i = elemPath.getName();\n                var elem = elemPath.getValue();\n                if (!elem) {\n                    // If the array expression ends with a hole, that hole\n                    // will be ignored by the interpreter, but if it ends with\n                    // two (or more) holes, we need to write out two (or more)\n                    // commas so that the resulting code is interpreted with\n                    // both (all) of the holes.\n                    parts.push(\",\");\n                }\n                else {\n                    var lines = printed_2[i];\n                    if (oneLine_3) {\n                        if (i > 0)\n                            parts.push(\" \");\n                    }\n                    else {\n                        lines = lines.indent(options.tabWidth);\n                    }\n                    parts.push(lines);\n                    if (i < n.types.length - 1 ||\n                        (!oneLine_3 && util.isTrailingCommaEnabled(options, \"arrays\")))\n                        parts.push(\",\");\n                    if (!oneLine_3)\n                        parts.push(\"\\n\");\n                }\n            }, \"types\");\n            if (oneLine_3 && options.arrayBracketSpacing) {\n                parts.push(\" ]\");\n            }\n            else {\n                parts.push(\"]\");\n            }\n            return lines_1.concat(parts);\n        }\n        case \"BooleanTypeAnnotation\":\n            return lines_1.fromString(\"boolean\", options);\n        case \"BooleanLiteralTypeAnnotation\":\n            assert_1.default.strictEqual(typeof n.value, \"boolean\");\n            return lines_1.fromString(\"\" + n.value, options);\n        case \"InterfaceTypeAnnotation\":\n            parts.push(\"interface\");\n            if (n.extends && n.extends.length > 0) {\n                parts.push(\" extends \", lines_1.fromString(\", \").join(path.map(print, \"extends\")));\n            }\n            parts.push(\" \", path.call(print, \"body\"));\n            return lines_1.concat(parts);\n        case \"DeclareClass\":\n            return printFlowDeclaration(path, [\n                \"class \",\n                path.call(print, \"id\"),\n                \" \",\n                path.call(print, \"body\"),\n            ]);\n        case \"DeclareFunction\":\n            return printFlowDeclaration(path, [\n                \"function \",\n                path.call(print, \"id\"),\n                \";\",\n            ]);\n        case \"DeclareModule\":\n            return printFlowDeclaration(path, [\n                \"module \",\n                path.call(print, \"id\"),\n                \" \",\n                path.call(print, \"body\"),\n            ]);\n        case \"DeclareModuleExports\":\n            return printFlowDeclaration(path, [\n                \"module.exports\",\n                path.call(print, \"typeAnnotation\"),\n            ]);\n        case \"DeclareVariable\":\n            return printFlowDeclaration(path, [\"var \", path.call(print, \"id\"), \";\"]);\n        case \"DeclareExportDeclaration\":\n        case \"DeclareExportAllDeclaration\":\n            return lines_1.concat([\"declare \", printExportDeclaration(path, options, print)]);\n        case \"EnumDeclaration\":\n            return lines_1.concat([\n                \"enum \",\n                path.call(print, \"id\"),\n                path.call(print, \"body\"),\n            ]);\n        case \"EnumBooleanBody\":\n        case \"EnumNumberBody\":\n        case \"EnumStringBody\":\n        case \"EnumSymbolBody\": {\n            if (n.type === \"EnumSymbolBody\" || n.explicitType) {\n                parts.push(\" of \", \n                // EnumBooleanBody => boolean, etc.\n                n.type.slice(4, -4).toLowerCase());\n            }\n            parts.push(\" {\\n\", lines_1.fromString(\"\\n\")\n                .join(path.map(print, \"members\"))\n                .indent(options.tabWidth), \"\\n}\");\n            return lines_1.concat(parts);\n        }\n        case \"EnumDefaultedMember\":\n            return lines_1.concat([path.call(print, \"id\"), \",\"]);\n        case \"EnumBooleanMember\":\n        case \"EnumNumberMember\":\n        case \"EnumStringMember\":\n            return lines_1.concat([\n                path.call(print, \"id\"),\n                \" = \",\n                path.call(print, \"init\"),\n                \",\",\n            ]);\n        case \"InferredPredicate\":\n            return lines_1.fromString(\"%checks\", options);\n        case \"DeclaredPredicate\":\n            return lines_1.concat([\"%checks(\", path.call(print, \"value\"), \")\"]);\n        case \"FunctionTypeAnnotation\": {\n            // FunctionTypeAnnotation is ambiguous:\n            // declare function(a: B): void; OR\n            // const A: (a: B) => void;\n            var parent = path.getParentNode(0);\n            var isArrowFunctionTypeAnnotation = !(namedTypes.ObjectTypeCallProperty.check(parent) ||\n                (namedTypes.ObjectTypeInternalSlot.check(parent) && parent.method) ||\n                namedTypes.DeclareFunction.check(path.getParentNode(2)));\n            var needsColon = isArrowFunctionTypeAnnotation &&\n                !namedTypes.FunctionTypeParam.check(parent) &&\n                !namedTypes.TypeAlias.check(parent);\n            if (needsColon) {\n                parts.push(\": \");\n            }\n            var hasTypeParameters = !!n.typeParameters;\n            var needsParens = hasTypeParameters || n.params.length !== 1 || n.params[0].name;\n            parts.push(hasTypeParameters ? path.call(print, \"typeParameters\") : \"\", needsParens ? \"(\" : \"\", printFunctionParams(path, options, print), needsParens ? \")\" : \"\");\n            // The returnType is not wrapped in a TypeAnnotation, so the colon\n            // needs to be added separately.\n            if (n.returnType) {\n                parts.push(isArrowFunctionTypeAnnotation ? \" => \" : \": \", path.call(print, \"returnType\"));\n            }\n            return lines_1.concat(parts);\n        }\n        case \"FunctionTypeParam\": {\n            var name = path.call(print, \"name\");\n            parts.push(name);\n            if (n.optional) {\n                parts.push(\"?\");\n            }\n            if (name.infos[0].line) {\n                parts.push(\": \");\n            }\n            parts.push(path.call(print, \"typeAnnotation\"));\n            return lines_1.concat(parts);\n        }\n        case \"GenericTypeAnnotation\":\n            return lines_1.concat([\n                path.call(print, \"id\"),\n                path.call(print, \"typeParameters\"),\n            ]);\n        case \"DeclareInterface\":\n            parts.push(\"declare \");\n        // Fall through to InterfaceDeclaration...\n        case \"InterfaceDeclaration\":\n        case \"TSInterfaceDeclaration\":\n            if (n.declare) {\n                parts.push(\"declare \");\n            }\n            parts.push(\"interface \", path.call(print, \"id\"), path.call(print, \"typeParameters\"), \" \");\n            if (n[\"extends\"] && n[\"extends\"].length > 0) {\n                parts.push(\"extends \", lines_1.fromString(\", \").join(path.map(print, \"extends\")), \" \");\n            }\n            if (n.body) {\n                parts.push(path.call(print, \"body\"));\n            }\n            return lines_1.concat(parts);\n        case \"ClassImplements\":\n        case \"InterfaceExtends\":\n            return lines_1.concat([\n                path.call(print, \"id\"),\n                path.call(print, \"typeParameters\"),\n            ]);\n        case \"IntersectionTypeAnnotation\":\n            return lines_1.fromString(\" & \").join(path.map(print, \"types\"));\n        case \"NullableTypeAnnotation\":\n            return lines_1.concat([\"?\", path.call(print, \"typeAnnotation\")]);\n        case \"NullLiteralTypeAnnotation\":\n            return lines_1.fromString(\"null\", options);\n        case \"ThisTypeAnnotation\":\n            return lines_1.fromString(\"this\", options);\n        case \"NumberTypeAnnotation\":\n            return lines_1.fromString(\"number\", options);\n        case \"ObjectTypeCallProperty\":\n            return path.call(print, \"value\");\n        case \"ObjectTypeIndexer\":\n            if (n.static) {\n                parts.push(\"static \");\n            }\n            parts.push(printVariance(path, print), \"[\");\n            if (n.id) {\n                parts.push(path.call(print, \"id\"), \": \");\n            }\n            parts.push(path.call(print, \"key\"), \"]: \", path.call(print, \"value\"));\n            return lines_1.concat(parts);\n        case \"ObjectTypeProperty\":\n            return lines_1.concat([\n                printVariance(path, print),\n                path.call(print, \"key\"),\n                n.optional ? \"?\" : \"\",\n                \": \",\n                path.call(print, \"value\"),\n            ]);\n        case \"ObjectTypeInternalSlot\":\n            return lines_1.concat([\n                n.static ? \"static \" : \"\",\n                \"[[\",\n                path.call(print, \"id\"),\n                \"]]\",\n                n.optional ? \"?\" : \"\",\n                n.value.type !== \"FunctionTypeAnnotation\" ? \": \" : \"\",\n                path.call(print, \"value\"),\n            ]);\n        case \"QualifiedTypeIdentifier\":\n            return lines_1.concat([\n                path.call(print, \"qualification\"),\n                \".\",\n                path.call(print, \"id\"),\n            ]);\n        case \"StringLiteralTypeAnnotation\":\n            return lines_1.fromString(nodeStr(n.value, options), options);\n        case \"NumberLiteralTypeAnnotation\":\n        case \"NumericLiteralTypeAnnotation\":\n            assert_1.default.strictEqual(typeof n.value, \"number\");\n            return lines_1.fromString(JSON.stringify(n.value), options);\n        case \"BigIntLiteralTypeAnnotation\":\n            return lines_1.fromString(n.raw, options);\n        case \"StringTypeAnnotation\":\n            return lines_1.fromString(\"string\", options);\n        case \"DeclareTypeAlias\":\n            parts.push(\"declare \");\n        // Fall through to TypeAlias...\n        case \"TypeAlias\":\n            return lines_1.concat([\n                \"type \",\n                path.call(print, \"id\"),\n                path.call(print, \"typeParameters\"),\n                \" = \",\n                path.call(print, \"right\"),\n                \";\",\n            ]);\n        case \"DeclareOpaqueType\":\n            parts.push(\"declare \");\n        // Fall through to OpaqueType...\n        case \"OpaqueType\":\n            parts.push(\"opaque type \", path.call(print, \"id\"), path.call(print, \"typeParameters\"));\n            if (n[\"supertype\"]) {\n                parts.push(\": \", path.call(print, \"supertype\"));\n            }\n            if (n[\"impltype\"]) {\n                parts.push(\" = \", path.call(print, \"impltype\"));\n            }\n            parts.push(\";\");\n            return lines_1.concat(parts);\n        case \"TypeCastExpression\":\n            return lines_1.concat([\n                \"(\",\n                path.call(print, \"expression\"),\n                path.call(print, \"typeAnnotation\"),\n                \")\",\n            ]);\n        case \"TypeParameterDeclaration\":\n        case \"TypeParameterInstantiation\":\n            return lines_1.concat([\n                \"<\",\n                lines_1.fromString(\", \").join(path.map(print, \"params\")),\n                \">\",\n            ]);\n        case \"Variance\":\n            if (n.kind === \"plus\") {\n                return lines_1.fromString(\"+\");\n            }\n            if (n.kind === \"minus\") {\n                return lines_1.fromString(\"-\");\n            }\n            return lines_1.fromString(\"\");\n        case \"TypeParameter\":\n            if (n.variance) {\n                parts.push(printVariance(path, print));\n            }\n            parts.push(path.call(print, \"name\"));\n            if (n.bound) {\n                parts.push(path.call(print, \"bound\"));\n            }\n            if (n[\"default\"]) {\n                parts.push(\"=\", path.call(print, \"default\"));\n            }\n            return lines_1.concat(parts);\n        case \"TypeofTypeAnnotation\":\n            return lines_1.concat([\n                lines_1.fromString(\"typeof \", options),\n                path.call(print, \"argument\"),\n            ]);\n        case \"UnionTypeAnnotation\":\n            return lines_1.fromString(\" | \").join(path.map(print, \"types\"));\n        case \"VoidTypeAnnotation\":\n            return lines_1.fromString(\"void\", options);\n        case \"NullTypeAnnotation\":\n            return lines_1.fromString(\"null\", options);\n        case \"SymbolTypeAnnotation\":\n            return lines_1.fromString(\"symbol\", options);\n        case \"BigIntTypeAnnotation\":\n            return lines_1.fromString(\"bigint\", options);\n        // Type Annotations for TypeScript (when using Babylon as parser)\n        case \"TSType\":\n            throw new Error(\"unprintable type: \" + JSON.stringify(n.type));\n        case \"TSNumberKeyword\":\n            return lines_1.fromString(\"number\", options);\n        case \"TSBigIntKeyword\":\n            return lines_1.fromString(\"bigint\", options);\n        case \"TSObjectKeyword\":\n            return lines_1.fromString(\"object\", options);\n        case \"TSBooleanKeyword\":\n            return lines_1.fromString(\"boolean\", options);\n        case \"TSStringKeyword\":\n            return lines_1.fromString(\"string\", options);\n        case \"TSSymbolKeyword\":\n            return lines_1.fromString(\"symbol\", options);\n        case \"TSAnyKeyword\":\n            return lines_1.fromString(\"any\", options);\n        case \"TSVoidKeyword\":\n            return lines_1.fromString(\"void\", options);\n        case \"TSThisType\":\n            return lines_1.fromString(\"this\", options);\n        case \"TSNullKeyword\":\n            return lines_1.fromString(\"null\", options);\n        case \"TSUndefinedKeyword\":\n            return lines_1.fromString(\"undefined\", options);\n        case \"TSUnknownKeyword\":\n            return lines_1.fromString(\"unknown\", options);\n        case \"TSNeverKeyword\":\n            return lines_1.fromString(\"never\", options);\n        case \"TSArrayType\":\n            return lines_1.concat([path.call(print, \"elementType\"), \"[]\"]);\n        case \"TSLiteralType\":\n            return path.call(print, \"literal\");\n        case \"TSUnionType\":\n            return lines_1.fromString(\" | \").join(path.map(print, \"types\"));\n        case \"TSIntersectionType\":\n            return lines_1.fromString(\" & \").join(path.map(print, \"types\"));\n        case \"TSConditionalType\":\n            parts.push(path.call(print, \"checkType\"), \" extends \", path.call(print, \"extendsType\"), \" ? \", path.call(print, \"trueType\"), \" : \", path.call(print, \"falseType\"));\n            return lines_1.concat(parts);\n        case \"TSInferType\":\n            parts.push(\"infer \", path.call(print, \"typeParameter\"));\n            return lines_1.concat(parts);\n        case \"TSParenthesizedType\":\n            return lines_1.concat([\"(\", path.call(print, \"typeAnnotation\"), \")\"]);\n        case \"TSFunctionType\":\n            return lines_1.concat([\n                path.call(print, \"typeParameters\"),\n                \"(\",\n                printFunctionParams(path, options, print),\n                \") => \",\n                path.call(print, \"typeAnnotation\", \"typeAnnotation\"),\n            ]);\n        case \"TSConstructorType\":\n            return lines_1.concat([\n                \"new \",\n                path.call(print, \"typeParameters\"),\n                \"(\",\n                printFunctionParams(path, options, print),\n                \") => \",\n                path.call(print, \"typeAnnotation\", \"typeAnnotation\"),\n            ]);\n        case \"TSMappedType\": {\n            parts.push(n.readonly ? \"readonly \" : \"\", \"[\", path.call(print, \"typeParameter\"), \"]\", n.optional ? \"?\" : \"\");\n            if (n.typeAnnotation) {\n                parts.push(\": \", path.call(print, \"typeAnnotation\"), \";\");\n            }\n            return lines_1.concat([\"{\\n\", lines_1.concat(parts).indent(options.tabWidth), \"\\n}\"]);\n        }\n        case \"TSTupleType\":\n            return lines_1.concat([\n                \"[\",\n                lines_1.fromString(\", \").join(path.map(print, \"elementTypes\")),\n                \"]\",\n            ]);\n        case \"TSNamedTupleMember\":\n            parts.push(path.call(print, \"label\"));\n            if (n.optional) {\n                parts.push(\"?\");\n            }\n            parts.push(\": \", path.call(print, \"elementType\"));\n            return lines_1.concat(parts);\n        case \"TSRestType\":\n            return lines_1.concat([\"...\", path.call(print, \"typeAnnotation\")]);\n        case \"TSOptionalType\":\n            return lines_1.concat([path.call(print, \"typeAnnotation\"), \"?\"]);\n        case \"TSIndexedAccessType\":\n            return lines_1.concat([\n                path.call(print, \"objectType\"),\n                \"[\",\n                path.call(print, \"indexType\"),\n                \"]\",\n            ]);\n        case \"TSTypeOperator\":\n            return lines_1.concat([\n                path.call(print, \"operator\"),\n                \" \",\n                path.call(print, \"typeAnnotation\"),\n            ]);\n        case \"TSTypeLiteral\": {\n            var memberLines = lines_1.fromString(\",\\n\").join(path.map(print, \"members\"));\n            if (memberLines.isEmpty()) {\n                return lines_1.fromString(\"{}\", options);\n            }\n            parts.push(\"{\\n\", memberLines.indent(options.tabWidth), \"\\n}\");\n            return lines_1.concat(parts);\n        }\n        case \"TSEnumMember\":\n            parts.push(path.call(print, \"id\"));\n            if (n.initializer) {\n                parts.push(\" = \", path.call(print, \"initializer\"));\n            }\n            return lines_1.concat(parts);\n        case \"TSTypeQuery\":\n            return lines_1.concat([\"typeof \", path.call(print, \"exprName\")]);\n        case \"TSParameterProperty\":\n            if (n.accessibility) {\n                parts.push(n.accessibility, \" \");\n            }\n            if (n.export) {\n                parts.push(\"export \");\n            }\n            if (n.static) {\n                parts.push(\"static \");\n            }\n            if (n.readonly) {\n                parts.push(\"readonly \");\n            }\n            parts.push(path.call(print, \"parameter\"));\n            return lines_1.concat(parts);\n        case \"TSTypeReference\":\n            return lines_1.concat([\n                path.call(print, \"typeName\"),\n                path.call(print, \"typeParameters\"),\n            ]);\n        case \"TSQualifiedName\":\n            return lines_1.concat([path.call(print, \"left\"), \".\", path.call(print, \"right\")]);\n        case \"TSAsExpression\": {\n            var expression = path.call(print, \"expression\");\n            parts.push(expression, lines_1.fromString(\" as \"), path.call(print, \"typeAnnotation\"));\n            return lines_1.concat(parts);\n        }\n        case \"TSNonNullExpression\":\n            return lines_1.concat([path.call(print, \"expression\"), \"!\"]);\n        case \"TSTypeAnnotation\":\n            return lines_1.concat([\": \", path.call(print, \"typeAnnotation\")]);\n        case \"TSIndexSignature\":\n            return lines_1.concat([\n                n.readonly ? \"readonly \" : \"\",\n                \"[\",\n                path.map(print, \"parameters\"),\n                \"]\",\n                path.call(print, \"typeAnnotation\"),\n            ]);\n        case \"TSPropertySignature\":\n            parts.push(printVariance(path, print), n.readonly ? \"readonly \" : \"\");\n            if (n.computed) {\n                parts.push(\"[\", path.call(print, \"key\"), \"]\");\n            }\n            else {\n                parts.push(path.call(print, \"key\"));\n            }\n            parts.push(n.optional ? \"?\" : \"\", path.call(print, \"typeAnnotation\"));\n            return lines_1.concat(parts);\n        case \"TSMethodSignature\":\n            if (n.computed) {\n                parts.push(\"[\", path.call(print, \"key\"), \"]\");\n            }\n            else {\n                parts.push(path.call(print, \"key\"));\n            }\n            if (n.optional) {\n                parts.push(\"?\");\n            }\n            parts.push(path.call(print, \"typeParameters\"), \"(\", printFunctionParams(path, options, print), \")\", path.call(print, \"typeAnnotation\"));\n            return lines_1.concat(parts);\n        case \"TSTypePredicate\":\n            if (n.asserts) {\n                parts.push(\"asserts \");\n            }\n            parts.push(path.call(print, \"parameterName\"));\n            if (n.typeAnnotation) {\n                parts.push(\" is \", path.call(print, \"typeAnnotation\", \"typeAnnotation\"));\n            }\n            return lines_1.concat(parts);\n        case \"TSCallSignatureDeclaration\":\n            return lines_1.concat([\n                path.call(print, \"typeParameters\"),\n                \"(\",\n                printFunctionParams(path, options, print),\n                \")\",\n                path.call(print, \"typeAnnotation\"),\n            ]);\n        case \"TSConstructSignatureDeclaration\":\n            if (n.typeParameters) {\n                parts.push(\"new\", path.call(print, \"typeParameters\"));\n            }\n            else {\n                parts.push(\"new \");\n            }\n            parts.push(\"(\", printFunctionParams(path, options, print), \")\", path.call(print, \"typeAnnotation\"));\n            return lines_1.concat(parts);\n        case \"TSTypeAliasDeclaration\":\n            return lines_1.concat([\n                n.declare ? \"declare \" : \"\",\n                \"type \",\n                path.call(print, \"id\"),\n                path.call(print, \"typeParameters\"),\n                \" = \",\n                path.call(print, \"typeAnnotation\"),\n                \";\",\n            ]);\n        case \"TSTypeParameter\": {\n            parts.push(path.call(print, \"name\"));\n            // ambiguous because of TSMappedType\n            var parent = path.getParentNode(0);\n            var isInMappedType = namedTypes.TSMappedType.check(parent);\n            if (n.constraint) {\n                parts.push(isInMappedType ? \" in \" : \" extends \", path.call(print, \"constraint\"));\n            }\n            if (n[\"default\"]) {\n                parts.push(\" = \", path.call(print, \"default\"));\n            }\n            return lines_1.concat(parts);\n        }\n        case \"TSTypeAssertion\": {\n            parts.push(\"<\", path.call(print, \"typeAnnotation\"), \"> \", path.call(print, \"expression\"));\n            return lines_1.concat(parts);\n        }\n        case \"TSTypeParameterDeclaration\":\n        case \"TSTypeParameterInstantiation\":\n            return lines_1.concat([\n                \"<\",\n                lines_1.fromString(\", \").join(path.map(print, \"params\")),\n                \">\",\n            ]);\n        case \"TSEnumDeclaration\": {\n            parts.push(n.declare ? \"declare \" : \"\", n.const ? \"const \" : \"\", \"enum \", path.call(print, \"id\"));\n            var memberLines = lines_1.fromString(\",\\n\").join(path.map(print, \"members\"));\n            if (memberLines.isEmpty()) {\n                parts.push(\" {}\");\n            }\n            else {\n                parts.push(\" {\\n\", memberLines.indent(options.tabWidth), \"\\n}\");\n            }\n            return lines_1.concat(parts);\n        }\n        case \"TSExpressionWithTypeArguments\":\n            return lines_1.concat([\n                path.call(print, \"expression\"),\n                path.call(print, \"typeParameters\"),\n            ]);\n        case \"TSInterfaceBody\": {\n            var lines = lines_1.fromString(\";\\n\").join(path.map(print, \"body\"));\n            if (lines.isEmpty()) {\n                return lines_1.fromString(\"{}\", options);\n            }\n            return lines_1.concat([\"{\\n\", lines.indent(options.tabWidth), \";\", \"\\n}\"]);\n        }\n        case \"TSImportType\":\n            parts.push(\"import(\", path.call(print, \"argument\"), \")\");\n            if (n.qualifier) {\n                parts.push(\".\", path.call(print, \"qualifier\"));\n            }\n            if (n.typeParameters) {\n                parts.push(path.call(print, \"typeParameters\"));\n            }\n            return lines_1.concat(parts);\n        case \"TSImportEqualsDeclaration\":\n            if (n.isExport) {\n                parts.push(\"export \");\n            }\n            parts.push(\"import \", path.call(print, \"id\"), \" = \", path.call(print, \"moduleReference\"));\n            return maybeAddSemicolon(lines_1.concat(parts));\n        case \"TSExternalModuleReference\":\n            return lines_1.concat([\"require(\", path.call(print, \"expression\"), \")\"]);\n        case \"TSModuleDeclaration\": {\n            var parent = path.getParentNode();\n            if (parent.type === \"TSModuleDeclaration\") {\n                parts.push(\".\");\n            }\n            else {\n                if (n.declare) {\n                    parts.push(\"declare \");\n                }\n                if (!n.global) {\n                    var isExternal = n.id.type === \"StringLiteral\" ||\n                        (n.id.type === \"Literal\" && typeof n.id.value === \"string\");\n                    if (isExternal) {\n                        parts.push(\"module \");\n                    }\n                    else if (n.loc && n.loc.lines && n.id.loc) {\n                        var prefix = n.loc.lines.sliceString(n.loc.start, n.id.loc.start);\n                        // These keywords are fundamentally ambiguous in the\n                        // Babylon parser, and not reflected in the AST, so\n                        // the best we can do is to match the original code,\n                        // when possible.\n                        if (prefix.indexOf(\"module\") >= 0) {\n                            parts.push(\"module \");\n                        }\n                        else {\n                            parts.push(\"namespace \");\n                        }\n                    }\n                    else {\n                        parts.push(\"namespace \");\n                    }\n                }\n            }\n            parts.push(path.call(print, \"id\"));\n            if (n.body && n.body.type === \"TSModuleDeclaration\") {\n                parts.push(path.call(print, \"body\"));\n            }\n            else if (n.body) {\n                var bodyLines = path.call(print, \"body\");\n                if (bodyLines.isEmpty()) {\n                    parts.push(\" {}\");\n                }\n                else {\n                    parts.push(\" {\\n\", bodyLines.indent(options.tabWidth), \"\\n}\");\n                }\n            }\n            return lines_1.concat(parts);\n        }\n        case \"TSModuleBlock\":\n            return path.call(function (bodyPath) { return printStatementSequence(bodyPath, options, print); }, \"body\");\n        // Unhandled types below. If encountered, nodes of these types should\n        // be either left alone or desugared into AST types that are fully\n        // supported by the pretty-printer.\n        case \"ClassHeritage\": // TODO\n        case \"ComprehensionBlock\": // TODO\n        case \"ComprehensionExpression\": // TODO\n        case \"Glob\": // TODO\n        case \"GeneratorExpression\": // TODO\n        case \"LetStatement\": // TODO\n        case \"LetExpression\": // TODO\n        case \"GraphExpression\": // TODO\n        case \"GraphIndexExpression\": // TODO\n        case \"XMLDefaultDeclaration\":\n        case \"XMLAnyName\":\n        case \"XMLQualifiedIdentifier\":\n        case \"XMLFunctionQualifiedIdentifier\":\n        case \"XMLAttributeSelector\":\n        case \"XMLFilterExpression\":\n        case \"XML\":\n        case \"XMLElement\":\n        case \"XMLList\":\n        case \"XMLEscape\":\n        case \"XMLText\":\n        case \"XMLStartTag\":\n        case \"XMLEndTag\":\n        case \"XMLPointTag\":\n        case \"XMLName\":\n        case \"XMLAttribute\":\n        case \"XMLCdata\":\n        case \"XMLComment\":\n        case \"XMLProcessingInstruction\":\n        default:\n            debugger;\n            throw new Error(\"unknown type: \" + JSON.stringify(n.type));\n    }\n}\nfunction printDecorators(path, printPath) {\n    var parts = [];\n    var node = path.getValue();\n    if (node.decorators &&\n        node.decorators.length > 0 &&\n        // If the parent node is an export declaration, it will be\n        // responsible for printing node.decorators.\n        !util.getParentExportDeclaration(path)) {\n        path.each(function (decoratorPath) {\n            parts.push(printPath(decoratorPath), \"\\n\");\n        }, \"decorators\");\n    }\n    else if (util.isExportDeclaration(node) &&\n        node.declaration &&\n        node.declaration.decorators) {\n        // Export declarations are responsible for printing any decorators\n        // that logically apply to node.declaration.\n        path.each(function (decoratorPath) {\n            parts.push(printPath(decoratorPath), \"\\n\");\n        }, \"declaration\", \"decorators\");\n    }\n    return lines_1.concat(parts);\n}\nfunction printStatementSequence(path, options, print) {\n    var filtered = [];\n    var sawComment = false;\n    var sawStatement = false;\n    path.each(function (stmtPath) {\n        var stmt = stmtPath.getValue();\n        // Just in case the AST has been modified to contain falsy\n        // \"statements,\" it's safer simply to skip them.\n        if (!stmt) {\n            return;\n        }\n        // Skip printing EmptyStatement nodes to avoid leaving stray\n        // semicolons lying around.\n        if (stmt.type === \"EmptyStatement\" &&\n            !(stmt.comments && stmt.comments.length > 0)) {\n            return;\n        }\n        if (namedTypes.Comment.check(stmt)) {\n            // The pretty printer allows a dangling Comment node to act as\n            // a Statement when the Comment can't be attached to any other\n            // non-Comment node in the tree.\n            sawComment = true;\n        }\n        else if (namedTypes.Statement.check(stmt)) {\n            sawStatement = true;\n        }\n        else {\n            // When the pretty printer encounters a string instead of an\n            // AST node, it just prints the string. This behavior can be\n            // useful for fine-grained formatting decisions like inserting\n            // blank lines.\n            isString.assert(stmt);\n        }\n        // We can't hang onto stmtPath outside of this function, because\n        // it's just a reference to a mutable FastPath object, so we have\n        // to go ahead and print it here.\n        filtered.push({\n            node: stmt,\n            printed: print(stmtPath),\n        });\n    });\n    if (sawComment) {\n        assert_1.default.strictEqual(sawStatement, false, \"Comments may appear as statements in otherwise empty statement \" +\n            \"lists, but may not coexist with non-Comment nodes.\");\n    }\n    var prevTrailingSpace = null;\n    var len = filtered.length;\n    var parts = [];\n    filtered.forEach(function (info, i) {\n        var printed = info.printed;\n        var stmt = info.node;\n        var multiLine = printed.length > 1;\n        var notFirst = i > 0;\n        var notLast = i < len - 1;\n        var leadingSpace;\n        var trailingSpace;\n        var lines = stmt && stmt.loc && stmt.loc.lines;\n        var trueLoc = lines && options.reuseWhitespace && util.getTrueLoc(stmt, lines);\n        if (notFirst) {\n            if (trueLoc) {\n                var beforeStart = lines.skipSpaces(trueLoc.start, true);\n                var beforeStartLine = beforeStart ? beforeStart.line : 1;\n                var leadingGap = trueLoc.start.line - beforeStartLine;\n                leadingSpace = Array(leadingGap + 1).join(\"\\n\");\n            }\n            else {\n                leadingSpace = multiLine ? \"\\n\\n\" : \"\\n\";\n            }\n        }\n        else {\n            leadingSpace = \"\";\n        }\n        if (notLast) {\n            if (trueLoc) {\n                var afterEnd = lines.skipSpaces(trueLoc.end);\n                var afterEndLine = afterEnd ? afterEnd.line : lines.length;\n                var trailingGap = afterEndLine - trueLoc.end.line;\n                trailingSpace = Array(trailingGap + 1).join(\"\\n\");\n            }\n            else {\n                trailingSpace = multiLine ? \"\\n\\n\" : \"\\n\";\n            }\n        }\n        else {\n            trailingSpace = \"\";\n        }\n        parts.push(maxSpace(prevTrailingSpace, leadingSpace), printed);\n        if (notLast) {\n            prevTrailingSpace = trailingSpace;\n        }\n        else if (trailingSpace) {\n            parts.push(trailingSpace);\n        }\n    });\n    return lines_1.concat(parts);\n}\nfunction maxSpace(s1, s2) {\n    if (!s1 && !s2) {\n        return lines_1.fromString(\"\");\n    }\n    if (!s1) {\n        return lines_1.fromString(s2);\n    }\n    if (!s2) {\n        return lines_1.fromString(s1);\n    }\n    var spaceLines1 = lines_1.fromString(s1);\n    var spaceLines2 = lines_1.fromString(s2);\n    if (spaceLines2.length > spaceLines1.length) {\n        return spaceLines2;\n    }\n    return spaceLines1;\n}\nfunction printMethod(path, options, print) {\n    var node = path.getNode();\n    var kind = node.kind;\n    var parts = [];\n    var nodeValue = node.value;\n    if (!namedTypes.FunctionExpression.check(nodeValue)) {\n        nodeValue = node;\n    }\n    var access = node.accessibility || node.access;\n    if (typeof access === \"string\") {\n        parts.push(access, \" \");\n    }\n    if (node.static) {\n        parts.push(\"static \");\n    }\n    if (node.abstract) {\n        parts.push(\"abstract \");\n    }\n    if (node.readonly) {\n        parts.push(\"readonly \");\n    }\n    if (nodeValue.async) {\n        parts.push(\"async \");\n    }\n    if (nodeValue.generator) {\n        parts.push(\"*\");\n    }\n    if (kind === \"get\" || kind === \"set\") {\n        parts.push(kind, \" \");\n    }\n    var key = path.call(print, \"key\");\n    if (node.computed) {\n        key = lines_1.concat([\"[\", key, \"]\"]);\n    }\n    parts.push(key);\n    if (node.optional) {\n        parts.push(\"?\");\n    }\n    if (node === nodeValue) {\n        parts.push(path.call(print, \"typeParameters\"), \"(\", printFunctionParams(path, options, print), \")\", path.call(print, \"returnType\"));\n        if (node.body) {\n            parts.push(\" \", path.call(print, \"body\"));\n        }\n        else {\n            parts.push(\";\");\n        }\n    }\n    else {\n        parts.push(path.call(print, \"value\", \"typeParameters\"), \"(\", path.call(function (valuePath) { return printFunctionParams(valuePath, options, print); }, \"value\"), \")\", path.call(print, \"value\", \"returnType\"));\n        if (nodeValue.body) {\n            parts.push(\" \", path.call(print, \"value\", \"body\"));\n        }\n        else {\n            parts.push(\";\");\n        }\n    }\n    return lines_1.concat(parts);\n}\nfunction printArgumentsList(path, options, print) {\n    var printed = path.map(print, \"arguments\");\n    var trailingComma = util.isTrailingCommaEnabled(options, \"parameters\");\n    var joined = lines_1.fromString(\", \").join(printed);\n    if (joined.getLineLength(1) > options.wrapColumn) {\n        joined = lines_1.fromString(\",\\n\").join(printed);\n        return lines_1.concat([\n            \"(\\n\",\n            joined.indent(options.tabWidth),\n            trailingComma ? \",\\n)\" : \"\\n)\",\n        ]);\n    }\n    return lines_1.concat([\"(\", joined, \")\"]);\n}\nfunction printFunctionParams(path, options, print) {\n    var fun = path.getValue();\n    var params;\n    var printed = [];\n    if (fun.params) {\n        params = fun.params;\n        printed = path.map(print, \"params\");\n    }\n    else if (fun.parameters) {\n        params = fun.parameters;\n        printed = path.map(print, \"parameters\");\n    }\n    if (fun.defaults) {\n        path.each(function (defExprPath) {\n            var i = defExprPath.getName();\n            var p = printed[i];\n            if (p && defExprPath.getValue()) {\n                printed[i] = lines_1.concat([p, \" = \", print(defExprPath)]);\n            }\n        }, \"defaults\");\n    }\n    if (fun.rest) {\n        printed.push(lines_1.concat([\"...\", path.call(print, \"rest\")]));\n    }\n    var joined = lines_1.fromString(\", \").join(printed);\n    if (joined.length > 1 || joined.getLineLength(1) > options.wrapColumn) {\n        joined = lines_1.fromString(\",\\n\").join(printed);\n        if (util.isTrailingCommaEnabled(options, \"parameters\") &&\n            !fun.rest &&\n            params[params.length - 1].type !== \"RestElement\") {\n            joined = lines_1.concat([joined, \",\\n\"]);\n        }\n        else {\n            joined = lines_1.concat([joined, \"\\n\"]);\n        }\n        return lines_1.concat([\"\\n\", joined.indent(options.tabWidth)]);\n    }\n    return joined;\n}\nfunction printExportDeclaration(path, options, print) {\n    var decl = path.getValue();\n    var parts = [\"export \"];\n    if (decl.exportKind && decl.exportKind === \"type\") {\n        if (!decl.declaration) {\n            parts.push(\"type \");\n        }\n    }\n    var shouldPrintSpaces = options.objectCurlySpacing;\n    namedTypes.Declaration.assert(decl);\n    if (decl[\"default\"] || decl.type === \"ExportDefaultDeclaration\") {\n        parts.push(\"default \");\n    }\n    if (decl.declaration) {\n        parts.push(path.call(print, \"declaration\"));\n    }\n    else if (decl.specifiers) {\n        if (decl.specifiers.length === 1 &&\n            decl.specifiers[0].type === \"ExportBatchSpecifier\") {\n            parts.push(\"*\");\n        }\n        else if (decl.specifiers.length === 0) {\n            parts.push(\"{}\");\n        }\n        else if (decl.specifiers[0].type === \"ExportDefaultSpecifier\") {\n            var unbracedSpecifiers_2 = [];\n            var bracedSpecifiers_2 = [];\n            path.each(function (specifierPath) {\n                var spec = specifierPath.getValue();\n                if (spec.type === \"ExportDefaultSpecifier\") {\n                    unbracedSpecifiers_2.push(print(specifierPath));\n                }\n                else {\n                    bracedSpecifiers_2.push(print(specifierPath));\n                }\n            }, \"specifiers\");\n            unbracedSpecifiers_2.forEach(function (lines, i) {\n                if (i > 0) {\n                    parts.push(\", \");\n                }\n                parts.push(lines);\n            });\n            if (bracedSpecifiers_2.length > 0) {\n                var lines_2 = lines_1.fromString(\", \").join(bracedSpecifiers_2);\n                if (lines_2.getLineLength(1) > options.wrapColumn) {\n                    lines_2 = lines_1.concat([\n                        lines_1.fromString(\",\\n\").join(bracedSpecifiers_2).indent(options.tabWidth),\n                        \",\",\n                    ]);\n                }\n                if (unbracedSpecifiers_2.length > 0) {\n                    parts.push(\", \");\n                }\n                if (lines_2.length > 1) {\n                    parts.push(\"{\\n\", lines_2, \"\\n}\");\n                }\n                else if (options.objectCurlySpacing) {\n                    parts.push(\"{ \", lines_2, \" }\");\n                }\n                else {\n                    parts.push(\"{\", lines_2, \"}\");\n                }\n            }\n        }\n        else {\n            parts.push(shouldPrintSpaces ? \"{ \" : \"{\", lines_1.fromString(\", \").join(path.map(print, \"specifiers\")), shouldPrintSpaces ? \" }\" : \"}\");\n        }\n        if (decl.source) {\n            parts.push(\" from \", path.call(print, \"source\"));\n        }\n    }\n    var lines = lines_1.concat(parts);\n    if (lastNonSpaceCharacter(lines) !== \";\" &&\n        !(decl.declaration &&\n            (decl.declaration.type === \"FunctionDeclaration\" ||\n                decl.declaration.type === \"ClassDeclaration\" ||\n                decl.declaration.type === \"TSModuleDeclaration\" ||\n                decl.declaration.type === \"TSInterfaceDeclaration\" ||\n                decl.declaration.type === \"TSEnumDeclaration\"))) {\n        lines = lines_1.concat([lines, \";\"]);\n    }\n    return lines;\n}\nfunction printFlowDeclaration(path, parts) {\n    var parentExportDecl = util.getParentExportDeclaration(path);\n    if (parentExportDecl) {\n        assert_1.default.strictEqual(parentExportDecl.type, \"DeclareExportDeclaration\");\n    }\n    else {\n        // If the parent node has type DeclareExportDeclaration, then it\n        // will be responsible for printing the \"declare\" token. Otherwise\n        // it needs to be printed with this non-exported declaration node.\n        parts.unshift(\"declare \");\n    }\n    return lines_1.concat(parts);\n}\nfunction printVariance(path, print) {\n    return path.call(function (variancePath) {\n        var value = variancePath.getValue();\n        if (value) {\n            if (value === \"plus\") {\n                return lines_1.fromString(\"+\");\n            }\n            if (value === \"minus\") {\n                return lines_1.fromString(\"-\");\n            }\n            return print(variancePath);\n        }\n        return lines_1.fromString(\"\");\n    }, \"variance\");\n}\nfunction adjustClause(clause, options) {\n    if (clause.length > 1)\n        return lines_1.concat([\" \", clause]);\n    return lines_1.concat([\"\\n\", maybeAddSemicolon(clause).indent(options.tabWidth)]);\n}\nfunction lastNonSpaceCharacter(lines) {\n    var pos = lines.lastPos();\n    do {\n        var ch = lines.charAt(pos);\n        if (/\\S/.test(ch))\n            return ch;\n    } while (lines.prevPos(pos));\n}\nfunction endsWithBrace(lines) {\n    return lastNonSpaceCharacter(lines) === \"}\";\n}\nfunction swapQuotes(str) {\n    return str.replace(/['\"]/g, function (m) { return (m === '\"' ? \"'\" : '\"'); });\n}\nfunction nodeStr(str, options) {\n    isString.assert(str);\n    switch (options.quote) {\n        case \"auto\": {\n            var double = JSON.stringify(str);\n            var single = swapQuotes(JSON.stringify(swapQuotes(str)));\n            return double.length > single.length ? single : double;\n        }\n        case \"single\":\n            return swapQuotes(JSON.stringify(swapQuotes(str)));\n        case \"double\":\n        default:\n            return JSON.stringify(str);\n    }\n}\nfunction maybeAddSemicolon(lines) {\n    var eoc = lastNonSpaceCharacter(lines);\n    if (!eoc || \"\\n};\".indexOf(eoc) < 0)\n        return lines_1.concat([lines, \";\"]);\n    return lines;\n}\n"],"mappings":"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"},"metadata":{},"sourceType":"script"}