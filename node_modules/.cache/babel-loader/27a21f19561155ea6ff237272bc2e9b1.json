{"ast":null,"code":"/**\n * Copyright (c) Facebook, Inc. and its affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n */\n\n'use strict';\n\nvar _classCallCheck = require(\"C:/Users/Acer/Desktop/dev__book/dev__book/node_modules/@babel/runtime/helpers/classCallCheck.js\").default;\nvar _createClass = require(\"C:/Users/Acer/Desktop/dev__book/dev__book/node_modules/@babel/runtime/helpers/createClass.js\").default;\nvar assert = require('assert');\nvar intersection = require('./utils/intersection');\nvar recast = require('recast');\nvar union = require('./utils/union');\nvar astTypes = recast.types;\nvar types = astTypes.namedTypes;\nvar NodePath = astTypes.NodePath;\nvar Node = types.Node;\n\n/**\n * This represents a generic collection of node paths. It only has a generic\n * API to access and process the elements of the list. It doesn't know anything\n * about AST types.\n *\n * @mixes traversalMethods\n * @mixes mutationMethods\n * @mixes transformMethods\n * @mixes globalMethods\n */\nvar Collection = /*#__PURE__*/function () {\n  /**\n   * @param {Array} paths An array of AST paths\n   * @param {Collection} parent A parent collection\n   * @param {Array} types An array of types all the paths in the collection\n   *  have in common. If not passed, it will be inferred from the paths.\n   * @return {Collection}\n   */\n  function Collection(paths, parent, types) {\n    _classCallCheck(this, Collection);\n    assert.ok(Array.isArray(paths), 'Collection is passed an array');\n    assert.ok(paths.every(function (p) {\n      return p instanceof NodePath;\n    }), 'Array contains only paths');\n    this._parent = parent;\n    this.__paths = paths;\n    if (types && !Array.isArray(types)) {\n      types = _toTypeArray(types);\n    } else if (!types || Array.isArray(types) && types.length === 0) {\n      types = _inferTypes(paths);\n    }\n    this._types = types.length === 0 ? _defaultType : types;\n  }\n\n  /**\n   * Returns a new collection containing the nodes for which the callback\n   * returns true.\n   *\n   * @param {function} callback\n   * @return {Collection}\n   */\n  _createClass(Collection, [{\n    key: \"filter\",\n    value: function filter(callback) {\n      return new this.constructor(this.__paths.filter(callback), this);\n    }\n\n    /**\n     * Executes callback for each node/path in the collection.\n     *\n     * @param {function} callback\n     * @return {Collection} The collection itself\n     */\n  }, {\n    key: \"forEach\",\n    value: function forEach(callback) {\n      this.__paths.forEach(function (path, i, paths) {\n        return callback.call(path, path, i, paths);\n      });\n      return this;\n    }\n\n    /**\n     * Tests whether at-least one path passes the test implemented by the provided callback.\n     *\n     * @param {function} callback\n     * @return {boolean}\n     */\n  }, {\n    key: \"some\",\n    value: function some(callback) {\n      return this.__paths.some(function (path, i, paths) {\n        return callback.call(path, path, i, paths);\n      });\n    }\n\n    /**\n     * Tests whether all paths pass the test implemented by the provided callback.\n     *\n     * @param {function} callback\n     * @return {boolean}\n     */\n  }, {\n    key: \"every\",\n    value: function every(callback) {\n      return this.__paths.every(function (path, i, paths) {\n        return callback.call(path, path, i, paths);\n      });\n    }\n\n    /**\n     * Executes the callback for every path in the collection and returns a new\n     * collection from the return values (which must be paths).\n     *\n     * The callback can return null to indicate to exclude the element from the\n     * new collection.\n     *\n     * If an array is returned, the array will be flattened into the result\n     * collection.\n     *\n     * @param {function} callback\n     * @param {Type} type Force the new collection to be of a specific type\n     */\n  }, {\n    key: \"map\",\n    value: function map(callback, type) {\n      var paths = [];\n      this.forEach(function (path) {\n        /*jshint eqnull:true*/\n        var result = callback.apply(path, arguments);\n        if (result == null) return;\n        if (!Array.isArray(result)) {\n          result = [result];\n        }\n        for (var i = 0; i < result.length; i++) {\n          if (paths.indexOf(result[i]) === -1) {\n            paths.push(result[i]);\n          }\n        }\n      });\n      return fromPaths(paths, this, type);\n    }\n\n    /**\n     * Returns the number of elements in this collection.\n     *\n     * @return {number}\n     */\n  }, {\n    key: \"size\",\n    value: function size() {\n      return this.__paths.length;\n    }\n\n    /**\n     * Returns the number of elements in this collection.\n     *\n     * @return {number}\n     */\n  }, {\n    key: \"length\",\n    get: function get() {\n      return this.__paths.length;\n    }\n\n    /**\n     * Returns an array of AST nodes in this collection.\n     *\n     * @return {Array}\n     */\n  }, {\n    key: \"nodes\",\n    value: function nodes() {\n      return this.__paths.map(function (p) {\n        return p.value;\n      });\n    }\n  }, {\n    key: \"paths\",\n    value: function paths() {\n      return this.__paths;\n    }\n  }, {\n    key: \"getAST\",\n    value: function getAST() {\n      if (this._parent) {\n        return this._parent.getAST();\n      }\n      return this.__paths;\n    }\n  }, {\n    key: \"toSource\",\n    value: function toSource(options) {\n      if (this._parent) {\n        return this._parent.toSource(options);\n      }\n      if (this.__paths.length === 1) {\n        return recast.print(this.__paths[0], options).code;\n      } else {\n        return this.__paths.map(function (p) {\n          return recast.print(p, options).code;\n        });\n      }\n    }\n\n    /**\n     * Returns a new collection containing only the element at position index.\n     *\n     * In case of a negative index, the element is taken from the end:\n     *\n     *   .at(0)  - first element\n     *   .at(-1) - last element\n     *\n     * @param {number} index\n     * @return {Collection}\n     */\n  }, {\n    key: \"at\",\n    value: function at(index) {\n      return fromPaths(this.__paths.slice(index, index === -1 ? undefined : index + 1), this);\n    }\n\n    /**\n     * Proxies to NodePath#get of the first path.\n     *\n     * @param {string|number} ...fields\n     */\n  }, {\n    key: \"get\",\n    value: function get() {\n      var path = this.__paths[0];\n      if (!path) {\n        throw Error('You cannot call \"get\" on a collection with no paths. ' + 'Instead, check the \"length\" property first to verify at least 1 path exists.');\n      }\n      return path.get.apply(path, arguments);\n    }\n\n    /**\n     * Returns the type(s) of the collection. This is only used for unit tests,\n     * I don't think other consumers would need it.\n     *\n     * @return {Array<string>}\n     */\n  }, {\n    key: \"getTypes\",\n    value: function getTypes() {\n      return this._types;\n    }\n\n    /**\n     * Returns true if this collection has the type 'type'.\n     *\n     * @param {Type} type\n     * @return {boolean}\n     */\n  }, {\n    key: \"isOfType\",\n    value: function isOfType(type) {\n      return !!type && this._types.indexOf(type.toString()) > -1;\n    }\n  }]);\n  return Collection;\n}();\n/**\n * Given a set of paths, this infers the common types of all paths.\n * @private\n * @param {Array} paths An array of paths.\n * @return {Type} type An AST type\n */\nfunction _inferTypes(paths) {\n  var _types = [];\n  if (paths.length > 0 && Node.check(paths[0].node)) {\n    var nodeType = types[paths[0].node.type];\n    var sameType = paths.length === 1 || paths.every(function (path) {\n      return nodeType.check(path.node);\n    });\n    if (sameType) {\n      _types = [nodeType.toString()].concat(astTypes.getSupertypeNames(nodeType.toString()));\n    } else {\n      // try to find a common type\n      _types = intersection(paths.map(function (path) {\n        return astTypes.getSupertypeNames(path.node.type);\n      }));\n    }\n  }\n  return _types;\n}\nfunction _toTypeArray(value) {\n  value = !Array.isArray(value) ? [value] : value;\n  value = value.map(function (v) {\n    return v.toString();\n  });\n  if (value.length > 1) {\n    return union([value].concat(intersection(value.map(_getSupertypeNames))));\n  } else {\n    return value.concat(_getSupertypeNames(value[0]));\n  }\n}\nfunction _getSupertypeNames(type) {\n  try {\n    return astTypes.getSupertypeNames(type);\n  } catch (error) {\n    if (error.message === '') {\n      // Likely the case that the passed type wasn't found in the definition\n      // list. Maybe a typo. ast-types doesn't throw a useful error in that\n      // case :(\n      throw new Error('\"' + type + '\" is not a known AST node type. Maybe a typo?');\n    }\n    throw error;\n  }\n}\n\n/**\n * Creates a new collection from an array of node paths.\n *\n * If type is passed, it will create a typed collection if such a collection\n * exists. The nodes or path values must be of the same type.\n *\n * Otherwise it will try to infer the type from the path list. If every\n * element has the same type, a typed collection is created (if it exists),\n * otherwise, a generic collection will be created.\n *\n * @ignore\n * @param {Array} paths An array of paths\n * @param {Collection} parent A parent collection\n * @param {Type} type An AST type\n * @return {Collection}\n */\nfunction fromPaths(paths, parent, type) {\n  assert.ok(paths.every(function (n) {\n    return n instanceof NodePath;\n  }), 'Every element in the array should be a NodePath');\n  return new Collection(paths, parent, type);\n}\n\n/**\n * Creates a new collection from an array of nodes. This is a convenience\n * method which converts the nodes to node paths first and calls\n *\n *    Collections.fromPaths(paths, parent, type)\n *\n * @ignore\n * @param {Array} nodes An array of AST nodes\n * @param {Collection} parent A parent collection\n * @param {Type} type An AST type\n * @return {Collection}\n */\nfunction fromNodes(nodes, parent, type) {\n  assert.ok(nodes.every(function (n) {\n    return Node.check(n);\n  }), 'Every element in the array should be a Node');\n  return fromPaths(nodes.map(function (n) {\n    return new NodePath(n);\n  }), parent, type);\n}\nvar CPt = Collection.prototype;\n\n/**\n * This function adds the provided methods to the prototype of the corresponding\n * typed collection. If no type is passed, the methods are added to\n * Collection.prototype and are available for all collections.\n *\n * @param {Object} methods Methods to add to the prototype\n * @param {Type=} type Optional type to add the methods to\n */\nfunction registerMethods(methods, type) {\n  for (var methodName in methods) {\n    if (!methods.hasOwnProperty(methodName)) {\n      return;\n    }\n    if (hasConflictingRegistration(methodName, type)) {\n      var msg = \"There is a conflicting registration for method with name \\\"\".concat(methodName, \"\\\".\\nYou tried to register an additional method with \");\n      if (type) {\n        msg += \"type \\\"\".concat(type.toString(), \"\\\".\");\n      } else {\n        msg += 'universal type.';\n      }\n      msg += '\\nThere are existing registrations for that method with ';\n      var conflictingRegistrations = CPt[methodName].typedRegistrations;\n      if (conflictingRegistrations) {\n        msg += \"type \".concat(Object.keys(conflictingRegistrations).join(', '), \".\");\n      } else {\n        msg += 'universal type.';\n      }\n      throw Error(msg);\n    }\n    if (!type) {\n      CPt[methodName] = methods[methodName];\n    } else {\n      type = type.toString();\n      if (!CPt.hasOwnProperty(methodName)) {\n        installTypedMethod(methodName);\n      }\n      var registrations = CPt[methodName].typedRegistrations;\n      registrations[type] = methods[methodName];\n      astTypes.getSupertypeNames(type).forEach(function (name) {\n        registrations[name] = false;\n      });\n    }\n  }\n}\nfunction installTypedMethod(methodName) {\n  if (CPt.hasOwnProperty(methodName)) {\n    throw new Error(\"Internal Error: \\\"\".concat(methodName, \"\\\" method is already installed\"));\n  }\n  var registrations = {};\n  function typedMethod() {\n    var types = Object.keys(registrations);\n    for (var i = 0; i < types.length; i++) {\n      var currentType = types[i];\n      if (registrations[currentType] && this.isOfType(currentType)) {\n        return registrations[currentType].apply(this, arguments);\n      }\n    }\n    throw Error(\"You have a collection of type [\".concat(this.getTypes(), \"]. \") + \"\\\"\".concat(methodName, \"\\\" is only defined for one of [\").concat(types.join('|'), \"].\"));\n  }\n  typedMethod.typedRegistrations = registrations;\n  CPt[methodName] = typedMethod;\n}\nfunction hasConflictingRegistration(methodName, type) {\n  if (!type) {\n    return CPt.hasOwnProperty(methodName);\n  }\n  if (!CPt.hasOwnProperty(methodName)) {\n    return false;\n  }\n  var registrations = CPt[methodName] && CPt[methodName].typedRegistrations;\n  if (!registrations) {\n    return true;\n  }\n  type = type.toString();\n  if (registrations.hasOwnProperty(type)) {\n    return true;\n  }\n  return astTypes.getSupertypeNames(type.toString()).some(function (name) {\n    return !!registrations[name];\n  });\n}\nvar _defaultType = [];\n\n/**\n * Sets the default collection type. In case a collection is created form an\n * empty set of paths and no type is specified, we return a collection of this\n * type.\n *\n * @ignore\n * @param {Type} type\n */\nfunction setDefaultCollectionType(type) {\n  _defaultType = _toTypeArray(type);\n}\nexports.fromPaths = fromPaths;\nexports.fromNodes = fromNodes;\nexports.registerMethods = registerMethods;\nexports.hasConflictingRegistration = hasConflictingRegistration;\nexports.setDefaultCollectionType = setDefaultCollectionType;","map":{"version":3,"names":["_classCallCheck","require","default","_createClass","assert","intersection","recast","union","astTypes","types","namedTypes","NodePath","Node","Collection","paths","parent","ok","Array","isArray","every","p","_parent","__paths","_toTypeArray","length","_inferTypes","_types","_defaultType","key","value","filter","callback","constructor","forEach","path","i","call","some","map","type","result","apply","arguments","indexOf","push","fromPaths","size","get","nodes","getAST","toSource","options","print","code","at","index","slice","undefined","Error","getTypes","isOfType","toString","check","node","nodeType","sameType","concat","getSupertypeNames","v","_getSupertypeNames","error","message","n","fromNodes","CPt","prototype","registerMethods","methods","methodName","hasOwnProperty","hasConflictingRegistration","msg","conflictingRegistrations","typedRegistrations","Object","keys","join","installTypedMethod","registrations","name","typedMethod","currentType","setDefaultCollectionType","exports"],"sources":["C:/Users/Acer/Desktop/dev__book/dev__book/node_modules/jscodeshift/src/Collection.js"],"sourcesContent":["\n/**\n * Copyright (c) Facebook, Inc. and its affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n */\n\n'use strict';\n\nconst assert = require('assert');\nconst intersection = require('./utils/intersection');\nconst recast = require('recast');\nconst union = require('./utils/union');\n\nconst astTypes = recast.types;\nvar types = astTypes.namedTypes;\nconst NodePath = astTypes.NodePath;\nconst Node = types.Node;\n\n/**\n * This represents a generic collection of node paths. It only has a generic\n * API to access and process the elements of the list. It doesn't know anything\n * about AST types.\n *\n * @mixes traversalMethods\n * @mixes mutationMethods\n * @mixes transformMethods\n * @mixes globalMethods\n */\nclass Collection {\n\n  /**\n   * @param {Array} paths An array of AST paths\n   * @param {Collection} parent A parent collection\n   * @param {Array} types An array of types all the paths in the collection\n   *  have in common. If not passed, it will be inferred from the paths.\n   * @return {Collection}\n   */\n  constructor(paths, parent, types) {\n    assert.ok(Array.isArray(paths), 'Collection is passed an array');\n    assert.ok(\n      paths.every(p => p instanceof NodePath),\n      'Array contains only paths'\n    );\n    this._parent = parent;\n    this.__paths = paths;\n    if (types && !Array.isArray(types)) {\n      types = _toTypeArray(types);\n    } else if (!types || Array.isArray(types) && types.length === 0) {\n      types = _inferTypes(paths);\n    }\n    this._types = types.length === 0 ? _defaultType : types;\n  }\n\n  /**\n   * Returns a new collection containing the nodes for which the callback\n   * returns true.\n   *\n   * @param {function} callback\n   * @return {Collection}\n   */\n  filter(callback) {\n    return new this.constructor(this.__paths.filter(callback), this);\n  }\n\n  /**\n   * Executes callback for each node/path in the collection.\n   *\n   * @param {function} callback\n   * @return {Collection} The collection itself\n   */\n  forEach(callback) {\n    this.__paths.forEach(\n      (path, i, paths) => callback.call(path, path, i, paths)\n    );\n    return this;\n  }\n\n  /**\n   * Tests whether at-least one path passes the test implemented by the provided callback.\n   *\n   * @param {function} callback\n   * @return {boolean}\n   */\n  some(callback) {\n    return this.__paths.some(\n      (path, i, paths) => callback.call(path, path, i, paths)\n    );\n  }\n\n  /**\n   * Tests whether all paths pass the test implemented by the provided callback.\n   *\n   * @param {function} callback\n   * @return {boolean}\n   */\n  every(callback) {\n    return this.__paths.every(\n      (path, i, paths) => callback.call(path, path, i, paths)\n    );\n  }\n\n  /**\n   * Executes the callback for every path in the collection and returns a new\n   * collection from the return values (which must be paths).\n   *\n   * The callback can return null to indicate to exclude the element from the\n   * new collection.\n   *\n   * If an array is returned, the array will be flattened into the result\n   * collection.\n   *\n   * @param {function} callback\n   * @param {Type} type Force the new collection to be of a specific type\n   */\n  map(callback, type) {\n    const paths = [];\n    this.forEach(function(path) {\n      /*jshint eqnull:true*/\n      let result = callback.apply(path, arguments);\n      if (result == null) return;\n      if (!Array.isArray(result)) {\n        result = [result];\n      }\n      for (let i = 0; i < result.length; i++) {\n        if (paths.indexOf(result[i]) === -1) {\n          paths.push(result[i]);\n        }\n      }\n    });\n    return fromPaths(paths, this, type);\n  }\n\n  /**\n   * Returns the number of elements in this collection.\n   *\n   * @return {number}\n   */\n  size() {\n    return this.__paths.length;\n  }\n\n  /**\n   * Returns the number of elements in this collection.\n   *\n   * @return {number}\n   */\n  get length() {\n    return this.__paths.length;\n  }\n\n  /**\n   * Returns an array of AST nodes in this collection.\n   *\n   * @return {Array}\n   */\n  nodes() {\n    return this.__paths.map(p => p.value);\n  }\n\n  paths() {\n    return this.__paths;\n  }\n\n  getAST() {\n    if (this._parent) {\n      return this._parent.getAST();\n    }\n    return this.__paths;\n  }\n\n  toSource(options) {\n    if (this._parent) {\n      return this._parent.toSource(options);\n    }\n    if (this.__paths.length === 1) {\n      return recast.print(this.__paths[0], options).code;\n    } else {\n      return this.__paths.map(p => recast.print(p, options).code);\n    }\n  }\n\n  /**\n   * Returns a new collection containing only the element at position index.\n   *\n   * In case of a negative index, the element is taken from the end:\n   *\n   *   .at(0)  - first element\n   *   .at(-1) - last element\n   *\n   * @param {number} index\n   * @return {Collection}\n   */\n  at(index) {\n    return fromPaths(\n      this.__paths.slice(\n        index,\n        index === -1 ? undefined : index + 1\n      ),\n      this\n    );\n  }\n\n  /**\n   * Proxies to NodePath#get of the first path.\n   *\n   * @param {string|number} ...fields\n   */\n  get() {\n    const path = this.__paths[0];\n    if (!path) {\n      throw Error(\n        'You cannot call \"get\" on a collection with no paths. ' +\n        'Instead, check the \"length\" property first to verify at least 1 path exists.'\n      );\n    }\n    return path.get.apply(path, arguments);\n  }\n\n  /**\n   * Returns the type(s) of the collection. This is only used for unit tests,\n   * I don't think other consumers would need it.\n   *\n   * @return {Array<string>}\n   */\n  getTypes() {\n    return this._types;\n  }\n\n  /**\n   * Returns true if this collection has the type 'type'.\n   *\n   * @param {Type} type\n   * @return {boolean}\n   */\n  isOfType(type) {\n    return !!type && this._types.indexOf(type.toString()) > -1;\n  }\n}\n\n/**\n * Given a set of paths, this infers the common types of all paths.\n * @private\n * @param {Array} paths An array of paths.\n * @return {Type} type An AST type\n */\nfunction _inferTypes(paths) {\n  let _types = [];\n\n  if (paths.length > 0 && Node.check(paths[0].node)) {\n    const nodeType = types[paths[0].node.type];\n    const sameType = paths.length === 1 ||\n      paths.every(path => nodeType.check(path.node));\n\n    if (sameType) {\n      _types = [nodeType.toString()].concat(\n        astTypes.getSupertypeNames(nodeType.toString())\n      );\n    } else {\n      // try to find a common type\n      _types = intersection(\n        paths.map(path => astTypes.getSupertypeNames(path.node.type))\n      );\n    }\n  }\n\n  return _types;\n}\n\nfunction _toTypeArray(value) {\n  value = !Array.isArray(value) ? [value] : value;\n  value = value.map(v => v.toString());\n  if (value.length > 1) {\n    return union(\n      [value].concat(intersection(value.map(_getSupertypeNames)))\n    );\n  } else {\n    return value.concat(_getSupertypeNames(value[0]));\n  }\n}\n\nfunction _getSupertypeNames(type) {\n  try {\n    return astTypes.getSupertypeNames(type);\n  } catch(error) {\n    if (error.message === '') {\n      // Likely the case that the passed type wasn't found in the definition\n      // list. Maybe a typo. ast-types doesn't throw a useful error in that\n      // case :(\n      throw new Error(\n        '\"' + type + '\" is not a known AST node type. Maybe a typo?'\n      );\n    }\n    throw error;\n  }\n}\n\n/**\n * Creates a new collection from an array of node paths.\n *\n * If type is passed, it will create a typed collection if such a collection\n * exists. The nodes or path values must be of the same type.\n *\n * Otherwise it will try to infer the type from the path list. If every\n * element has the same type, a typed collection is created (if it exists),\n * otherwise, a generic collection will be created.\n *\n * @ignore\n * @param {Array} paths An array of paths\n * @param {Collection} parent A parent collection\n * @param {Type} type An AST type\n * @return {Collection}\n */\nfunction fromPaths(paths, parent, type) {\n  assert.ok(\n    paths.every(n => n instanceof NodePath),\n    'Every element in the array should be a NodePath'\n  );\n\n  return new Collection(paths, parent, type);\n}\n\n/**\n * Creates a new collection from an array of nodes. This is a convenience\n * method which converts the nodes to node paths first and calls\n *\n *    Collections.fromPaths(paths, parent, type)\n *\n * @ignore\n * @param {Array} nodes An array of AST nodes\n * @param {Collection} parent A parent collection\n * @param {Type} type An AST type\n * @return {Collection}\n */\nfunction fromNodes(nodes, parent, type) {\n  assert.ok(\n    nodes.every(n => Node.check(n)),\n    'Every element in the array should be a Node'\n  );\n  return fromPaths(\n    nodes.map(n => new NodePath(n)),\n    parent,\n    type\n  );\n}\n\nconst CPt = Collection.prototype;\n\n/**\n * This function adds the provided methods to the prototype of the corresponding\n * typed collection. If no type is passed, the methods are added to\n * Collection.prototype and are available for all collections.\n *\n * @param {Object} methods Methods to add to the prototype\n * @param {Type=} type Optional type to add the methods to\n */\nfunction registerMethods(methods, type) {\n  for (const methodName in methods) {\n    if (!methods.hasOwnProperty(methodName)) {\n      return;\n    }\n    if (hasConflictingRegistration(methodName, type)) {\n      let msg = `There is a conflicting registration for method with name \"${methodName}\".\\nYou tried to register an additional method with `;\n\n      if (type) {\n        msg += `type \"${type.toString()}\".`\n      } else {\n        msg += 'universal type.'\n      }\n\n      msg += '\\nThere are existing registrations for that method with ';\n\n      const conflictingRegistrations = CPt[methodName].typedRegistrations;\n\n      if (conflictingRegistrations) {\n        msg += `type ${Object.keys(conflictingRegistrations).join(', ')}.`;\n      } else {\n        msg += 'universal type.';\n      }\n\n      throw Error(msg);\n    }\n    if (!type) {\n      CPt[methodName] = methods[methodName];\n    } else {\n      type = type.toString();\n      if (!CPt.hasOwnProperty(methodName)) {\n        installTypedMethod(methodName);\n      }\n      var registrations = CPt[methodName].typedRegistrations;\n      registrations[type] = methods[methodName];\n      astTypes.getSupertypeNames(type).forEach(function (name) {\n        registrations[name] = false;\n      });\n    }\n  }\n}\n\nfunction installTypedMethod(methodName) {\n  if (CPt.hasOwnProperty(methodName)) {\n    throw new Error(`Internal Error: \"${methodName}\" method is already installed`);\n  }\n\n  const registrations = {};\n\n  function typedMethod() {\n    const types = Object.keys(registrations);\n\n    for (let i = 0; i < types.length; i++) {\n      const currentType = types[i];\n      if (registrations[currentType] && this.isOfType(currentType)) {\n        return registrations[currentType].apply(this, arguments);\n      }\n    }\n\n    throw Error(\n      `You have a collection of type [${this.getTypes()}]. ` +\n      `\"${methodName}\" is only defined for one of [${types.join('|')}].`\n    );\n  }\n\n  typedMethod.typedRegistrations = registrations;\n\n  CPt[methodName] = typedMethod;\n}\n\nfunction hasConflictingRegistration(methodName, type) {\n  if (!type) {\n    return CPt.hasOwnProperty(methodName);\n  }\n\n  if (!CPt.hasOwnProperty(methodName)) {\n    return false;\n  }\n\n  const registrations = CPt[methodName] && CPt[methodName].typedRegistrations;\n\n  if (!registrations) {\n    return true;\n  }\n\n  type = type.toString();\n\n  if (registrations.hasOwnProperty(type)) {\n    return true;\n  }\n\n  return astTypes.getSupertypeNames(type.toString()).some(function (name) {\n    return !!registrations[name];\n  });\n}\n\nvar _defaultType = [];\n\n/**\n * Sets the default collection type. In case a collection is created form an\n * empty set of paths and no type is specified, we return a collection of this\n * type.\n *\n * @ignore\n * @param {Type} type\n */\nfunction setDefaultCollectionType(type) {\n  _defaultType = _toTypeArray(type);\n}\n\nexports.fromPaths = fromPaths;\nexports.fromNodes = fromNodes;\nexports.registerMethods = registerMethods;\nexports.hasConflictingRegistration = hasConflictingRegistration;\nexports.setDefaultCollectionType = setDefaultCollectionType;\n"],"mappings":"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"},"metadata":{},"sourceType":"script"}