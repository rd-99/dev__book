{"ast":null,"code":"\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.concat = exports.fromString = exports.countSpaces = exports.Lines = void 0;\nvar tslib_1 = require(\"tslib\");\nvar assert_1 = tslib_1.__importDefault(require(\"assert\"));\nvar source_map_1 = tslib_1.__importDefault(require(\"source-map\"));\nvar options_1 = require(\"./options\");\nvar util_1 = require(\"./util\");\nvar mapping_1 = tslib_1.__importDefault(require(\"./mapping\"));\nvar Lines = /** @class */function () {\n  function Lines(infos, sourceFileName) {\n    if (sourceFileName === void 0) {\n      sourceFileName = null;\n    }\n    this.infos = infos;\n    this.mappings = [];\n    this.cachedSourceMap = null;\n    this.cachedTabWidth = void 0;\n    assert_1.default.ok(infos.length > 0);\n    this.length = infos.length;\n    this.name = sourceFileName || null;\n    if (this.name) {\n      this.mappings.push(new mapping_1.default(this, {\n        start: this.firstPos(),\n        end: this.lastPos()\n      }));\n    }\n  }\n  Lines.prototype.toString = function (options) {\n    return this.sliceString(this.firstPos(), this.lastPos(), options);\n  };\n  Lines.prototype.getSourceMap = function (sourceMapName, sourceRoot) {\n    if (!sourceMapName) {\n      // Although we could make up a name or generate an anonymous\n      // source map, instead we assume that any consumer who does not\n      // provide a name does not actually want a source map.\n      return null;\n    }\n    var targetLines = this;\n    function updateJSON(json) {\n      json = json || {};\n      json.file = sourceMapName;\n      if (sourceRoot) {\n        json.sourceRoot = sourceRoot;\n      }\n      return json;\n    }\n    if (targetLines.cachedSourceMap) {\n      // Since Lines objects are immutable, we can reuse any source map\n      // that was previously generated. Nevertheless, we return a new\n      // JSON object here to protect the cached source map from outside\n      // modification.\n      return updateJSON(targetLines.cachedSourceMap.toJSON());\n    }\n    var smg = new source_map_1.default.SourceMapGenerator(updateJSON());\n    var sourcesToContents = {};\n    targetLines.mappings.forEach(function (mapping) {\n      var sourceCursor = mapping.sourceLines.skipSpaces(mapping.sourceLoc.start) || mapping.sourceLines.lastPos();\n      var targetCursor = targetLines.skipSpaces(mapping.targetLoc.start) || targetLines.lastPos();\n      while (util_1.comparePos(sourceCursor, mapping.sourceLoc.end) < 0 && util_1.comparePos(targetCursor, mapping.targetLoc.end) < 0) {\n        var sourceChar = mapping.sourceLines.charAt(sourceCursor);\n        var targetChar = targetLines.charAt(targetCursor);\n        assert_1.default.strictEqual(sourceChar, targetChar);\n        var sourceName = mapping.sourceLines.name;\n        // Add mappings one character at a time for maximum resolution.\n        smg.addMapping({\n          source: sourceName,\n          original: {\n            line: sourceCursor.line,\n            column: sourceCursor.column\n          },\n          generated: {\n            line: targetCursor.line,\n            column: targetCursor.column\n          }\n        });\n        if (!hasOwn.call(sourcesToContents, sourceName)) {\n          var sourceContent = mapping.sourceLines.toString();\n          smg.setSourceContent(sourceName, sourceContent);\n          sourcesToContents[sourceName] = sourceContent;\n        }\n        targetLines.nextPos(targetCursor, true);\n        mapping.sourceLines.nextPos(sourceCursor, true);\n      }\n    });\n    targetLines.cachedSourceMap = smg;\n    return smg.toJSON();\n  };\n  Lines.prototype.bootstrapCharAt = function (pos) {\n    assert_1.default.strictEqual(typeof pos, \"object\");\n    assert_1.default.strictEqual(typeof pos.line, \"number\");\n    assert_1.default.strictEqual(typeof pos.column, \"number\");\n    var line = pos.line,\n      column = pos.column,\n      strings = this.toString().split(lineTerminatorSeqExp),\n      string = strings[line - 1];\n    if (typeof string === \"undefined\") return \"\";\n    if (column === string.length && line < strings.length) return \"\\n\";\n    if (column >= string.length) return \"\";\n    return string.charAt(column);\n  };\n  Lines.prototype.charAt = function (pos) {\n    assert_1.default.strictEqual(typeof pos, \"object\");\n    assert_1.default.strictEqual(typeof pos.line, \"number\");\n    assert_1.default.strictEqual(typeof pos.column, \"number\");\n    var line = pos.line,\n      column = pos.column,\n      secret = this,\n      infos = secret.infos,\n      info = infos[line - 1],\n      c = column;\n    if (typeof info === \"undefined\" || c < 0) return \"\";\n    var indent = this.getIndentAt(line);\n    if (c < indent) return \" \";\n    c += info.sliceStart - indent;\n    if (c === info.sliceEnd && line < this.length) return \"\\n\";\n    if (c >= info.sliceEnd) return \"\";\n    return info.line.charAt(c);\n  };\n  Lines.prototype.stripMargin = function (width, skipFirstLine) {\n    if (width === 0) return this;\n    assert_1.default.ok(width > 0, \"negative margin: \" + width);\n    if (skipFirstLine && this.length === 1) return this;\n    var lines = new Lines(this.infos.map(function (info, i) {\n      if (info.line && (i > 0 || !skipFirstLine)) {\n        info = tslib_1.__assign(tslib_1.__assign({}, info), {\n          indent: Math.max(0, info.indent - width)\n        });\n      }\n      return info;\n    }));\n    if (this.mappings.length > 0) {\n      var newMappings_1 = lines.mappings;\n      assert_1.default.strictEqual(newMappings_1.length, 0);\n      this.mappings.forEach(function (mapping) {\n        newMappings_1.push(mapping.indent(width, skipFirstLine, true));\n      });\n    }\n    return lines;\n  };\n  Lines.prototype.indent = function (by) {\n    if (by === 0) {\n      return this;\n    }\n    var lines = new Lines(this.infos.map(function (info) {\n      if (info.line && !info.locked) {\n        info = tslib_1.__assign(tslib_1.__assign({}, info), {\n          indent: info.indent + by\n        });\n      }\n      return info;\n    }));\n    if (this.mappings.length > 0) {\n      var newMappings_2 = lines.mappings;\n      assert_1.default.strictEqual(newMappings_2.length, 0);\n      this.mappings.forEach(function (mapping) {\n        newMappings_2.push(mapping.indent(by));\n      });\n    }\n    return lines;\n  };\n  Lines.prototype.indentTail = function (by) {\n    if (by === 0) {\n      return this;\n    }\n    if (this.length < 2) {\n      return this;\n    }\n    var lines = new Lines(this.infos.map(function (info, i) {\n      if (i > 0 && info.line && !info.locked) {\n        info = tslib_1.__assign(tslib_1.__assign({}, info), {\n          indent: info.indent + by\n        });\n      }\n      return info;\n    }));\n    if (this.mappings.length > 0) {\n      var newMappings_3 = lines.mappings;\n      assert_1.default.strictEqual(newMappings_3.length, 0);\n      this.mappings.forEach(function (mapping) {\n        newMappings_3.push(mapping.indent(by, true));\n      });\n    }\n    return lines;\n  };\n  Lines.prototype.lockIndentTail = function () {\n    if (this.length < 2) {\n      return this;\n    }\n    return new Lines(this.infos.map(function (info, i) {\n      return tslib_1.__assign(tslib_1.__assign({}, info), {\n        locked: i > 0\n      });\n    }));\n  };\n  Lines.prototype.getIndentAt = function (line) {\n    assert_1.default.ok(line >= 1, \"no line \" + line + \" (line numbers start from 1)\");\n    return Math.max(this.infos[line - 1].indent, 0);\n  };\n  Lines.prototype.guessTabWidth = function () {\n    if (typeof this.cachedTabWidth === \"number\") {\n      return this.cachedTabWidth;\n    }\n    var counts = []; // Sparse array.\n    var lastIndent = 0;\n    for (var line = 1, last = this.length; line <= last; ++line) {\n      var info = this.infos[line - 1];\n      var sliced = info.line.slice(info.sliceStart, info.sliceEnd);\n      // Whitespace-only lines don't tell us much about the likely tab\n      // width of this code.\n      if (isOnlyWhitespace(sliced)) {\n        continue;\n      }\n      var diff = Math.abs(info.indent - lastIndent);\n      counts[diff] = ~~counts[diff] + 1;\n      lastIndent = info.indent;\n    }\n    var maxCount = -1;\n    var result = 2;\n    for (var tabWidth = 1; tabWidth < counts.length; tabWidth += 1) {\n      if (hasOwn.call(counts, tabWidth) && counts[tabWidth] > maxCount) {\n        maxCount = counts[tabWidth];\n        result = tabWidth;\n      }\n    }\n    return this.cachedTabWidth = result;\n  };\n  // Determine if the list of lines has a first line that starts with a //\n  // or /* comment. If this is the case, the code may need to be wrapped in\n  // parens to avoid ASI issues.\n  Lines.prototype.startsWithComment = function () {\n    if (this.infos.length === 0) {\n      return false;\n    }\n    var firstLineInfo = this.infos[0],\n      sliceStart = firstLineInfo.sliceStart,\n      sliceEnd = firstLineInfo.sliceEnd,\n      firstLine = firstLineInfo.line.slice(sliceStart, sliceEnd).trim();\n    return firstLine.length === 0 || firstLine.slice(0, 2) === \"//\" || firstLine.slice(0, 2) === \"/*\";\n  };\n  Lines.prototype.isOnlyWhitespace = function () {\n    return isOnlyWhitespace(this.toString());\n  };\n  Lines.prototype.isPrecededOnlyByWhitespace = function (pos) {\n    var info = this.infos[pos.line - 1];\n    var indent = Math.max(info.indent, 0);\n    var diff = pos.column - indent;\n    if (diff <= 0) {\n      // If pos.column does not exceed the indentation amount, then\n      // there must be only whitespace before it.\n      return true;\n    }\n    var start = info.sliceStart;\n    var end = Math.min(start + diff, info.sliceEnd);\n    var prefix = info.line.slice(start, end);\n    return isOnlyWhitespace(prefix);\n  };\n  Lines.prototype.getLineLength = function (line) {\n    var info = this.infos[line - 1];\n    return this.getIndentAt(line) + info.sliceEnd - info.sliceStart;\n  };\n  Lines.prototype.nextPos = function (pos, skipSpaces) {\n    if (skipSpaces === void 0) {\n      skipSpaces = false;\n    }\n    var l = Math.max(pos.line, 0),\n      c = Math.max(pos.column, 0);\n    if (c < this.getLineLength(l)) {\n      pos.column += 1;\n      return skipSpaces ? !!this.skipSpaces(pos, false, true) : true;\n    }\n    if (l < this.length) {\n      pos.line += 1;\n      pos.column = 0;\n      return skipSpaces ? !!this.skipSpaces(pos, false, true) : true;\n    }\n    return false;\n  };\n  Lines.prototype.prevPos = function (pos, skipSpaces) {\n    if (skipSpaces === void 0) {\n      skipSpaces = false;\n    }\n    var l = pos.line,\n      c = pos.column;\n    if (c < 1) {\n      l -= 1;\n      if (l < 1) return false;\n      c = this.getLineLength(l);\n    } else {\n      c = Math.min(c - 1, this.getLineLength(l));\n    }\n    pos.line = l;\n    pos.column = c;\n    return skipSpaces ? !!this.skipSpaces(pos, true, true) : true;\n  };\n  Lines.prototype.firstPos = function () {\n    // Trivial, but provided for completeness.\n    return {\n      line: 1,\n      column: 0\n    };\n  };\n  Lines.prototype.lastPos = function () {\n    return {\n      line: this.length,\n      column: this.getLineLength(this.length)\n    };\n  };\n  Lines.prototype.skipSpaces = function (pos, backward, modifyInPlace) {\n    if (backward === void 0) {\n      backward = false;\n    }\n    if (modifyInPlace === void 0) {\n      modifyInPlace = false;\n    }\n    if (pos) {\n      pos = modifyInPlace ? pos : {\n        line: pos.line,\n        column: pos.column\n      };\n    } else if (backward) {\n      pos = this.lastPos();\n    } else {\n      pos = this.firstPos();\n    }\n    if (backward) {\n      while (this.prevPos(pos)) {\n        if (!isOnlyWhitespace(this.charAt(pos)) && this.nextPos(pos)) {\n          return pos;\n        }\n      }\n      return null;\n    } else {\n      while (isOnlyWhitespace(this.charAt(pos))) {\n        if (!this.nextPos(pos)) {\n          return null;\n        }\n      }\n      return pos;\n    }\n  };\n  Lines.prototype.trimLeft = function () {\n    var pos = this.skipSpaces(this.firstPos(), false, true);\n    return pos ? this.slice(pos) : emptyLines;\n  };\n  Lines.prototype.trimRight = function () {\n    var pos = this.skipSpaces(this.lastPos(), true, true);\n    return pos ? this.slice(this.firstPos(), pos) : emptyLines;\n  };\n  Lines.prototype.trim = function () {\n    var start = this.skipSpaces(this.firstPos(), false, true);\n    if (start === null) {\n      return emptyLines;\n    }\n    var end = this.skipSpaces(this.lastPos(), true, true);\n    if (end === null) {\n      return emptyLines;\n    }\n    return this.slice(start, end);\n  };\n  Lines.prototype.eachPos = function (callback, startPos, skipSpaces) {\n    if (startPos === void 0) {\n      startPos = this.firstPos();\n    }\n    if (skipSpaces === void 0) {\n      skipSpaces = false;\n    }\n    var pos = this.firstPos();\n    if (startPos) {\n      pos.line = startPos.line, pos.column = startPos.column;\n    }\n    if (skipSpaces && !this.skipSpaces(pos, false, true)) {\n      return; // Encountered nothing but spaces.\n    }\n\n    do callback.call(this, pos); while (this.nextPos(pos, skipSpaces));\n  };\n  Lines.prototype.bootstrapSlice = function (start, end) {\n    var strings = this.toString().split(lineTerminatorSeqExp).slice(start.line - 1, end.line);\n    if (strings.length > 0) {\n      strings.push(strings.pop().slice(0, end.column));\n      strings[0] = strings[0].slice(start.column);\n    }\n    return fromString(strings.join(\"\\n\"));\n  };\n  Lines.prototype.slice = function (start, end) {\n    if (!end) {\n      if (!start) {\n        // The client seems to want a copy of this Lines object, but\n        // Lines objects are immutable, so it's perfectly adequate to\n        // return the same object.\n        return this;\n      }\n      // Slice to the end if no end position was provided.\n      end = this.lastPos();\n    }\n    if (!start) {\n      throw new Error(\"cannot slice with end but not start\");\n    }\n    var sliced = this.infos.slice(start.line - 1, end.line);\n    if (start.line === end.line) {\n      sliced[0] = sliceInfo(sliced[0], start.column, end.column);\n    } else {\n      assert_1.default.ok(start.line < end.line);\n      sliced[0] = sliceInfo(sliced[0], start.column);\n      sliced.push(sliceInfo(sliced.pop(), 0, end.column));\n    }\n    var lines = new Lines(sliced);\n    if (this.mappings.length > 0) {\n      var newMappings_4 = lines.mappings;\n      assert_1.default.strictEqual(newMappings_4.length, 0);\n      this.mappings.forEach(function (mapping) {\n        var sliced = mapping.slice(this, start, end);\n        if (sliced) {\n          newMappings_4.push(sliced);\n        }\n      }, this);\n    }\n    return lines;\n  };\n  Lines.prototype.bootstrapSliceString = function (start, end, options) {\n    return this.slice(start, end).toString(options);\n  };\n  Lines.prototype.sliceString = function (start, end, options) {\n    if (start === void 0) {\n      start = this.firstPos();\n    }\n    if (end === void 0) {\n      end = this.lastPos();\n    }\n    var _a = options_1.normalize(options),\n      tabWidth = _a.tabWidth,\n      useTabs = _a.useTabs,\n      reuseWhitespace = _a.reuseWhitespace,\n      lineTerminator = _a.lineTerminator;\n    var parts = [];\n    for (var line = start.line; line <= end.line; ++line) {\n      var info = this.infos[line - 1];\n      if (line === start.line) {\n        if (line === end.line) {\n          info = sliceInfo(info, start.column, end.column);\n        } else {\n          info = sliceInfo(info, start.column);\n        }\n      } else if (line === end.line) {\n        info = sliceInfo(info, 0, end.column);\n      }\n      var indent = Math.max(info.indent, 0);\n      var before_1 = info.line.slice(0, info.sliceStart);\n      if (reuseWhitespace && isOnlyWhitespace(before_1) && countSpaces(before_1, tabWidth) === indent) {\n        // Reuse original spaces if the indentation is correct.\n        parts.push(info.line.slice(0, info.sliceEnd));\n        continue;\n      }\n      var tabs = 0;\n      var spaces = indent;\n      if (useTabs) {\n        tabs = Math.floor(indent / tabWidth);\n        spaces -= tabs * tabWidth;\n      }\n      var result = \"\";\n      if (tabs > 0) {\n        result += new Array(tabs + 1).join(\"\\t\");\n      }\n      if (spaces > 0) {\n        result += new Array(spaces + 1).join(\" \");\n      }\n      result += info.line.slice(info.sliceStart, info.sliceEnd);\n      parts.push(result);\n    }\n    return parts.join(lineTerminator);\n  };\n  Lines.prototype.isEmpty = function () {\n    return this.length < 2 && this.getLineLength(1) < 1;\n  };\n  Lines.prototype.join = function (elements) {\n    var separator = this;\n    var infos = [];\n    var mappings = [];\n    var prevInfo;\n    function appendLines(linesOrNull) {\n      if (linesOrNull === null) {\n        return;\n      }\n      if (prevInfo) {\n        var info = linesOrNull.infos[0];\n        var indent = new Array(info.indent + 1).join(\" \");\n        var prevLine_1 = infos.length;\n        var prevColumn_1 = Math.max(prevInfo.indent, 0) + prevInfo.sliceEnd - prevInfo.sliceStart;\n        prevInfo.line = prevInfo.line.slice(0, prevInfo.sliceEnd) + indent + info.line.slice(info.sliceStart, info.sliceEnd);\n        // If any part of a line is indentation-locked, the whole line\n        // will be indentation-locked.\n        prevInfo.locked = prevInfo.locked || info.locked;\n        prevInfo.sliceEnd = prevInfo.line.length;\n        if (linesOrNull.mappings.length > 0) {\n          linesOrNull.mappings.forEach(function (mapping) {\n            mappings.push(mapping.add(prevLine_1, prevColumn_1));\n          });\n        }\n      } else if (linesOrNull.mappings.length > 0) {\n        mappings.push.apply(mappings, linesOrNull.mappings);\n      }\n      linesOrNull.infos.forEach(function (info, i) {\n        if (!prevInfo || i > 0) {\n          prevInfo = tslib_1.__assign({}, info);\n          infos.push(prevInfo);\n        }\n      });\n    }\n    function appendWithSeparator(linesOrNull, i) {\n      if (i > 0) appendLines(separator);\n      appendLines(linesOrNull);\n    }\n    elements.map(function (elem) {\n      var lines = fromString(elem);\n      if (lines.isEmpty()) return null;\n      return lines;\n    }).forEach(function (linesOrNull, i) {\n      if (separator.isEmpty()) {\n        appendLines(linesOrNull);\n      } else {\n        appendWithSeparator(linesOrNull, i);\n      }\n    });\n    if (infos.length < 1) return emptyLines;\n    var lines = new Lines(infos);\n    lines.mappings = mappings;\n    return lines;\n  };\n  Lines.prototype.concat = function () {\n    var args = [];\n    for (var _i = 0; _i < arguments.length; _i++) {\n      args[_i] = arguments[_i];\n    }\n    var list = [this];\n    list.push.apply(list, args);\n    assert_1.default.strictEqual(list.length, args.length + 1);\n    return emptyLines.join(list);\n  };\n  return Lines;\n}();\nexports.Lines = Lines;\nvar fromStringCache = {};\nvar hasOwn = fromStringCache.hasOwnProperty;\nvar maxCacheKeyLen = 10;\nfunction countSpaces(spaces, tabWidth) {\n  var count = 0;\n  var len = spaces.length;\n  for (var i = 0; i < len; ++i) {\n    switch (spaces.charCodeAt(i)) {\n      case 9:\n        {\n          // '\\t'\n          assert_1.default.strictEqual(typeof tabWidth, \"number\");\n          assert_1.default.ok(tabWidth > 0);\n          var next = Math.ceil(count / tabWidth) * tabWidth;\n          if (next === count) {\n            count += tabWidth;\n          } else {\n            count = next;\n          }\n          break;\n        }\n      case 11: // '\\v'\n      case 12: // '\\f'\n      case 13: // '\\r'\n      case 0xfeff:\n        // zero-width non-breaking space\n        // These characters contribute nothing to indentation.\n        break;\n      case 32: // ' '\n      default:\n        // Treat all other whitespace like ' '.\n        count += 1;\n        break;\n    }\n  }\n  return count;\n}\nexports.countSpaces = countSpaces;\nvar leadingSpaceExp = /^\\s*/;\n// As specified here: http://www.ecma-international.org/ecma-262/6.0/#sec-line-terminators\nvar lineTerminatorSeqExp = /\\u000D\\u000A|\\u000D(?!\\u000A)|\\u000A|\\u2028|\\u2029/;\n/**\n * @param {Object} options - Options object that configures printing.\n */\nfunction fromString(string, options) {\n  if (string instanceof Lines) return string;\n  string += \"\";\n  var tabWidth = options && options.tabWidth;\n  var tabless = string.indexOf(\"\\t\") < 0;\n  var cacheable = !options && tabless && string.length <= maxCacheKeyLen;\n  assert_1.default.ok(tabWidth || tabless, \"No tab width specified but encountered tabs in string\\n\" + string);\n  if (cacheable && hasOwn.call(fromStringCache, string)) return fromStringCache[string];\n  var lines = new Lines(string.split(lineTerminatorSeqExp).map(function (line) {\n    // TODO: handle null exec result\n    var spaces = leadingSpaceExp.exec(line)[0];\n    return {\n      line: line,\n      indent: countSpaces(spaces, tabWidth),\n      // Boolean indicating whether this line can be reindented.\n      locked: false,\n      sliceStart: spaces.length,\n      sliceEnd: line.length\n    };\n  }), options_1.normalize(options).sourceFileName);\n  if (cacheable) fromStringCache[string] = lines;\n  return lines;\n}\nexports.fromString = fromString;\nfunction isOnlyWhitespace(string) {\n  return !/\\S/.test(string);\n}\nfunction sliceInfo(info, startCol, endCol) {\n  var sliceStart = info.sliceStart;\n  var sliceEnd = info.sliceEnd;\n  var indent = Math.max(info.indent, 0);\n  var lineLength = indent + sliceEnd - sliceStart;\n  if (typeof endCol === \"undefined\") {\n    endCol = lineLength;\n  }\n  startCol = Math.max(startCol, 0);\n  endCol = Math.min(endCol, lineLength);\n  endCol = Math.max(endCol, startCol);\n  if (endCol < indent) {\n    indent = endCol;\n    sliceEnd = sliceStart;\n  } else {\n    sliceEnd -= lineLength - endCol;\n  }\n  lineLength = endCol;\n  lineLength -= startCol;\n  if (startCol < indent) {\n    indent -= startCol;\n  } else {\n    startCol -= indent;\n    indent = 0;\n    sliceStart += startCol;\n  }\n  assert_1.default.ok(indent >= 0);\n  assert_1.default.ok(sliceStart <= sliceEnd);\n  assert_1.default.strictEqual(lineLength, indent + sliceEnd - sliceStart);\n  if (info.indent === indent && info.sliceStart === sliceStart && info.sliceEnd === sliceEnd) {\n    return info;\n  }\n  return {\n    line: info.line,\n    indent: indent,\n    // A destructive slice always unlocks indentation.\n    locked: false,\n    sliceStart: sliceStart,\n    sliceEnd: sliceEnd\n  };\n}\nfunction concat(elements) {\n  return emptyLines.join(elements);\n}\nexports.concat = concat;\n// The emptyLines object needs to be created all the way down here so that\n// Lines.prototype will be fully populated.\nvar emptyLines = fromString(\"\");","map":{"version":3,"names":["Object","defineProperty","exports","value","concat","fromString","countSpaces","Lines","tslib_1","require","assert_1","__importDefault","source_map_1","options_1","util_1","mapping_1","infos","sourceFileName","mappings","cachedSourceMap","cachedTabWidth","default","ok","length","name","push","start","firstPos","end","lastPos","prototype","toString","options","sliceString","getSourceMap","sourceMapName","sourceRoot","targetLines","updateJSON","json","file","toJSON","smg","SourceMapGenerator","sourcesToContents","forEach","mapping","sourceCursor","sourceLines","skipSpaces","sourceLoc","targetCursor","targetLoc","comparePos","sourceChar","charAt","targetChar","strictEqual","sourceName","addMapping","source","original","line","column","generated","hasOwn","call","sourceContent","setSourceContent","nextPos","bootstrapCharAt","pos","strings","split","lineTerminatorSeqExp","string","secret","info","c","indent","getIndentAt","sliceStart","sliceEnd","stripMargin","width","skipFirstLine","lines","map","i","__assign","Math","max","newMappings_1","by","locked","newMappings_2","indentTail","newMappings_3","lockIndentTail","guessTabWidth","counts","lastIndent","last","sliced","slice","isOnlyWhitespace","diff","abs","maxCount","result","tabWidth","startsWithComment","firstLineInfo","firstLine","trim","isPrecededOnlyByWhitespace","min","prefix","getLineLength","l","prevPos","backward","modifyInPlace","trimLeft","emptyLines","trimRight","eachPos","callback","startPos","bootstrapSlice","pop","join","Error","sliceInfo","newMappings_4","bootstrapSliceString","_a","normalize","useTabs","reuseWhitespace","lineTerminator","parts","before_1","tabs","spaces","floor","Array","isEmpty","elements","separator","prevInfo","appendLines","linesOrNull","prevLine_1","prevColumn_1","add","apply","appendWithSeparator","elem","args","_i","arguments","list","fromStringCache","hasOwnProperty","maxCacheKeyLen","count","len","charCodeAt","next","ceil","leadingSpaceExp","tabless","indexOf","cacheable","exec","test","startCol","endCol","lineLength"],"sources":["C:/Users/Acer/Desktop/dev__book/dev__book/node_modules/jscodeshift/node_modules/recast/lib/lines.js"],"sourcesContent":["\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.concat = exports.fromString = exports.countSpaces = exports.Lines = void 0;\nvar tslib_1 = require(\"tslib\");\nvar assert_1 = tslib_1.__importDefault(require(\"assert\"));\nvar source_map_1 = tslib_1.__importDefault(require(\"source-map\"));\nvar options_1 = require(\"./options\");\nvar util_1 = require(\"./util\");\nvar mapping_1 = tslib_1.__importDefault(require(\"./mapping\"));\nvar Lines = /** @class */ (function () {\n    function Lines(infos, sourceFileName) {\n        if (sourceFileName === void 0) { sourceFileName = null; }\n        this.infos = infos;\n        this.mappings = [];\n        this.cachedSourceMap = null;\n        this.cachedTabWidth = void 0;\n        assert_1.default.ok(infos.length > 0);\n        this.length = infos.length;\n        this.name = sourceFileName || null;\n        if (this.name) {\n            this.mappings.push(new mapping_1.default(this, {\n                start: this.firstPos(),\n                end: this.lastPos(),\n            }));\n        }\n    }\n    Lines.prototype.toString = function (options) {\n        return this.sliceString(this.firstPos(), this.lastPos(), options);\n    };\n    Lines.prototype.getSourceMap = function (sourceMapName, sourceRoot) {\n        if (!sourceMapName) {\n            // Although we could make up a name or generate an anonymous\n            // source map, instead we assume that any consumer who does not\n            // provide a name does not actually want a source map.\n            return null;\n        }\n        var targetLines = this;\n        function updateJSON(json) {\n            json = json || {};\n            json.file = sourceMapName;\n            if (sourceRoot) {\n                json.sourceRoot = sourceRoot;\n            }\n            return json;\n        }\n        if (targetLines.cachedSourceMap) {\n            // Since Lines objects are immutable, we can reuse any source map\n            // that was previously generated. Nevertheless, we return a new\n            // JSON object here to protect the cached source map from outside\n            // modification.\n            return updateJSON(targetLines.cachedSourceMap.toJSON());\n        }\n        var smg = new source_map_1.default.SourceMapGenerator(updateJSON());\n        var sourcesToContents = {};\n        targetLines.mappings.forEach(function (mapping) {\n            var sourceCursor = mapping.sourceLines.skipSpaces(mapping.sourceLoc.start) ||\n                mapping.sourceLines.lastPos();\n            var targetCursor = targetLines.skipSpaces(mapping.targetLoc.start) ||\n                targetLines.lastPos();\n            while (util_1.comparePos(sourceCursor, mapping.sourceLoc.end) < 0 &&\n                util_1.comparePos(targetCursor, mapping.targetLoc.end) < 0) {\n                var sourceChar = mapping.sourceLines.charAt(sourceCursor);\n                var targetChar = targetLines.charAt(targetCursor);\n                assert_1.default.strictEqual(sourceChar, targetChar);\n                var sourceName = mapping.sourceLines.name;\n                // Add mappings one character at a time for maximum resolution.\n                smg.addMapping({\n                    source: sourceName,\n                    original: { line: sourceCursor.line, column: sourceCursor.column },\n                    generated: { line: targetCursor.line, column: targetCursor.column },\n                });\n                if (!hasOwn.call(sourcesToContents, sourceName)) {\n                    var sourceContent = mapping.sourceLines.toString();\n                    smg.setSourceContent(sourceName, sourceContent);\n                    sourcesToContents[sourceName] = sourceContent;\n                }\n                targetLines.nextPos(targetCursor, true);\n                mapping.sourceLines.nextPos(sourceCursor, true);\n            }\n        });\n        targetLines.cachedSourceMap = smg;\n        return smg.toJSON();\n    };\n    Lines.prototype.bootstrapCharAt = function (pos) {\n        assert_1.default.strictEqual(typeof pos, \"object\");\n        assert_1.default.strictEqual(typeof pos.line, \"number\");\n        assert_1.default.strictEqual(typeof pos.column, \"number\");\n        var line = pos.line, column = pos.column, strings = this.toString().split(lineTerminatorSeqExp), string = strings[line - 1];\n        if (typeof string === \"undefined\")\n            return \"\";\n        if (column === string.length && line < strings.length)\n            return \"\\n\";\n        if (column >= string.length)\n            return \"\";\n        return string.charAt(column);\n    };\n    Lines.prototype.charAt = function (pos) {\n        assert_1.default.strictEqual(typeof pos, \"object\");\n        assert_1.default.strictEqual(typeof pos.line, \"number\");\n        assert_1.default.strictEqual(typeof pos.column, \"number\");\n        var line = pos.line, column = pos.column, secret = this, infos = secret.infos, info = infos[line - 1], c = column;\n        if (typeof info === \"undefined\" || c < 0)\n            return \"\";\n        var indent = this.getIndentAt(line);\n        if (c < indent)\n            return \" \";\n        c += info.sliceStart - indent;\n        if (c === info.sliceEnd && line < this.length)\n            return \"\\n\";\n        if (c >= info.sliceEnd)\n            return \"\";\n        return info.line.charAt(c);\n    };\n    Lines.prototype.stripMargin = function (width, skipFirstLine) {\n        if (width === 0)\n            return this;\n        assert_1.default.ok(width > 0, \"negative margin: \" + width);\n        if (skipFirstLine && this.length === 1)\n            return this;\n        var lines = new Lines(this.infos.map(function (info, i) {\n            if (info.line && (i > 0 || !skipFirstLine)) {\n                info = tslib_1.__assign(tslib_1.__assign({}, info), { indent: Math.max(0, info.indent - width) });\n            }\n            return info;\n        }));\n        if (this.mappings.length > 0) {\n            var newMappings_1 = lines.mappings;\n            assert_1.default.strictEqual(newMappings_1.length, 0);\n            this.mappings.forEach(function (mapping) {\n                newMappings_1.push(mapping.indent(width, skipFirstLine, true));\n            });\n        }\n        return lines;\n    };\n    Lines.prototype.indent = function (by) {\n        if (by === 0) {\n            return this;\n        }\n        var lines = new Lines(this.infos.map(function (info) {\n            if (info.line && !info.locked) {\n                info = tslib_1.__assign(tslib_1.__assign({}, info), { indent: info.indent + by });\n            }\n            return info;\n        }));\n        if (this.mappings.length > 0) {\n            var newMappings_2 = lines.mappings;\n            assert_1.default.strictEqual(newMappings_2.length, 0);\n            this.mappings.forEach(function (mapping) {\n                newMappings_2.push(mapping.indent(by));\n            });\n        }\n        return lines;\n    };\n    Lines.prototype.indentTail = function (by) {\n        if (by === 0) {\n            return this;\n        }\n        if (this.length < 2) {\n            return this;\n        }\n        var lines = new Lines(this.infos.map(function (info, i) {\n            if (i > 0 && info.line && !info.locked) {\n                info = tslib_1.__assign(tslib_1.__assign({}, info), { indent: info.indent + by });\n            }\n            return info;\n        }));\n        if (this.mappings.length > 0) {\n            var newMappings_3 = lines.mappings;\n            assert_1.default.strictEqual(newMappings_3.length, 0);\n            this.mappings.forEach(function (mapping) {\n                newMappings_3.push(mapping.indent(by, true));\n            });\n        }\n        return lines;\n    };\n    Lines.prototype.lockIndentTail = function () {\n        if (this.length < 2) {\n            return this;\n        }\n        return new Lines(this.infos.map(function (info, i) { return (tslib_1.__assign(tslib_1.__assign({}, info), { locked: i > 0 })); }));\n    };\n    Lines.prototype.getIndentAt = function (line) {\n        assert_1.default.ok(line >= 1, \"no line \" + line + \" (line numbers start from 1)\");\n        return Math.max(this.infos[line - 1].indent, 0);\n    };\n    Lines.prototype.guessTabWidth = function () {\n        if (typeof this.cachedTabWidth === \"number\") {\n            return this.cachedTabWidth;\n        }\n        var counts = []; // Sparse array.\n        var lastIndent = 0;\n        for (var line = 1, last = this.length; line <= last; ++line) {\n            var info = this.infos[line - 1];\n            var sliced = info.line.slice(info.sliceStart, info.sliceEnd);\n            // Whitespace-only lines don't tell us much about the likely tab\n            // width of this code.\n            if (isOnlyWhitespace(sliced)) {\n                continue;\n            }\n            var diff = Math.abs(info.indent - lastIndent);\n            counts[diff] = ~~counts[diff] + 1;\n            lastIndent = info.indent;\n        }\n        var maxCount = -1;\n        var result = 2;\n        for (var tabWidth = 1; tabWidth < counts.length; tabWidth += 1) {\n            if (hasOwn.call(counts, tabWidth) && counts[tabWidth] > maxCount) {\n                maxCount = counts[tabWidth];\n                result = tabWidth;\n            }\n        }\n        return (this.cachedTabWidth = result);\n    };\n    // Determine if the list of lines has a first line that starts with a //\n    // or /* comment. If this is the case, the code may need to be wrapped in\n    // parens to avoid ASI issues.\n    Lines.prototype.startsWithComment = function () {\n        if (this.infos.length === 0) {\n            return false;\n        }\n        var firstLineInfo = this.infos[0], sliceStart = firstLineInfo.sliceStart, sliceEnd = firstLineInfo.sliceEnd, firstLine = firstLineInfo.line.slice(sliceStart, sliceEnd).trim();\n        return (firstLine.length === 0 ||\n            firstLine.slice(0, 2) === \"//\" ||\n            firstLine.slice(0, 2) === \"/*\");\n    };\n    Lines.prototype.isOnlyWhitespace = function () {\n        return isOnlyWhitespace(this.toString());\n    };\n    Lines.prototype.isPrecededOnlyByWhitespace = function (pos) {\n        var info = this.infos[pos.line - 1];\n        var indent = Math.max(info.indent, 0);\n        var diff = pos.column - indent;\n        if (diff <= 0) {\n            // If pos.column does not exceed the indentation amount, then\n            // there must be only whitespace before it.\n            return true;\n        }\n        var start = info.sliceStart;\n        var end = Math.min(start + diff, info.sliceEnd);\n        var prefix = info.line.slice(start, end);\n        return isOnlyWhitespace(prefix);\n    };\n    Lines.prototype.getLineLength = function (line) {\n        var info = this.infos[line - 1];\n        return this.getIndentAt(line) + info.sliceEnd - info.sliceStart;\n    };\n    Lines.prototype.nextPos = function (pos, skipSpaces) {\n        if (skipSpaces === void 0) { skipSpaces = false; }\n        var l = Math.max(pos.line, 0), c = Math.max(pos.column, 0);\n        if (c < this.getLineLength(l)) {\n            pos.column += 1;\n            return skipSpaces ? !!this.skipSpaces(pos, false, true) : true;\n        }\n        if (l < this.length) {\n            pos.line += 1;\n            pos.column = 0;\n            return skipSpaces ? !!this.skipSpaces(pos, false, true) : true;\n        }\n        return false;\n    };\n    Lines.prototype.prevPos = function (pos, skipSpaces) {\n        if (skipSpaces === void 0) { skipSpaces = false; }\n        var l = pos.line, c = pos.column;\n        if (c < 1) {\n            l -= 1;\n            if (l < 1)\n                return false;\n            c = this.getLineLength(l);\n        }\n        else {\n            c = Math.min(c - 1, this.getLineLength(l));\n        }\n        pos.line = l;\n        pos.column = c;\n        return skipSpaces ? !!this.skipSpaces(pos, true, true) : true;\n    };\n    Lines.prototype.firstPos = function () {\n        // Trivial, but provided for completeness.\n        return { line: 1, column: 0 };\n    };\n    Lines.prototype.lastPos = function () {\n        return {\n            line: this.length,\n            column: this.getLineLength(this.length),\n        };\n    };\n    Lines.prototype.skipSpaces = function (pos, backward, modifyInPlace) {\n        if (backward === void 0) { backward = false; }\n        if (modifyInPlace === void 0) { modifyInPlace = false; }\n        if (pos) {\n            pos = modifyInPlace\n                ? pos\n                : {\n                    line: pos.line,\n                    column: pos.column,\n                };\n        }\n        else if (backward) {\n            pos = this.lastPos();\n        }\n        else {\n            pos = this.firstPos();\n        }\n        if (backward) {\n            while (this.prevPos(pos)) {\n                if (!isOnlyWhitespace(this.charAt(pos)) && this.nextPos(pos)) {\n                    return pos;\n                }\n            }\n            return null;\n        }\n        else {\n            while (isOnlyWhitespace(this.charAt(pos))) {\n                if (!this.nextPos(pos)) {\n                    return null;\n                }\n            }\n            return pos;\n        }\n    };\n    Lines.prototype.trimLeft = function () {\n        var pos = this.skipSpaces(this.firstPos(), false, true);\n        return pos ? this.slice(pos) : emptyLines;\n    };\n    Lines.prototype.trimRight = function () {\n        var pos = this.skipSpaces(this.lastPos(), true, true);\n        return pos ? this.slice(this.firstPos(), pos) : emptyLines;\n    };\n    Lines.prototype.trim = function () {\n        var start = this.skipSpaces(this.firstPos(), false, true);\n        if (start === null) {\n            return emptyLines;\n        }\n        var end = this.skipSpaces(this.lastPos(), true, true);\n        if (end === null) {\n            return emptyLines;\n        }\n        return this.slice(start, end);\n    };\n    Lines.prototype.eachPos = function (callback, startPos, skipSpaces) {\n        if (startPos === void 0) { startPos = this.firstPos(); }\n        if (skipSpaces === void 0) { skipSpaces = false; }\n        var pos = this.firstPos();\n        if (startPos) {\n            (pos.line = startPos.line), (pos.column = startPos.column);\n        }\n        if (skipSpaces && !this.skipSpaces(pos, false, true)) {\n            return; // Encountered nothing but spaces.\n        }\n        do\n            callback.call(this, pos);\n        while (this.nextPos(pos, skipSpaces));\n    };\n    Lines.prototype.bootstrapSlice = function (start, end) {\n        var strings = this.toString()\n            .split(lineTerminatorSeqExp)\n            .slice(start.line - 1, end.line);\n        if (strings.length > 0) {\n            strings.push(strings.pop().slice(0, end.column));\n            strings[0] = strings[0].slice(start.column);\n        }\n        return fromString(strings.join(\"\\n\"));\n    };\n    Lines.prototype.slice = function (start, end) {\n        if (!end) {\n            if (!start) {\n                // The client seems to want a copy of this Lines object, but\n                // Lines objects are immutable, so it's perfectly adequate to\n                // return the same object.\n                return this;\n            }\n            // Slice to the end if no end position was provided.\n            end = this.lastPos();\n        }\n        if (!start) {\n            throw new Error(\"cannot slice with end but not start\");\n        }\n        var sliced = this.infos.slice(start.line - 1, end.line);\n        if (start.line === end.line) {\n            sliced[0] = sliceInfo(sliced[0], start.column, end.column);\n        }\n        else {\n            assert_1.default.ok(start.line < end.line);\n            sliced[0] = sliceInfo(sliced[0], start.column);\n            sliced.push(sliceInfo(sliced.pop(), 0, end.column));\n        }\n        var lines = new Lines(sliced);\n        if (this.mappings.length > 0) {\n            var newMappings_4 = lines.mappings;\n            assert_1.default.strictEqual(newMappings_4.length, 0);\n            this.mappings.forEach(function (mapping) {\n                var sliced = mapping.slice(this, start, end);\n                if (sliced) {\n                    newMappings_4.push(sliced);\n                }\n            }, this);\n        }\n        return lines;\n    };\n    Lines.prototype.bootstrapSliceString = function (start, end, options) {\n        return this.slice(start, end).toString(options);\n    };\n    Lines.prototype.sliceString = function (start, end, options) {\n        if (start === void 0) { start = this.firstPos(); }\n        if (end === void 0) { end = this.lastPos(); }\n        var _a = options_1.normalize(options), tabWidth = _a.tabWidth, useTabs = _a.useTabs, reuseWhitespace = _a.reuseWhitespace, lineTerminator = _a.lineTerminator;\n        var parts = [];\n        for (var line = start.line; line <= end.line; ++line) {\n            var info = this.infos[line - 1];\n            if (line === start.line) {\n                if (line === end.line) {\n                    info = sliceInfo(info, start.column, end.column);\n                }\n                else {\n                    info = sliceInfo(info, start.column);\n                }\n            }\n            else if (line === end.line) {\n                info = sliceInfo(info, 0, end.column);\n            }\n            var indent = Math.max(info.indent, 0);\n            var before_1 = info.line.slice(0, info.sliceStart);\n            if (reuseWhitespace &&\n                isOnlyWhitespace(before_1) &&\n                countSpaces(before_1, tabWidth) === indent) {\n                // Reuse original spaces if the indentation is correct.\n                parts.push(info.line.slice(0, info.sliceEnd));\n                continue;\n            }\n            var tabs = 0;\n            var spaces = indent;\n            if (useTabs) {\n                tabs = Math.floor(indent / tabWidth);\n                spaces -= tabs * tabWidth;\n            }\n            var result = \"\";\n            if (tabs > 0) {\n                result += new Array(tabs + 1).join(\"\\t\");\n            }\n            if (spaces > 0) {\n                result += new Array(spaces + 1).join(\" \");\n            }\n            result += info.line.slice(info.sliceStart, info.sliceEnd);\n            parts.push(result);\n        }\n        return parts.join(lineTerminator);\n    };\n    Lines.prototype.isEmpty = function () {\n        return this.length < 2 && this.getLineLength(1) < 1;\n    };\n    Lines.prototype.join = function (elements) {\n        var separator = this;\n        var infos = [];\n        var mappings = [];\n        var prevInfo;\n        function appendLines(linesOrNull) {\n            if (linesOrNull === null) {\n                return;\n            }\n            if (prevInfo) {\n                var info = linesOrNull.infos[0];\n                var indent = new Array(info.indent + 1).join(\" \");\n                var prevLine_1 = infos.length;\n                var prevColumn_1 = Math.max(prevInfo.indent, 0) +\n                    prevInfo.sliceEnd -\n                    prevInfo.sliceStart;\n                prevInfo.line =\n                    prevInfo.line.slice(0, prevInfo.sliceEnd) +\n                        indent +\n                        info.line.slice(info.sliceStart, info.sliceEnd);\n                // If any part of a line is indentation-locked, the whole line\n                // will be indentation-locked.\n                prevInfo.locked = prevInfo.locked || info.locked;\n                prevInfo.sliceEnd = prevInfo.line.length;\n                if (linesOrNull.mappings.length > 0) {\n                    linesOrNull.mappings.forEach(function (mapping) {\n                        mappings.push(mapping.add(prevLine_1, prevColumn_1));\n                    });\n                }\n            }\n            else if (linesOrNull.mappings.length > 0) {\n                mappings.push.apply(mappings, linesOrNull.mappings);\n            }\n            linesOrNull.infos.forEach(function (info, i) {\n                if (!prevInfo || i > 0) {\n                    prevInfo = tslib_1.__assign({}, info);\n                    infos.push(prevInfo);\n                }\n            });\n        }\n        function appendWithSeparator(linesOrNull, i) {\n            if (i > 0)\n                appendLines(separator);\n            appendLines(linesOrNull);\n        }\n        elements\n            .map(function (elem) {\n            var lines = fromString(elem);\n            if (lines.isEmpty())\n                return null;\n            return lines;\n        })\n            .forEach(function (linesOrNull, i) {\n            if (separator.isEmpty()) {\n                appendLines(linesOrNull);\n            }\n            else {\n                appendWithSeparator(linesOrNull, i);\n            }\n        });\n        if (infos.length < 1)\n            return emptyLines;\n        var lines = new Lines(infos);\n        lines.mappings = mappings;\n        return lines;\n    };\n    Lines.prototype.concat = function () {\n        var args = [];\n        for (var _i = 0; _i < arguments.length; _i++) {\n            args[_i] = arguments[_i];\n        }\n        var list = [this];\n        list.push.apply(list, args);\n        assert_1.default.strictEqual(list.length, args.length + 1);\n        return emptyLines.join(list);\n    };\n    return Lines;\n}());\nexports.Lines = Lines;\nvar fromStringCache = {};\nvar hasOwn = fromStringCache.hasOwnProperty;\nvar maxCacheKeyLen = 10;\nfunction countSpaces(spaces, tabWidth) {\n    var count = 0;\n    var len = spaces.length;\n    for (var i = 0; i < len; ++i) {\n        switch (spaces.charCodeAt(i)) {\n            case 9: {\n                // '\\t'\n                assert_1.default.strictEqual(typeof tabWidth, \"number\");\n                assert_1.default.ok(tabWidth > 0);\n                var next = Math.ceil(count / tabWidth) * tabWidth;\n                if (next === count) {\n                    count += tabWidth;\n                }\n                else {\n                    count = next;\n                }\n                break;\n            }\n            case 11: // '\\v'\n            case 12: // '\\f'\n            case 13: // '\\r'\n            case 0xfeff: // zero-width non-breaking space\n                // These characters contribute nothing to indentation.\n                break;\n            case 32: // ' '\n            default:\n                // Treat all other whitespace like ' '.\n                count += 1;\n                break;\n        }\n    }\n    return count;\n}\nexports.countSpaces = countSpaces;\nvar leadingSpaceExp = /^\\s*/;\n// As specified here: http://www.ecma-international.org/ecma-262/6.0/#sec-line-terminators\nvar lineTerminatorSeqExp = /\\u000D\\u000A|\\u000D(?!\\u000A)|\\u000A|\\u2028|\\u2029/;\n/**\n * @param {Object} options - Options object that configures printing.\n */\nfunction fromString(string, options) {\n    if (string instanceof Lines)\n        return string;\n    string += \"\";\n    var tabWidth = options && options.tabWidth;\n    var tabless = string.indexOf(\"\\t\") < 0;\n    var cacheable = !options && tabless && string.length <= maxCacheKeyLen;\n    assert_1.default.ok(tabWidth || tabless, \"No tab width specified but encountered tabs in string\\n\" + string);\n    if (cacheable && hasOwn.call(fromStringCache, string))\n        return fromStringCache[string];\n    var lines = new Lines(string.split(lineTerminatorSeqExp).map(function (line) {\n        // TODO: handle null exec result\n        var spaces = leadingSpaceExp.exec(line)[0];\n        return {\n            line: line,\n            indent: countSpaces(spaces, tabWidth),\n            // Boolean indicating whether this line can be reindented.\n            locked: false,\n            sliceStart: spaces.length,\n            sliceEnd: line.length,\n        };\n    }), options_1.normalize(options).sourceFileName);\n    if (cacheable)\n        fromStringCache[string] = lines;\n    return lines;\n}\nexports.fromString = fromString;\nfunction isOnlyWhitespace(string) {\n    return !/\\S/.test(string);\n}\nfunction sliceInfo(info, startCol, endCol) {\n    var sliceStart = info.sliceStart;\n    var sliceEnd = info.sliceEnd;\n    var indent = Math.max(info.indent, 0);\n    var lineLength = indent + sliceEnd - sliceStart;\n    if (typeof endCol === \"undefined\") {\n        endCol = lineLength;\n    }\n    startCol = Math.max(startCol, 0);\n    endCol = Math.min(endCol, lineLength);\n    endCol = Math.max(endCol, startCol);\n    if (endCol < indent) {\n        indent = endCol;\n        sliceEnd = sliceStart;\n    }\n    else {\n        sliceEnd -= lineLength - endCol;\n    }\n    lineLength = endCol;\n    lineLength -= startCol;\n    if (startCol < indent) {\n        indent -= startCol;\n    }\n    else {\n        startCol -= indent;\n        indent = 0;\n        sliceStart += startCol;\n    }\n    assert_1.default.ok(indent >= 0);\n    assert_1.default.ok(sliceStart <= sliceEnd);\n    assert_1.default.strictEqual(lineLength, indent + sliceEnd - sliceStart);\n    if (info.indent === indent &&\n        info.sliceStart === sliceStart &&\n        info.sliceEnd === sliceEnd) {\n        return info;\n    }\n    return {\n        line: info.line,\n        indent: indent,\n        // A destructive slice always unlocks indentation.\n        locked: false,\n        sliceStart: sliceStart,\n        sliceEnd: sliceEnd,\n    };\n}\nfunction concat(elements) {\n    return emptyLines.join(elements);\n}\nexports.concat = concat;\n// The emptyLines object needs to be created all the way down here so that\n// Lines.prototype will be fully populated.\nvar emptyLines = fromString(\"\");\n"],"mappings":"AAAA,YAAY;;AACZA,MAAM,CAACC,cAAc,CAACC,OAAO,EAAE,YAAY,EAAE;EAAEC,KAAK,EAAE;AAAK,CAAC,CAAC;AAC7DD,OAAO,CAACE,MAAM,GAAGF,OAAO,CAACG,UAAU,GAAGH,OAAO,CAACI,WAAW,GAAGJ,OAAO,CAACK,KAAK,GAAG,KAAK,CAAC;AAClF,IAAIC,OAAO,GAAGC,OAAO,CAAC,OAAO,CAAC;AAC9B,IAAIC,QAAQ,GAAGF,OAAO,CAACG,eAAe,CAACF,OAAO,CAAC,QAAQ,CAAC,CAAC;AACzD,IAAIG,YAAY,GAAGJ,OAAO,CAACG,eAAe,CAACF,OAAO,CAAC,YAAY,CAAC,CAAC;AACjE,IAAII,SAAS,GAAGJ,OAAO,CAAC,WAAW,CAAC;AACpC,IAAIK,MAAM,GAAGL,OAAO,CAAC,QAAQ,CAAC;AAC9B,IAAIM,SAAS,GAAGP,OAAO,CAACG,eAAe,CAACF,OAAO,CAAC,WAAW,CAAC,CAAC;AAC7D,IAAIF,KAAK,GAAG,aAAe,YAAY;EACnC,SAASA,KAAKA,CAACS,KAAK,EAAEC,cAAc,EAAE;IAClC,IAAIA,cAAc,KAAK,KAAK,CAAC,EAAE;MAAEA,cAAc,GAAG,IAAI;IAAE;IACxD,IAAI,CAACD,KAAK,GAAGA,KAAK;IAClB,IAAI,CAACE,QAAQ,GAAG,EAAE;IAClB,IAAI,CAACC,eAAe,GAAG,IAAI;IAC3B,IAAI,CAACC,cAAc,GAAG,KAAK,CAAC;IAC5BV,QAAQ,CAACW,OAAO,CAACC,EAAE,CAACN,KAAK,CAACO,MAAM,GAAG,CAAC,CAAC;IACrC,IAAI,CAACA,MAAM,GAAGP,KAAK,CAACO,MAAM;IAC1B,IAAI,CAACC,IAAI,GAAGP,cAAc,IAAI,IAAI;IAClC,IAAI,IAAI,CAACO,IAAI,EAAE;MACX,IAAI,CAACN,QAAQ,CAACO,IAAI,CAAC,IAAIV,SAAS,CAACM,OAAO,CAAC,IAAI,EAAE;QAC3CK,KAAK,EAAE,IAAI,CAACC,QAAQ,CAAC,CAAC;QACtBC,GAAG,EAAE,IAAI,CAACC,OAAO,CAAC;MACtB,CAAC,CAAC,CAAC;IACP;EACJ;EACAtB,KAAK,CAACuB,SAAS,CAACC,QAAQ,GAAG,UAAUC,OAAO,EAAE;IAC1C,OAAO,IAAI,CAACC,WAAW,CAAC,IAAI,CAACN,QAAQ,CAAC,CAAC,EAAE,IAAI,CAACE,OAAO,CAAC,CAAC,EAAEG,OAAO,CAAC;EACrE,CAAC;EACDzB,KAAK,CAACuB,SAAS,CAACI,YAAY,GAAG,UAAUC,aAAa,EAAEC,UAAU,EAAE;IAChE,IAAI,CAACD,aAAa,EAAE;MAChB;MACA;MACA;MACA,OAAO,IAAI;IACf;IACA,IAAIE,WAAW,GAAG,IAAI;IACtB,SAASC,UAAUA,CAACC,IAAI,EAAE;MACtBA,IAAI,GAAGA,IAAI,IAAI,CAAC,CAAC;MACjBA,IAAI,CAACC,IAAI,GAAGL,aAAa;MACzB,IAAIC,UAAU,EAAE;QACZG,IAAI,CAACH,UAAU,GAAGA,UAAU;MAChC;MACA,OAAOG,IAAI;IACf;IACA,IAAIF,WAAW,CAAClB,eAAe,EAAE;MAC7B;MACA;MACA;MACA;MACA,OAAOmB,UAAU,CAACD,WAAW,CAAClB,eAAe,CAACsB,MAAM,CAAC,CAAC,CAAC;IAC3D;IACA,IAAIC,GAAG,GAAG,IAAI9B,YAAY,CAACS,OAAO,CAACsB,kBAAkB,CAACL,UAAU,CAAC,CAAC,CAAC;IACnE,IAAIM,iBAAiB,GAAG,CAAC,CAAC;IAC1BP,WAAW,CAACnB,QAAQ,CAAC2B,OAAO,CAAC,UAAUC,OAAO,EAAE;MAC5C,IAAIC,YAAY,GAAGD,OAAO,CAACE,WAAW,CAACC,UAAU,CAACH,OAAO,CAACI,SAAS,CAACxB,KAAK,CAAC,IACtEoB,OAAO,CAACE,WAAW,CAACnB,OAAO,CAAC,CAAC;MACjC,IAAIsB,YAAY,GAAGd,WAAW,CAACY,UAAU,CAACH,OAAO,CAACM,SAAS,CAAC1B,KAAK,CAAC,IAC9DW,WAAW,CAACR,OAAO,CAAC,CAAC;MACzB,OAAOf,MAAM,CAACuC,UAAU,CAACN,YAAY,EAAED,OAAO,CAACI,SAAS,CAACtB,GAAG,CAAC,GAAG,CAAC,IAC7Dd,MAAM,CAACuC,UAAU,CAACF,YAAY,EAAEL,OAAO,CAACM,SAAS,CAACxB,GAAG,CAAC,GAAG,CAAC,EAAE;QAC5D,IAAI0B,UAAU,GAAGR,OAAO,CAACE,WAAW,CAACO,MAAM,CAACR,YAAY,CAAC;QACzD,IAAIS,UAAU,GAAGnB,WAAW,CAACkB,MAAM,CAACJ,YAAY,CAAC;QACjDzC,QAAQ,CAACW,OAAO,CAACoC,WAAW,CAACH,UAAU,EAAEE,UAAU,CAAC;QACpD,IAAIE,UAAU,GAAGZ,OAAO,CAACE,WAAW,CAACxB,IAAI;QACzC;QACAkB,GAAG,CAACiB,UAAU,CAAC;UACXC,MAAM,EAAEF,UAAU;UAClBG,QAAQ,EAAE;YAAEC,IAAI,EAAEf,YAAY,CAACe,IAAI;YAAEC,MAAM,EAAEhB,YAAY,CAACgB;UAAO,CAAC;UAClEC,SAAS,EAAE;YAAEF,IAAI,EAAEX,YAAY,CAACW,IAAI;YAAEC,MAAM,EAAEZ,YAAY,CAACY;UAAO;QACtE,CAAC,CAAC;QACF,IAAI,CAACE,MAAM,CAACC,IAAI,CAACtB,iBAAiB,EAAEc,UAAU,CAAC,EAAE;UAC7C,IAAIS,aAAa,GAAGrB,OAAO,CAACE,WAAW,CAACjB,QAAQ,CAAC,CAAC;UAClDW,GAAG,CAAC0B,gBAAgB,CAACV,UAAU,EAAES,aAAa,CAAC;UAC/CvB,iBAAiB,CAACc,UAAU,CAAC,GAAGS,aAAa;QACjD;QACA9B,WAAW,CAACgC,OAAO,CAAClB,YAAY,EAAE,IAAI,CAAC;QACvCL,OAAO,CAACE,WAAW,CAACqB,OAAO,CAACtB,YAAY,EAAE,IAAI,CAAC;MACnD;IACJ,CAAC,CAAC;IACFV,WAAW,CAAClB,eAAe,GAAGuB,GAAG;IACjC,OAAOA,GAAG,CAACD,MAAM,CAAC,CAAC;EACvB,CAAC;EACDlC,KAAK,CAACuB,SAAS,CAACwC,eAAe,GAAG,UAAUC,GAAG,EAAE;IAC7C7D,QAAQ,CAACW,OAAO,CAACoC,WAAW,CAAC,OAAOc,GAAG,EAAE,QAAQ,CAAC;IAClD7D,QAAQ,CAACW,OAAO,CAACoC,WAAW,CAAC,OAAOc,GAAG,CAACT,IAAI,EAAE,QAAQ,CAAC;IACvDpD,QAAQ,CAACW,OAAO,CAACoC,WAAW,CAAC,OAAOc,GAAG,CAACR,MAAM,EAAE,QAAQ,CAAC;IACzD,IAAID,IAAI,GAAGS,GAAG,CAACT,IAAI;MAAEC,MAAM,GAAGQ,GAAG,CAACR,MAAM;MAAES,OAAO,GAAG,IAAI,CAACzC,QAAQ,CAAC,CAAC,CAAC0C,KAAK,CAACC,oBAAoB,CAAC;MAAEC,MAAM,GAAGH,OAAO,CAACV,IAAI,GAAG,CAAC,CAAC;IAC3H,IAAI,OAAOa,MAAM,KAAK,WAAW,EAC7B,OAAO,EAAE;IACb,IAAIZ,MAAM,KAAKY,MAAM,CAACpD,MAAM,IAAIuC,IAAI,GAAGU,OAAO,CAACjD,MAAM,EACjD,OAAO,IAAI;IACf,IAAIwC,MAAM,IAAIY,MAAM,CAACpD,MAAM,EACvB,OAAO,EAAE;IACb,OAAOoD,MAAM,CAACpB,MAAM,CAACQ,MAAM,CAAC;EAChC,CAAC;EACDxD,KAAK,CAACuB,SAAS,CAACyB,MAAM,GAAG,UAAUgB,GAAG,EAAE;IACpC7D,QAAQ,CAACW,OAAO,CAACoC,WAAW,CAAC,OAAOc,GAAG,EAAE,QAAQ,CAAC;IAClD7D,QAAQ,CAACW,OAAO,CAACoC,WAAW,CAAC,OAAOc,GAAG,CAACT,IAAI,EAAE,QAAQ,CAAC;IACvDpD,QAAQ,CAACW,OAAO,CAACoC,WAAW,CAAC,OAAOc,GAAG,CAACR,MAAM,EAAE,QAAQ,CAAC;IACzD,IAAID,IAAI,GAAGS,GAAG,CAACT,IAAI;MAAEC,MAAM,GAAGQ,GAAG,CAACR,MAAM;MAAEa,MAAM,GAAG,IAAI;MAAE5D,KAAK,GAAG4D,MAAM,CAAC5D,KAAK;MAAE6D,IAAI,GAAG7D,KAAK,CAAC8C,IAAI,GAAG,CAAC,CAAC;MAAEgB,CAAC,GAAGf,MAAM;IACjH,IAAI,OAAOc,IAAI,KAAK,WAAW,IAAIC,CAAC,GAAG,CAAC,EACpC,OAAO,EAAE;IACb,IAAIC,MAAM,GAAG,IAAI,CAACC,WAAW,CAAClB,IAAI,CAAC;IACnC,IAAIgB,CAAC,GAAGC,MAAM,EACV,OAAO,GAAG;IACdD,CAAC,IAAID,IAAI,CAACI,UAAU,GAAGF,MAAM;IAC7B,IAAID,CAAC,KAAKD,IAAI,CAACK,QAAQ,IAAIpB,IAAI,GAAG,IAAI,CAACvC,MAAM,EACzC,OAAO,IAAI;IACf,IAAIuD,CAAC,IAAID,IAAI,CAACK,QAAQ,EAClB,OAAO,EAAE;IACb,OAAOL,IAAI,CAACf,IAAI,CAACP,MAAM,CAACuB,CAAC,CAAC;EAC9B,CAAC;EACDvE,KAAK,CAACuB,SAAS,CAACqD,WAAW,GAAG,UAAUC,KAAK,EAAEC,aAAa,EAAE;IAC1D,IAAID,KAAK,KAAK,CAAC,EACX,OAAO,IAAI;IACf1E,QAAQ,CAACW,OAAO,CAACC,EAAE,CAAC8D,KAAK,GAAG,CAAC,EAAE,mBAAmB,GAAGA,KAAK,CAAC;IAC3D,IAAIC,aAAa,IAAI,IAAI,CAAC9D,MAAM,KAAK,CAAC,EAClC,OAAO,IAAI;IACf,IAAI+D,KAAK,GAAG,IAAI/E,KAAK,CAAC,IAAI,CAACS,KAAK,CAACuE,GAAG,CAAC,UAAUV,IAAI,EAAEW,CAAC,EAAE;MACpD,IAAIX,IAAI,CAACf,IAAI,KAAK0B,CAAC,GAAG,CAAC,IAAI,CAACH,aAAa,CAAC,EAAE;QACxCR,IAAI,GAAGrE,OAAO,CAACiF,QAAQ,CAACjF,OAAO,CAACiF,QAAQ,CAAC,CAAC,CAAC,EAAEZ,IAAI,CAAC,EAAE;UAAEE,MAAM,EAAEW,IAAI,CAACC,GAAG,CAAC,CAAC,EAAEd,IAAI,CAACE,MAAM,GAAGK,KAAK;QAAE,CAAC,CAAC;MACrG;MACA,OAAOP,IAAI;IACf,CAAC,CAAC,CAAC;IACH,IAAI,IAAI,CAAC3D,QAAQ,CAACK,MAAM,GAAG,CAAC,EAAE;MAC1B,IAAIqE,aAAa,GAAGN,KAAK,CAACpE,QAAQ;MAClCR,QAAQ,CAACW,OAAO,CAACoC,WAAW,CAACmC,aAAa,CAACrE,MAAM,EAAE,CAAC,CAAC;MACrD,IAAI,CAACL,QAAQ,CAAC2B,OAAO,CAAC,UAAUC,OAAO,EAAE;QACrC8C,aAAa,CAACnE,IAAI,CAACqB,OAAO,CAACiC,MAAM,CAACK,KAAK,EAAEC,aAAa,EAAE,IAAI,CAAC,CAAC;MAClE,CAAC,CAAC;IACN;IACA,OAAOC,KAAK;EAChB,CAAC;EACD/E,KAAK,CAACuB,SAAS,CAACiD,MAAM,GAAG,UAAUc,EAAE,EAAE;IACnC,IAAIA,EAAE,KAAK,CAAC,EAAE;MACV,OAAO,IAAI;IACf;IACA,IAAIP,KAAK,GAAG,IAAI/E,KAAK,CAAC,IAAI,CAACS,KAAK,CAACuE,GAAG,CAAC,UAAUV,IAAI,EAAE;MACjD,IAAIA,IAAI,CAACf,IAAI,IAAI,CAACe,IAAI,CAACiB,MAAM,EAAE;QAC3BjB,IAAI,GAAGrE,OAAO,CAACiF,QAAQ,CAACjF,OAAO,CAACiF,QAAQ,CAAC,CAAC,CAAC,EAAEZ,IAAI,CAAC,EAAE;UAAEE,MAAM,EAAEF,IAAI,CAACE,MAAM,GAAGc;QAAG,CAAC,CAAC;MACrF;MACA,OAAOhB,IAAI;IACf,CAAC,CAAC,CAAC;IACH,IAAI,IAAI,CAAC3D,QAAQ,CAACK,MAAM,GAAG,CAAC,EAAE;MAC1B,IAAIwE,aAAa,GAAGT,KAAK,CAACpE,QAAQ;MAClCR,QAAQ,CAACW,OAAO,CAACoC,WAAW,CAACsC,aAAa,CAACxE,MAAM,EAAE,CAAC,CAAC;MACrD,IAAI,CAACL,QAAQ,CAAC2B,OAAO,CAAC,UAAUC,OAAO,EAAE;QACrCiD,aAAa,CAACtE,IAAI,CAACqB,OAAO,CAACiC,MAAM,CAACc,EAAE,CAAC,CAAC;MAC1C,CAAC,CAAC;IACN;IACA,OAAOP,KAAK;EAChB,CAAC;EACD/E,KAAK,CAACuB,SAAS,CAACkE,UAAU,GAAG,UAAUH,EAAE,EAAE;IACvC,IAAIA,EAAE,KAAK,CAAC,EAAE;MACV,OAAO,IAAI;IACf;IACA,IAAI,IAAI,CAACtE,MAAM,GAAG,CAAC,EAAE;MACjB,OAAO,IAAI;IACf;IACA,IAAI+D,KAAK,GAAG,IAAI/E,KAAK,CAAC,IAAI,CAACS,KAAK,CAACuE,GAAG,CAAC,UAAUV,IAAI,EAAEW,CAAC,EAAE;MACpD,IAAIA,CAAC,GAAG,CAAC,IAAIX,IAAI,CAACf,IAAI,IAAI,CAACe,IAAI,CAACiB,MAAM,EAAE;QACpCjB,IAAI,GAAGrE,OAAO,CAACiF,QAAQ,CAACjF,OAAO,CAACiF,QAAQ,CAAC,CAAC,CAAC,EAAEZ,IAAI,CAAC,EAAE;UAAEE,MAAM,EAAEF,IAAI,CAACE,MAAM,GAAGc;QAAG,CAAC,CAAC;MACrF;MACA,OAAOhB,IAAI;IACf,CAAC,CAAC,CAAC;IACH,IAAI,IAAI,CAAC3D,QAAQ,CAACK,MAAM,GAAG,CAAC,EAAE;MAC1B,IAAI0E,aAAa,GAAGX,KAAK,CAACpE,QAAQ;MAClCR,QAAQ,CAACW,OAAO,CAACoC,WAAW,CAACwC,aAAa,CAAC1E,MAAM,EAAE,CAAC,CAAC;MACrD,IAAI,CAACL,QAAQ,CAAC2B,OAAO,CAAC,UAAUC,OAAO,EAAE;QACrCmD,aAAa,CAACxE,IAAI,CAACqB,OAAO,CAACiC,MAAM,CAACc,EAAE,EAAE,IAAI,CAAC,CAAC;MAChD,CAAC,CAAC;IACN;IACA,OAAOP,KAAK;EAChB,CAAC;EACD/E,KAAK,CAACuB,SAAS,CAACoE,cAAc,GAAG,YAAY;IACzC,IAAI,IAAI,CAAC3E,MAAM,GAAG,CAAC,EAAE;MACjB,OAAO,IAAI;IACf;IACA,OAAO,IAAIhB,KAAK,CAAC,IAAI,CAACS,KAAK,CAACuE,GAAG,CAAC,UAAUV,IAAI,EAAEW,CAAC,EAAE;MAAE,OAAQhF,OAAO,CAACiF,QAAQ,CAACjF,OAAO,CAACiF,QAAQ,CAAC,CAAC,CAAC,EAAEZ,IAAI,CAAC,EAAE;QAAEiB,MAAM,EAAEN,CAAC,GAAG;MAAE,CAAC,CAAC;IAAG,CAAC,CAAC,CAAC;EACtI,CAAC;EACDjF,KAAK,CAACuB,SAAS,CAACkD,WAAW,GAAG,UAAUlB,IAAI,EAAE;IAC1CpD,QAAQ,CAACW,OAAO,CAACC,EAAE,CAACwC,IAAI,IAAI,CAAC,EAAE,UAAU,GAAGA,IAAI,GAAG,8BAA8B,CAAC;IAClF,OAAO4B,IAAI,CAACC,GAAG,CAAC,IAAI,CAAC3E,KAAK,CAAC8C,IAAI,GAAG,CAAC,CAAC,CAACiB,MAAM,EAAE,CAAC,CAAC;EACnD,CAAC;EACDxE,KAAK,CAACuB,SAAS,CAACqE,aAAa,GAAG,YAAY;IACxC,IAAI,OAAO,IAAI,CAAC/E,cAAc,KAAK,QAAQ,EAAE;MACzC,OAAO,IAAI,CAACA,cAAc;IAC9B;IACA,IAAIgF,MAAM,GAAG,EAAE,CAAC,CAAC;IACjB,IAAIC,UAAU,GAAG,CAAC;IAClB,KAAK,IAAIvC,IAAI,GAAG,CAAC,EAAEwC,IAAI,GAAG,IAAI,CAAC/E,MAAM,EAAEuC,IAAI,IAAIwC,IAAI,EAAE,EAAExC,IAAI,EAAE;MACzD,IAAIe,IAAI,GAAG,IAAI,CAAC7D,KAAK,CAAC8C,IAAI,GAAG,CAAC,CAAC;MAC/B,IAAIyC,MAAM,GAAG1B,IAAI,CAACf,IAAI,CAAC0C,KAAK,CAAC3B,IAAI,CAACI,UAAU,EAAEJ,IAAI,CAACK,QAAQ,CAAC;MAC5D;MACA;MACA,IAAIuB,gBAAgB,CAACF,MAAM,CAAC,EAAE;QAC1B;MACJ;MACA,IAAIG,IAAI,GAAGhB,IAAI,CAACiB,GAAG,CAAC9B,IAAI,CAACE,MAAM,GAAGsB,UAAU,CAAC;MAC7CD,MAAM,CAACM,IAAI,CAAC,GAAG,CAAC,CAACN,MAAM,CAACM,IAAI,CAAC,GAAG,CAAC;MACjCL,UAAU,GAAGxB,IAAI,CAACE,MAAM;IAC5B;IACA,IAAI6B,QAAQ,GAAG,CAAC,CAAC;IACjB,IAAIC,MAAM,GAAG,CAAC;IACd,KAAK,IAAIC,QAAQ,GAAG,CAAC,EAAEA,QAAQ,GAAGV,MAAM,CAAC7E,MAAM,EAAEuF,QAAQ,IAAI,CAAC,EAAE;MAC5D,IAAI7C,MAAM,CAACC,IAAI,CAACkC,MAAM,EAAEU,QAAQ,CAAC,IAAIV,MAAM,CAACU,QAAQ,CAAC,GAAGF,QAAQ,EAAE;QAC9DA,QAAQ,GAAGR,MAAM,CAACU,QAAQ,CAAC;QAC3BD,MAAM,GAAGC,QAAQ;MACrB;IACJ;IACA,OAAQ,IAAI,CAAC1F,cAAc,GAAGyF,MAAM;EACxC,CAAC;EACD;EACA;EACA;EACAtG,KAAK,CAACuB,SAAS,CAACiF,iBAAiB,GAAG,YAAY;IAC5C,IAAI,IAAI,CAAC/F,KAAK,CAACO,MAAM,KAAK,CAAC,EAAE;MACzB,OAAO,KAAK;IAChB;IACA,IAAIyF,aAAa,GAAG,IAAI,CAAChG,KAAK,CAAC,CAAC,CAAC;MAAEiE,UAAU,GAAG+B,aAAa,CAAC/B,UAAU;MAAEC,QAAQ,GAAG8B,aAAa,CAAC9B,QAAQ;MAAE+B,SAAS,GAAGD,aAAa,CAAClD,IAAI,CAAC0C,KAAK,CAACvB,UAAU,EAAEC,QAAQ,CAAC,CAACgC,IAAI,CAAC,CAAC;IAC9K,OAAQD,SAAS,CAAC1F,MAAM,KAAK,CAAC,IAC1B0F,SAAS,CAACT,KAAK,CAAC,CAAC,EAAE,CAAC,CAAC,KAAK,IAAI,IAC9BS,SAAS,CAACT,KAAK,CAAC,CAAC,EAAE,CAAC,CAAC,KAAK,IAAI;EACtC,CAAC;EACDjG,KAAK,CAACuB,SAAS,CAAC2E,gBAAgB,GAAG,YAAY;IAC3C,OAAOA,gBAAgB,CAAC,IAAI,CAAC1E,QAAQ,CAAC,CAAC,CAAC;EAC5C,CAAC;EACDxB,KAAK,CAACuB,SAAS,CAACqF,0BAA0B,GAAG,UAAU5C,GAAG,EAAE;IACxD,IAAIM,IAAI,GAAG,IAAI,CAAC7D,KAAK,CAACuD,GAAG,CAACT,IAAI,GAAG,CAAC,CAAC;IACnC,IAAIiB,MAAM,GAAGW,IAAI,CAACC,GAAG,CAACd,IAAI,CAACE,MAAM,EAAE,CAAC,CAAC;IACrC,IAAI2B,IAAI,GAAGnC,GAAG,CAACR,MAAM,GAAGgB,MAAM;IAC9B,IAAI2B,IAAI,IAAI,CAAC,EAAE;MACX;MACA;MACA,OAAO,IAAI;IACf;IACA,IAAIhF,KAAK,GAAGmD,IAAI,CAACI,UAAU;IAC3B,IAAIrD,GAAG,GAAG8D,IAAI,CAAC0B,GAAG,CAAC1F,KAAK,GAAGgF,IAAI,EAAE7B,IAAI,CAACK,QAAQ,CAAC;IAC/C,IAAImC,MAAM,GAAGxC,IAAI,CAACf,IAAI,CAAC0C,KAAK,CAAC9E,KAAK,EAAEE,GAAG,CAAC;IACxC,OAAO6E,gBAAgB,CAACY,MAAM,CAAC;EACnC,CAAC;EACD9G,KAAK,CAACuB,SAAS,CAACwF,aAAa,GAAG,UAAUxD,IAAI,EAAE;IAC5C,IAAIe,IAAI,GAAG,IAAI,CAAC7D,KAAK,CAAC8C,IAAI,GAAG,CAAC,CAAC;IAC/B,OAAO,IAAI,CAACkB,WAAW,CAAClB,IAAI,CAAC,GAAGe,IAAI,CAACK,QAAQ,GAAGL,IAAI,CAACI,UAAU;EACnE,CAAC;EACD1E,KAAK,CAACuB,SAAS,CAACuC,OAAO,GAAG,UAAUE,GAAG,EAAEtB,UAAU,EAAE;IACjD,IAAIA,UAAU,KAAK,KAAK,CAAC,EAAE;MAAEA,UAAU,GAAG,KAAK;IAAE;IACjD,IAAIsE,CAAC,GAAG7B,IAAI,CAACC,GAAG,CAACpB,GAAG,CAACT,IAAI,EAAE,CAAC,CAAC;MAAEgB,CAAC,GAAGY,IAAI,CAACC,GAAG,CAACpB,GAAG,CAACR,MAAM,EAAE,CAAC,CAAC;IAC1D,IAAIe,CAAC,GAAG,IAAI,CAACwC,aAAa,CAACC,CAAC,CAAC,EAAE;MAC3BhD,GAAG,CAACR,MAAM,IAAI,CAAC;MACf,OAAOd,UAAU,GAAG,CAAC,CAAC,IAAI,CAACA,UAAU,CAACsB,GAAG,EAAE,KAAK,EAAE,IAAI,CAAC,GAAG,IAAI;IAClE;IACA,IAAIgD,CAAC,GAAG,IAAI,CAAChG,MAAM,EAAE;MACjBgD,GAAG,CAACT,IAAI,IAAI,CAAC;MACbS,GAAG,CAACR,MAAM,GAAG,CAAC;MACd,OAAOd,UAAU,GAAG,CAAC,CAAC,IAAI,CAACA,UAAU,CAACsB,GAAG,EAAE,KAAK,EAAE,IAAI,CAAC,GAAG,IAAI;IAClE;IACA,OAAO,KAAK;EAChB,CAAC;EACDhE,KAAK,CAACuB,SAAS,CAAC0F,OAAO,GAAG,UAAUjD,GAAG,EAAEtB,UAAU,EAAE;IACjD,IAAIA,UAAU,KAAK,KAAK,CAAC,EAAE;MAAEA,UAAU,GAAG,KAAK;IAAE;IACjD,IAAIsE,CAAC,GAAGhD,GAAG,CAACT,IAAI;MAAEgB,CAAC,GAAGP,GAAG,CAACR,MAAM;IAChC,IAAIe,CAAC,GAAG,CAAC,EAAE;MACPyC,CAAC,IAAI,CAAC;MACN,IAAIA,CAAC,GAAG,CAAC,EACL,OAAO,KAAK;MAChBzC,CAAC,GAAG,IAAI,CAACwC,aAAa,CAACC,CAAC,CAAC;IAC7B,CAAC,MACI;MACDzC,CAAC,GAAGY,IAAI,CAAC0B,GAAG,CAACtC,CAAC,GAAG,CAAC,EAAE,IAAI,CAACwC,aAAa,CAACC,CAAC,CAAC,CAAC;IAC9C;IACAhD,GAAG,CAACT,IAAI,GAAGyD,CAAC;IACZhD,GAAG,CAACR,MAAM,GAAGe,CAAC;IACd,OAAO7B,UAAU,GAAG,CAAC,CAAC,IAAI,CAACA,UAAU,CAACsB,GAAG,EAAE,IAAI,EAAE,IAAI,CAAC,GAAG,IAAI;EACjE,CAAC;EACDhE,KAAK,CAACuB,SAAS,CAACH,QAAQ,GAAG,YAAY;IACnC;IACA,OAAO;MAAEmC,IAAI,EAAE,CAAC;MAAEC,MAAM,EAAE;IAAE,CAAC;EACjC,CAAC;EACDxD,KAAK,CAACuB,SAAS,CAACD,OAAO,GAAG,YAAY;IAClC,OAAO;MACHiC,IAAI,EAAE,IAAI,CAACvC,MAAM;MACjBwC,MAAM,EAAE,IAAI,CAACuD,aAAa,CAAC,IAAI,CAAC/F,MAAM;IAC1C,CAAC;EACL,CAAC;EACDhB,KAAK,CAACuB,SAAS,CAACmB,UAAU,GAAG,UAAUsB,GAAG,EAAEkD,QAAQ,EAAEC,aAAa,EAAE;IACjE,IAAID,QAAQ,KAAK,KAAK,CAAC,EAAE;MAAEA,QAAQ,GAAG,KAAK;IAAE;IAC7C,IAAIC,aAAa,KAAK,KAAK,CAAC,EAAE;MAAEA,aAAa,GAAG,KAAK;IAAE;IACvD,IAAInD,GAAG,EAAE;MACLA,GAAG,GAAGmD,aAAa,GACbnD,GAAG,GACH;QACET,IAAI,EAAES,GAAG,CAACT,IAAI;QACdC,MAAM,EAAEQ,GAAG,CAACR;MAChB,CAAC;IACT,CAAC,MACI,IAAI0D,QAAQ,EAAE;MACflD,GAAG,GAAG,IAAI,CAAC1C,OAAO,CAAC,CAAC;IACxB,CAAC,MACI;MACD0C,GAAG,GAAG,IAAI,CAAC5C,QAAQ,CAAC,CAAC;IACzB;IACA,IAAI8F,QAAQ,EAAE;MACV,OAAO,IAAI,CAACD,OAAO,CAACjD,GAAG,CAAC,EAAE;QACtB,IAAI,CAACkC,gBAAgB,CAAC,IAAI,CAAClD,MAAM,CAACgB,GAAG,CAAC,CAAC,IAAI,IAAI,CAACF,OAAO,CAACE,GAAG,CAAC,EAAE;UAC1D,OAAOA,GAAG;QACd;MACJ;MACA,OAAO,IAAI;IACf,CAAC,MACI;MACD,OAAOkC,gBAAgB,CAAC,IAAI,CAAClD,MAAM,CAACgB,GAAG,CAAC,CAAC,EAAE;QACvC,IAAI,CAAC,IAAI,CAACF,OAAO,CAACE,GAAG,CAAC,EAAE;UACpB,OAAO,IAAI;QACf;MACJ;MACA,OAAOA,GAAG;IACd;EACJ,CAAC;EACDhE,KAAK,CAACuB,SAAS,CAAC6F,QAAQ,GAAG,YAAY;IACnC,IAAIpD,GAAG,GAAG,IAAI,CAACtB,UAAU,CAAC,IAAI,CAACtB,QAAQ,CAAC,CAAC,EAAE,KAAK,EAAE,IAAI,CAAC;IACvD,OAAO4C,GAAG,GAAG,IAAI,CAACiC,KAAK,CAACjC,GAAG,CAAC,GAAGqD,UAAU;EAC7C,CAAC;EACDrH,KAAK,CAACuB,SAAS,CAAC+F,SAAS,GAAG,YAAY;IACpC,IAAItD,GAAG,GAAG,IAAI,CAACtB,UAAU,CAAC,IAAI,CAACpB,OAAO,CAAC,CAAC,EAAE,IAAI,EAAE,IAAI,CAAC;IACrD,OAAO0C,GAAG,GAAG,IAAI,CAACiC,KAAK,CAAC,IAAI,CAAC7E,QAAQ,CAAC,CAAC,EAAE4C,GAAG,CAAC,GAAGqD,UAAU;EAC9D,CAAC;EACDrH,KAAK,CAACuB,SAAS,CAACoF,IAAI,GAAG,YAAY;IAC/B,IAAIxF,KAAK,GAAG,IAAI,CAACuB,UAAU,CAAC,IAAI,CAACtB,QAAQ,CAAC,CAAC,EAAE,KAAK,EAAE,IAAI,CAAC;IACzD,IAAID,KAAK,KAAK,IAAI,EAAE;MAChB,OAAOkG,UAAU;IACrB;IACA,IAAIhG,GAAG,GAAG,IAAI,CAACqB,UAAU,CAAC,IAAI,CAACpB,OAAO,CAAC,CAAC,EAAE,IAAI,EAAE,IAAI,CAAC;IACrD,IAAID,GAAG,KAAK,IAAI,EAAE;MACd,OAAOgG,UAAU;IACrB;IACA,OAAO,IAAI,CAACpB,KAAK,CAAC9E,KAAK,EAAEE,GAAG,CAAC;EACjC,CAAC;EACDrB,KAAK,CAACuB,SAAS,CAACgG,OAAO,GAAG,UAAUC,QAAQ,EAAEC,QAAQ,EAAE/E,UAAU,EAAE;IAChE,IAAI+E,QAAQ,KAAK,KAAK,CAAC,EAAE;MAAEA,QAAQ,GAAG,IAAI,CAACrG,QAAQ,CAAC,CAAC;IAAE;IACvD,IAAIsB,UAAU,KAAK,KAAK,CAAC,EAAE;MAAEA,UAAU,GAAG,KAAK;IAAE;IACjD,IAAIsB,GAAG,GAAG,IAAI,CAAC5C,QAAQ,CAAC,CAAC;IACzB,IAAIqG,QAAQ,EAAE;MACTzD,GAAG,CAACT,IAAI,GAAGkE,QAAQ,CAAClE,IAAI,EAAIS,GAAG,CAACR,MAAM,GAAGiE,QAAQ,CAACjE,MAAO;IAC9D;IACA,IAAId,UAAU,IAAI,CAAC,IAAI,CAACA,UAAU,CAACsB,GAAG,EAAE,KAAK,EAAE,IAAI,CAAC,EAAE;MAClD,OAAO,CAAC;IACZ;;IACA,GACIwD,QAAQ,CAAC7D,IAAI,CAAC,IAAI,EAAEK,GAAG,CAAC,CAAC,QACtB,IAAI,CAACF,OAAO,CAACE,GAAG,EAAEtB,UAAU,CAAC;EACxC,CAAC;EACD1C,KAAK,CAACuB,SAAS,CAACmG,cAAc,GAAG,UAAUvG,KAAK,EAAEE,GAAG,EAAE;IACnD,IAAI4C,OAAO,GAAG,IAAI,CAACzC,QAAQ,CAAC,CAAC,CACxB0C,KAAK,CAACC,oBAAoB,CAAC,CAC3B8B,KAAK,CAAC9E,KAAK,CAACoC,IAAI,GAAG,CAAC,EAAElC,GAAG,CAACkC,IAAI,CAAC;IACpC,IAAIU,OAAO,CAACjD,MAAM,GAAG,CAAC,EAAE;MACpBiD,OAAO,CAAC/C,IAAI,CAAC+C,OAAO,CAAC0D,GAAG,CAAC,CAAC,CAAC1B,KAAK,CAAC,CAAC,EAAE5E,GAAG,CAACmC,MAAM,CAAC,CAAC;MAChDS,OAAO,CAAC,CAAC,CAAC,GAAGA,OAAO,CAAC,CAAC,CAAC,CAACgC,KAAK,CAAC9E,KAAK,CAACqC,MAAM,CAAC;IAC/C;IACA,OAAO1D,UAAU,CAACmE,OAAO,CAAC2D,IAAI,CAAC,IAAI,CAAC,CAAC;EACzC,CAAC;EACD5H,KAAK,CAACuB,SAAS,CAAC0E,KAAK,GAAG,UAAU9E,KAAK,EAAEE,GAAG,EAAE;IAC1C,IAAI,CAACA,GAAG,EAAE;MACN,IAAI,CAACF,KAAK,EAAE;QACR;QACA;QACA;QACA,OAAO,IAAI;MACf;MACA;MACAE,GAAG,GAAG,IAAI,CAACC,OAAO,CAAC,CAAC;IACxB;IACA,IAAI,CAACH,KAAK,EAAE;MACR,MAAM,IAAI0G,KAAK,CAAC,qCAAqC,CAAC;IAC1D;IACA,IAAI7B,MAAM,GAAG,IAAI,CAACvF,KAAK,CAACwF,KAAK,CAAC9E,KAAK,CAACoC,IAAI,GAAG,CAAC,EAAElC,GAAG,CAACkC,IAAI,CAAC;IACvD,IAAIpC,KAAK,CAACoC,IAAI,KAAKlC,GAAG,CAACkC,IAAI,EAAE;MACzByC,MAAM,CAAC,CAAC,CAAC,GAAG8B,SAAS,CAAC9B,MAAM,CAAC,CAAC,CAAC,EAAE7E,KAAK,CAACqC,MAAM,EAAEnC,GAAG,CAACmC,MAAM,CAAC;IAC9D,CAAC,MACI;MACDrD,QAAQ,CAACW,OAAO,CAACC,EAAE,CAACI,KAAK,CAACoC,IAAI,GAAGlC,GAAG,CAACkC,IAAI,CAAC;MAC1CyC,MAAM,CAAC,CAAC,CAAC,GAAG8B,SAAS,CAAC9B,MAAM,CAAC,CAAC,CAAC,EAAE7E,KAAK,CAACqC,MAAM,CAAC;MAC9CwC,MAAM,CAAC9E,IAAI,CAAC4G,SAAS,CAAC9B,MAAM,CAAC2B,GAAG,CAAC,CAAC,EAAE,CAAC,EAAEtG,GAAG,CAACmC,MAAM,CAAC,CAAC;IACvD;IACA,IAAIuB,KAAK,GAAG,IAAI/E,KAAK,CAACgG,MAAM,CAAC;IAC7B,IAAI,IAAI,CAACrF,QAAQ,CAACK,MAAM,GAAG,CAAC,EAAE;MAC1B,IAAI+G,aAAa,GAAGhD,KAAK,CAACpE,QAAQ;MAClCR,QAAQ,CAACW,OAAO,CAACoC,WAAW,CAAC6E,aAAa,CAAC/G,MAAM,EAAE,CAAC,CAAC;MACrD,IAAI,CAACL,QAAQ,CAAC2B,OAAO,CAAC,UAAUC,OAAO,EAAE;QACrC,IAAIyD,MAAM,GAAGzD,OAAO,CAAC0D,KAAK,CAAC,IAAI,EAAE9E,KAAK,EAAEE,GAAG,CAAC;QAC5C,IAAI2E,MAAM,EAAE;UACR+B,aAAa,CAAC7G,IAAI,CAAC8E,MAAM,CAAC;QAC9B;MACJ,CAAC,EAAE,IAAI,CAAC;IACZ;IACA,OAAOjB,KAAK;EAChB,CAAC;EACD/E,KAAK,CAACuB,SAAS,CAACyG,oBAAoB,GAAG,UAAU7G,KAAK,EAAEE,GAAG,EAAEI,OAAO,EAAE;IAClE,OAAO,IAAI,CAACwE,KAAK,CAAC9E,KAAK,EAAEE,GAAG,CAAC,CAACG,QAAQ,CAACC,OAAO,CAAC;EACnD,CAAC;EACDzB,KAAK,CAACuB,SAAS,CAACG,WAAW,GAAG,UAAUP,KAAK,EAAEE,GAAG,EAAEI,OAAO,EAAE;IACzD,IAAIN,KAAK,KAAK,KAAK,CAAC,EAAE;MAAEA,KAAK,GAAG,IAAI,CAACC,QAAQ,CAAC,CAAC;IAAE;IACjD,IAAIC,GAAG,KAAK,KAAK,CAAC,EAAE;MAAEA,GAAG,GAAG,IAAI,CAACC,OAAO,CAAC,CAAC;IAAE;IAC5C,IAAI2G,EAAE,GAAG3H,SAAS,CAAC4H,SAAS,CAACzG,OAAO,CAAC;MAAE8E,QAAQ,GAAG0B,EAAE,CAAC1B,QAAQ;MAAE4B,OAAO,GAAGF,EAAE,CAACE,OAAO;MAAEC,eAAe,GAAGH,EAAE,CAACG,eAAe;MAAEC,cAAc,GAAGJ,EAAE,CAACI,cAAc;IAC7J,IAAIC,KAAK,GAAG,EAAE;IACd,KAAK,IAAI/E,IAAI,GAAGpC,KAAK,CAACoC,IAAI,EAAEA,IAAI,IAAIlC,GAAG,CAACkC,IAAI,EAAE,EAAEA,IAAI,EAAE;MAClD,IAAIe,IAAI,GAAG,IAAI,CAAC7D,KAAK,CAAC8C,IAAI,GAAG,CAAC,CAAC;MAC/B,IAAIA,IAAI,KAAKpC,KAAK,CAACoC,IAAI,EAAE;QACrB,IAAIA,IAAI,KAAKlC,GAAG,CAACkC,IAAI,EAAE;UACnBe,IAAI,GAAGwD,SAAS,CAACxD,IAAI,EAAEnD,KAAK,CAACqC,MAAM,EAAEnC,GAAG,CAACmC,MAAM,CAAC;QACpD,CAAC,MACI;UACDc,IAAI,GAAGwD,SAAS,CAACxD,IAAI,EAAEnD,KAAK,CAACqC,MAAM,CAAC;QACxC;MACJ,CAAC,MACI,IAAID,IAAI,KAAKlC,GAAG,CAACkC,IAAI,EAAE;QACxBe,IAAI,GAAGwD,SAAS,CAACxD,IAAI,EAAE,CAAC,EAAEjD,GAAG,CAACmC,MAAM,CAAC;MACzC;MACA,IAAIgB,MAAM,GAAGW,IAAI,CAACC,GAAG,CAACd,IAAI,CAACE,MAAM,EAAE,CAAC,CAAC;MACrC,IAAI+D,QAAQ,GAAGjE,IAAI,CAACf,IAAI,CAAC0C,KAAK,CAAC,CAAC,EAAE3B,IAAI,CAACI,UAAU,CAAC;MAClD,IAAI0D,eAAe,IACflC,gBAAgB,CAACqC,QAAQ,CAAC,IAC1BxI,WAAW,CAACwI,QAAQ,EAAEhC,QAAQ,CAAC,KAAK/B,MAAM,EAAE;QAC5C;QACA8D,KAAK,CAACpH,IAAI,CAACoD,IAAI,CAACf,IAAI,CAAC0C,KAAK,CAAC,CAAC,EAAE3B,IAAI,CAACK,QAAQ,CAAC,CAAC;QAC7C;MACJ;MACA,IAAI6D,IAAI,GAAG,CAAC;MACZ,IAAIC,MAAM,GAAGjE,MAAM;MACnB,IAAI2D,OAAO,EAAE;QACTK,IAAI,GAAGrD,IAAI,CAACuD,KAAK,CAAClE,MAAM,GAAG+B,QAAQ,CAAC;QACpCkC,MAAM,IAAID,IAAI,GAAGjC,QAAQ;MAC7B;MACA,IAAID,MAAM,GAAG,EAAE;MACf,IAAIkC,IAAI,GAAG,CAAC,EAAE;QACVlC,MAAM,IAAI,IAAIqC,KAAK,CAACH,IAAI,GAAG,CAAC,CAAC,CAACZ,IAAI,CAAC,IAAI,CAAC;MAC5C;MACA,IAAIa,MAAM,GAAG,CAAC,EAAE;QACZnC,MAAM,IAAI,IAAIqC,KAAK,CAACF,MAAM,GAAG,CAAC,CAAC,CAACb,IAAI,CAAC,GAAG,CAAC;MAC7C;MACAtB,MAAM,IAAIhC,IAAI,CAACf,IAAI,CAAC0C,KAAK,CAAC3B,IAAI,CAACI,UAAU,EAAEJ,IAAI,CAACK,QAAQ,CAAC;MACzD2D,KAAK,CAACpH,IAAI,CAACoF,MAAM,CAAC;IACtB;IACA,OAAOgC,KAAK,CAACV,IAAI,CAACS,cAAc,CAAC;EACrC,CAAC;EACDrI,KAAK,CAACuB,SAAS,CAACqH,OAAO,GAAG,YAAY;IAClC,OAAO,IAAI,CAAC5H,MAAM,GAAG,CAAC,IAAI,IAAI,CAAC+F,aAAa,CAAC,CAAC,CAAC,GAAG,CAAC;EACvD,CAAC;EACD/G,KAAK,CAACuB,SAAS,CAACqG,IAAI,GAAG,UAAUiB,QAAQ,EAAE;IACvC,IAAIC,SAAS,GAAG,IAAI;IACpB,IAAIrI,KAAK,GAAG,EAAE;IACd,IAAIE,QAAQ,GAAG,EAAE;IACjB,IAAIoI,QAAQ;IACZ,SAASC,WAAWA,CAACC,WAAW,EAAE;MAC9B,IAAIA,WAAW,KAAK,IAAI,EAAE;QACtB;MACJ;MACA,IAAIF,QAAQ,EAAE;QACV,IAAIzE,IAAI,GAAG2E,WAAW,CAACxI,KAAK,CAAC,CAAC,CAAC;QAC/B,IAAI+D,MAAM,GAAG,IAAImE,KAAK,CAACrE,IAAI,CAACE,MAAM,GAAG,CAAC,CAAC,CAACoD,IAAI,CAAC,GAAG,CAAC;QACjD,IAAIsB,UAAU,GAAGzI,KAAK,CAACO,MAAM;QAC7B,IAAImI,YAAY,GAAGhE,IAAI,CAACC,GAAG,CAAC2D,QAAQ,CAACvE,MAAM,EAAE,CAAC,CAAC,GAC3CuE,QAAQ,CAACpE,QAAQ,GACjBoE,QAAQ,CAACrE,UAAU;QACvBqE,QAAQ,CAACxF,IAAI,GACTwF,QAAQ,CAACxF,IAAI,CAAC0C,KAAK,CAAC,CAAC,EAAE8C,QAAQ,CAACpE,QAAQ,CAAC,GACrCH,MAAM,GACNF,IAAI,CAACf,IAAI,CAAC0C,KAAK,CAAC3B,IAAI,CAACI,UAAU,EAAEJ,IAAI,CAACK,QAAQ,CAAC;QACvD;QACA;QACAoE,QAAQ,CAACxD,MAAM,GAAGwD,QAAQ,CAACxD,MAAM,IAAIjB,IAAI,CAACiB,MAAM;QAChDwD,QAAQ,CAACpE,QAAQ,GAAGoE,QAAQ,CAACxF,IAAI,CAACvC,MAAM;QACxC,IAAIiI,WAAW,CAACtI,QAAQ,CAACK,MAAM,GAAG,CAAC,EAAE;UACjCiI,WAAW,CAACtI,QAAQ,CAAC2B,OAAO,CAAC,UAAUC,OAAO,EAAE;YAC5C5B,QAAQ,CAACO,IAAI,CAACqB,OAAO,CAAC6G,GAAG,CAACF,UAAU,EAAEC,YAAY,CAAC,CAAC;UACxD,CAAC,CAAC;QACN;MACJ,CAAC,MACI,IAAIF,WAAW,CAACtI,QAAQ,CAACK,MAAM,GAAG,CAAC,EAAE;QACtCL,QAAQ,CAACO,IAAI,CAACmI,KAAK,CAAC1I,QAAQ,EAAEsI,WAAW,CAACtI,QAAQ,CAAC;MACvD;MACAsI,WAAW,CAACxI,KAAK,CAAC6B,OAAO,CAAC,UAAUgC,IAAI,EAAEW,CAAC,EAAE;QACzC,IAAI,CAAC8D,QAAQ,IAAI9D,CAAC,GAAG,CAAC,EAAE;UACpB8D,QAAQ,GAAG9I,OAAO,CAACiF,QAAQ,CAAC,CAAC,CAAC,EAAEZ,IAAI,CAAC;UACrC7D,KAAK,CAACS,IAAI,CAAC6H,QAAQ,CAAC;QACxB;MACJ,CAAC,CAAC;IACN;IACA,SAASO,mBAAmBA,CAACL,WAAW,EAAEhE,CAAC,EAAE;MACzC,IAAIA,CAAC,GAAG,CAAC,EACL+D,WAAW,CAACF,SAAS,CAAC;MAC1BE,WAAW,CAACC,WAAW,CAAC;IAC5B;IACAJ,QAAQ,CACH7D,GAAG,CAAC,UAAUuE,IAAI,EAAE;MACrB,IAAIxE,KAAK,GAAGjF,UAAU,CAACyJ,IAAI,CAAC;MAC5B,IAAIxE,KAAK,CAAC6D,OAAO,CAAC,CAAC,EACf,OAAO,IAAI;MACf,OAAO7D,KAAK;IAChB,CAAC,CAAC,CACGzC,OAAO,CAAC,UAAU2G,WAAW,EAAEhE,CAAC,EAAE;MACnC,IAAI6D,SAAS,CAACF,OAAO,CAAC,CAAC,EAAE;QACrBI,WAAW,CAACC,WAAW,CAAC;MAC5B,CAAC,MACI;QACDK,mBAAmB,CAACL,WAAW,EAAEhE,CAAC,CAAC;MACvC;IACJ,CAAC,CAAC;IACF,IAAIxE,KAAK,CAACO,MAAM,GAAG,CAAC,EAChB,OAAOqG,UAAU;IACrB,IAAItC,KAAK,GAAG,IAAI/E,KAAK,CAACS,KAAK,CAAC;IAC5BsE,KAAK,CAACpE,QAAQ,GAAGA,QAAQ;IACzB,OAAOoE,KAAK;EAChB,CAAC;EACD/E,KAAK,CAACuB,SAAS,CAAC1B,MAAM,GAAG,YAAY;IACjC,IAAI2J,IAAI,GAAG,EAAE;IACb,KAAK,IAAIC,EAAE,GAAG,CAAC,EAAEA,EAAE,GAAGC,SAAS,CAAC1I,MAAM,EAAEyI,EAAE,EAAE,EAAE;MAC1CD,IAAI,CAACC,EAAE,CAAC,GAAGC,SAAS,CAACD,EAAE,CAAC;IAC5B;IACA,IAAIE,IAAI,GAAG,CAAC,IAAI,CAAC;IACjBA,IAAI,CAACzI,IAAI,CAACmI,KAAK,CAACM,IAAI,EAAEH,IAAI,CAAC;IAC3BrJ,QAAQ,CAACW,OAAO,CAACoC,WAAW,CAACyG,IAAI,CAAC3I,MAAM,EAAEwI,IAAI,CAACxI,MAAM,GAAG,CAAC,CAAC;IAC1D,OAAOqG,UAAU,CAACO,IAAI,CAAC+B,IAAI,CAAC;EAChC,CAAC;EACD,OAAO3J,KAAK;AAChB,CAAC,CAAC,CAAE;AACJL,OAAO,CAACK,KAAK,GAAGA,KAAK;AACrB,IAAI4J,eAAe,GAAG,CAAC,CAAC;AACxB,IAAIlG,MAAM,GAAGkG,eAAe,CAACC,cAAc;AAC3C,IAAIC,cAAc,GAAG,EAAE;AACvB,SAAS/J,WAAWA,CAAC0I,MAAM,EAAElC,QAAQ,EAAE;EACnC,IAAIwD,KAAK,GAAG,CAAC;EACb,IAAIC,GAAG,GAAGvB,MAAM,CAACzH,MAAM;EACvB,KAAK,IAAIiE,CAAC,GAAG,CAAC,EAAEA,CAAC,GAAG+E,GAAG,EAAE,EAAE/E,CAAC,EAAE;IAC1B,QAAQwD,MAAM,CAACwB,UAAU,CAAChF,CAAC,CAAC;MACxB,KAAK,CAAC;QAAE;UACJ;UACA9E,QAAQ,CAACW,OAAO,CAACoC,WAAW,CAAC,OAAOqD,QAAQ,EAAE,QAAQ,CAAC;UACvDpG,QAAQ,CAACW,OAAO,CAACC,EAAE,CAACwF,QAAQ,GAAG,CAAC,CAAC;UACjC,IAAI2D,IAAI,GAAG/E,IAAI,CAACgF,IAAI,CAACJ,KAAK,GAAGxD,QAAQ,CAAC,GAAGA,QAAQ;UACjD,IAAI2D,IAAI,KAAKH,KAAK,EAAE;YAChBA,KAAK,IAAIxD,QAAQ;UACrB,CAAC,MACI;YACDwD,KAAK,GAAGG,IAAI;UAChB;UACA;QACJ;MACA,KAAK,EAAE,CAAC,CAAC;MACT,KAAK,EAAE,CAAC,CAAC;MACT,KAAK,EAAE,CAAC,CAAC;MACT,KAAK,MAAM;QAAE;QACT;QACA;MACJ,KAAK,EAAE,CAAC,CAAC;MACT;QACI;QACAH,KAAK,IAAI,CAAC;QACV;IACR;EACJ;EACA,OAAOA,KAAK;AAChB;AACApK,OAAO,CAACI,WAAW,GAAGA,WAAW;AACjC,IAAIqK,eAAe,GAAG,MAAM;AAC5B;AACA,IAAIjG,oBAAoB,GAAG,oDAAoD;AAC/E;AACA;AACA;AACA,SAASrE,UAAUA,CAACsE,MAAM,EAAE3C,OAAO,EAAE;EACjC,IAAI2C,MAAM,YAAYpE,KAAK,EACvB,OAAOoE,MAAM;EACjBA,MAAM,IAAI,EAAE;EACZ,IAAImC,QAAQ,GAAG9E,OAAO,IAAIA,OAAO,CAAC8E,QAAQ;EAC1C,IAAI8D,OAAO,GAAGjG,MAAM,CAACkG,OAAO,CAAC,IAAI,CAAC,GAAG,CAAC;EACtC,IAAIC,SAAS,GAAG,CAAC9I,OAAO,IAAI4I,OAAO,IAAIjG,MAAM,CAACpD,MAAM,IAAI8I,cAAc;EACtE3J,QAAQ,CAACW,OAAO,CAACC,EAAE,CAACwF,QAAQ,IAAI8D,OAAO,EAAE,yDAAyD,GAAGjG,MAAM,CAAC;EAC5G,IAAImG,SAAS,IAAI7G,MAAM,CAACC,IAAI,CAACiG,eAAe,EAAExF,MAAM,CAAC,EACjD,OAAOwF,eAAe,CAACxF,MAAM,CAAC;EAClC,IAAIW,KAAK,GAAG,IAAI/E,KAAK,CAACoE,MAAM,CAACF,KAAK,CAACC,oBAAoB,CAAC,CAACa,GAAG,CAAC,UAAUzB,IAAI,EAAE;IACzE;IACA,IAAIkF,MAAM,GAAG2B,eAAe,CAACI,IAAI,CAACjH,IAAI,CAAC,CAAC,CAAC,CAAC;IAC1C,OAAO;MACHA,IAAI,EAAEA,IAAI;MACViB,MAAM,EAAEzE,WAAW,CAAC0I,MAAM,EAAElC,QAAQ,CAAC;MACrC;MACAhB,MAAM,EAAE,KAAK;MACbb,UAAU,EAAE+D,MAAM,CAACzH,MAAM;MACzB2D,QAAQ,EAAEpB,IAAI,CAACvC;IACnB,CAAC;EACL,CAAC,CAAC,EAAEV,SAAS,CAAC4H,SAAS,CAACzG,OAAO,CAAC,CAACf,cAAc,CAAC;EAChD,IAAI6J,SAAS,EACTX,eAAe,CAACxF,MAAM,CAAC,GAAGW,KAAK;EACnC,OAAOA,KAAK;AAChB;AACApF,OAAO,CAACG,UAAU,GAAGA,UAAU;AAC/B,SAASoG,gBAAgBA,CAAC9B,MAAM,EAAE;EAC9B,OAAO,CAAC,IAAI,CAACqG,IAAI,CAACrG,MAAM,CAAC;AAC7B;AACA,SAAS0D,SAASA,CAACxD,IAAI,EAAEoG,QAAQ,EAAEC,MAAM,EAAE;EACvC,IAAIjG,UAAU,GAAGJ,IAAI,CAACI,UAAU;EAChC,IAAIC,QAAQ,GAAGL,IAAI,CAACK,QAAQ;EAC5B,IAAIH,MAAM,GAAGW,IAAI,CAACC,GAAG,CAACd,IAAI,CAACE,MAAM,EAAE,CAAC,CAAC;EACrC,IAAIoG,UAAU,GAAGpG,MAAM,GAAGG,QAAQ,GAAGD,UAAU;EAC/C,IAAI,OAAOiG,MAAM,KAAK,WAAW,EAAE;IAC/BA,MAAM,GAAGC,UAAU;EACvB;EACAF,QAAQ,GAAGvF,IAAI,CAACC,GAAG,CAACsF,QAAQ,EAAE,CAAC,CAAC;EAChCC,MAAM,GAAGxF,IAAI,CAAC0B,GAAG,CAAC8D,MAAM,EAAEC,UAAU,CAAC;EACrCD,MAAM,GAAGxF,IAAI,CAACC,GAAG,CAACuF,MAAM,EAAED,QAAQ,CAAC;EACnC,IAAIC,MAAM,GAAGnG,MAAM,EAAE;IACjBA,MAAM,GAAGmG,MAAM;IACfhG,QAAQ,GAAGD,UAAU;EACzB,CAAC,MACI;IACDC,QAAQ,IAAIiG,UAAU,GAAGD,MAAM;EACnC;EACAC,UAAU,GAAGD,MAAM;EACnBC,UAAU,IAAIF,QAAQ;EACtB,IAAIA,QAAQ,GAAGlG,MAAM,EAAE;IACnBA,MAAM,IAAIkG,QAAQ;EACtB,CAAC,MACI;IACDA,QAAQ,IAAIlG,MAAM;IAClBA,MAAM,GAAG,CAAC;IACVE,UAAU,IAAIgG,QAAQ;EAC1B;EACAvK,QAAQ,CAACW,OAAO,CAACC,EAAE,CAACyD,MAAM,IAAI,CAAC,CAAC;EAChCrE,QAAQ,CAACW,OAAO,CAACC,EAAE,CAAC2D,UAAU,IAAIC,QAAQ,CAAC;EAC3CxE,QAAQ,CAACW,OAAO,CAACoC,WAAW,CAAC0H,UAAU,EAAEpG,MAAM,GAAGG,QAAQ,GAAGD,UAAU,CAAC;EACxE,IAAIJ,IAAI,CAACE,MAAM,KAAKA,MAAM,IACtBF,IAAI,CAACI,UAAU,KAAKA,UAAU,IAC9BJ,IAAI,CAACK,QAAQ,KAAKA,QAAQ,EAAE;IAC5B,OAAOL,IAAI;EACf;EACA,OAAO;IACHf,IAAI,EAAEe,IAAI,CAACf,IAAI;IACfiB,MAAM,EAAEA,MAAM;IACd;IACAe,MAAM,EAAE,KAAK;IACbb,UAAU,EAAEA,UAAU;IACtBC,QAAQ,EAAEA;EACd,CAAC;AACL;AACA,SAAS9E,MAAMA,CAACgJ,QAAQ,EAAE;EACtB,OAAOxB,UAAU,CAACO,IAAI,CAACiB,QAAQ,CAAC;AACpC;AACAlJ,OAAO,CAACE,MAAM,GAAGA,MAAM;AACvB;AACA;AACA,IAAIwH,UAAU,GAAGvH,UAAU,CAAC,EAAE,CAAC"},"metadata":{},"sourceType":"script"}