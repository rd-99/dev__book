{"ast":null,"code":"Prism.languages.graphql = {\n  'comment': /#.*/,\n  'description': {\n    pattern: /(?:\"\"\"(?:[^\"]|(?!\"\"\")\")*\"\"\"|\"(?:\\\\.|[^\\\\\"\\r\\n])*\")(?=\\s*[a-z_])/i,\n    greedy: true,\n    alias: 'string',\n    inside: {\n      'language-markdown': {\n        pattern: /(^\"(?:\"\")?)(?!\\1)[\\s\\S]+(?=\\1$)/,\n        lookbehind: true,\n        inside: Prism.languages.markdown\n      }\n    }\n  },\n  'string': {\n    pattern: /\"\"\"(?:[^\"]|(?!\"\"\")\")*\"\"\"|\"(?:\\\\.|[^\\\\\"\\r\\n])*\"/,\n    greedy: true\n  },\n  'number': /(?:\\B-|\\b)\\d+(?:\\.\\d+)?(?:e[+-]?\\d+)?\\b/i,\n  'boolean': /\\b(?:true|false)\\b/,\n  'variable': /\\$[a-z_]\\w*/i,\n  'directive': {\n    pattern: /@[a-z_]\\w*/i,\n    alias: 'function'\n  },\n  'attr-name': {\n    pattern: /[a-z_]\\w*(?=\\s*(?:\\((?:[^()\"]|\"(?:\\\\.|[^\\\\\"\\r\\n])*\")*\\))?:)/i,\n    greedy: true\n  },\n  'atom-input': {\n    pattern: /[A-Z]\\w*Input(?=!?.*$)/m,\n    alias: 'class-name'\n  },\n  'scalar': /\\b(?:Boolean|Float|ID|Int|String)\\b/,\n  'constant': /\\b[A-Z][A-Z_\\d]*\\b/,\n  'class-name': {\n    pattern: /(\\b(?:enum|implements|interface|on|scalar|type|union)\\s+|&\\s*|:\\s*|\\[)[A-Z_]\\w*/,\n    lookbehind: true\n  },\n  'fragment': {\n    pattern: /(\\bfragment\\s+|\\.{3}\\s*(?!on\\b))[a-zA-Z_]\\w*/,\n    lookbehind: true,\n    alias: 'function'\n  },\n  'definition-mutation': {\n    pattern: /(\\bmutation\\s+)[a-zA-Z_]\\w*/,\n    lookbehind: true,\n    alias: 'function'\n  },\n  'definition-query': {\n    pattern: /(\\bquery\\s+)[a-zA-Z_]\\w*/,\n    lookbehind: true,\n    alias: 'function'\n  },\n  'keyword': /\\b(?:directive|enum|extend|fragment|implements|input|interface|mutation|on|query|repeatable|scalar|schema|subscription|type|union)\\b/,\n  'operator': /[!=|&]|\\.{3}/,\n  'property-query': /\\w+(?=\\s*\\()/,\n  'object': /\\w+(?=\\s*\\{)/,\n  'punctuation': /[!(){}\\[\\]:=,]/,\n  'property': /\\w+/\n};\nPrism.hooks.add('after-tokenize', function afterTokenizeGraphql(env) {\n  if (env.language !== 'graphql') {\n    return;\n  }\n\n  /**\n   * get the graphql token stream that we want to customize\n   *\n   * @typedef {InstanceType<import(\"./prism-core\")[\"Token\"]>} Token\n   * @type {Token[]}\n   */\n  var validTokens = env.tokens.filter(function (token) {\n    return typeof token !== 'string' && token.type !== 'comment' && token.type !== 'scalar';\n  });\n  var currentIndex = 0;\n\n  /**\n   * Returns whether the token relative to the current index has the given type.\n   *\n   * @param {number} offset\n   * @returns {Token | undefined}\n   */\n  function getToken(offset) {\n    return validTokens[currentIndex + offset];\n  }\n\n  /**\n   * Returns whether the token relative to the current index has the given type.\n   *\n   * @param {readonly string[]} types\n   * @param {number} [offset=0]\n   * @returns {boolean}\n   */\n  function isTokenType(types, offset) {\n    offset = offset || 0;\n    for (var i = 0; i < types.length; i++) {\n      var token = getToken(i + offset);\n      if (!token || token.type !== types[i]) {\n        return false;\n      }\n    }\n    return true;\n  }\n\n  /**\n   * Returns the index of the closing bracket to an opening bracket.\n   *\n   * It is assumed that `token[currentIndex - 1]` is an opening bracket.\n   *\n   * If no closing bracket could be found, `-1` will be returned.\n   *\n   * @param {RegExp} open\n   * @param {RegExp} close\n   * @returns {number}\n   */\n  function findClosingBracket(open, close) {\n    var stackHeight = 1;\n    for (var i = currentIndex; i < validTokens.length; i++) {\n      var token = validTokens[i];\n      var content = token.content;\n      if (token.type === 'punctuation' && typeof content === 'string') {\n        if (open.test(content)) {\n          stackHeight++;\n        } else if (close.test(content)) {\n          stackHeight--;\n          if (stackHeight === 0) {\n            return i;\n          }\n        }\n      }\n    }\n    return -1;\n  }\n\n  /**\n   * Adds an alias to the given token.\n   *\n   * @param {Token} token\n   * @param {string} alias\n   * @returns {void}\n   */\n  function addAlias(token, alias) {\n    var aliases = token.alias;\n    if (!aliases) {\n      token.alias = aliases = [];\n    } else if (!Array.isArray(aliases)) {\n      token.alias = aliases = [aliases];\n    }\n    aliases.push(alias);\n  }\n  for (; currentIndex < validTokens.length;) {\n    var startToken = validTokens[currentIndex++];\n\n    // add special aliases for mutation tokens\n    if (startToken.type === 'keyword' && startToken.content === 'mutation') {\n      // any array of the names of all input variables (if any)\n      var inputVariables = [];\n      if (isTokenType(['definition-mutation', 'punctuation']) && getToken(1).content === '(') {\n        // definition\n\n        currentIndex += 2; // skip 'definition-mutation' and 'punctuation'\n\n        var definitionEnd = findClosingBracket(/^\\($/, /^\\)$/);\n        if (definitionEnd === -1) {\n          continue;\n        }\n\n        // find all input variables\n        for (; currentIndex < definitionEnd; currentIndex++) {\n          var t = getToken(0);\n          if (t.type === 'variable') {\n            addAlias(t, 'variable-input');\n            inputVariables.push(t.content);\n          }\n        }\n        currentIndex = definitionEnd + 1;\n      }\n      if (isTokenType(['punctuation', 'property-query']) && getToken(0).content === '{') {\n        currentIndex++; // skip opening bracket\n\n        addAlias(getToken(0), 'property-mutation');\n        if (inputVariables.length > 0) {\n          var mutationEnd = findClosingBracket(/^\\{$/, /^\\}$/);\n          if (mutationEnd === -1) {\n            continue;\n          }\n\n          // give references to input variables a special alias\n          for (var i = currentIndex; i < mutationEnd; i++) {\n            var varToken = validTokens[i];\n            if (varToken.type === 'variable' && inputVariables.indexOf(varToken.content) >= 0) {\n              addAlias(varToken, 'variable-input');\n            }\n          }\n        }\n      }\n    }\n  }\n});","map":{"version":3,"names":["Prism","languages","graphql","pattern","greedy","alias","inside","lookbehind","markdown","hooks","add","afterTokenizeGraphql","env","language","validTokens","tokens","filter","token","type","currentIndex","getToken","offset","isTokenType","types","i","length","findClosingBracket","open","close","stackHeight","content","test","addAlias","aliases","Array","isArray","push","startToken","inputVariables","definitionEnd","t","mutationEnd","varToken","indexOf"],"sources":["C:/Users/Acer/Desktop/dev__book/dev__book/node_modules/prismjs/components/prism-graphql.js"],"sourcesContent":["Prism.languages.graphql = {\n\t'comment': /#.*/,\n\t'description': {\n\t\tpattern: /(?:\"\"\"(?:[^\"]|(?!\"\"\")\")*\"\"\"|\"(?:\\\\.|[^\\\\\"\\r\\n])*\")(?=\\s*[a-z_])/i,\n\t\tgreedy: true,\n\t\talias: 'string',\n\t\tinside: {\n\t\t\t'language-markdown': {\n\t\t\t\tpattern: /(^\"(?:\"\")?)(?!\\1)[\\s\\S]+(?=\\1$)/,\n\t\t\t\tlookbehind: true,\n\t\t\t\tinside: Prism.languages.markdown\n\t\t\t}\n\t\t}\n\t},\n\t'string': {\n\t\tpattern: /\"\"\"(?:[^\"]|(?!\"\"\")\")*\"\"\"|\"(?:\\\\.|[^\\\\\"\\r\\n])*\"/,\n\t\tgreedy: true\n\t},\n\t'number': /(?:\\B-|\\b)\\d+(?:\\.\\d+)?(?:e[+-]?\\d+)?\\b/i,\n\t'boolean': /\\b(?:true|false)\\b/,\n\t'variable': /\\$[a-z_]\\w*/i,\n\t'directive': {\n\t\tpattern: /@[a-z_]\\w*/i,\n\t\talias: 'function'\n\t},\n\t'attr-name': {\n\t\tpattern: /[a-z_]\\w*(?=\\s*(?:\\((?:[^()\"]|\"(?:\\\\.|[^\\\\\"\\r\\n])*\")*\\))?:)/i,\n\t\tgreedy: true\n\t},\n\t'atom-input': {\n\t\tpattern: /[A-Z]\\w*Input(?=!?.*$)/m,\n\t\talias: 'class-name'\n\t},\n\t'scalar': /\\b(?:Boolean|Float|ID|Int|String)\\b/,\n\t'constant': /\\b[A-Z][A-Z_\\d]*\\b/,\n\t'class-name': {\n\t\tpattern: /(\\b(?:enum|implements|interface|on|scalar|type|union)\\s+|&\\s*|:\\s*|\\[)[A-Z_]\\w*/,\n\t\tlookbehind: true\n\t},\n\t'fragment': {\n\t\tpattern: /(\\bfragment\\s+|\\.{3}\\s*(?!on\\b))[a-zA-Z_]\\w*/,\n\t\tlookbehind: true,\n\t\talias: 'function'\n\t},\n\t'definition-mutation': {\n\t\tpattern: /(\\bmutation\\s+)[a-zA-Z_]\\w*/,\n\t\tlookbehind: true,\n\t\talias: 'function'\n\t},\n\t'definition-query': {\n\t\tpattern: /(\\bquery\\s+)[a-zA-Z_]\\w*/,\n\t\tlookbehind: true,\n\t\talias: 'function'\n\t},\n\t'keyword': /\\b(?:directive|enum|extend|fragment|implements|input|interface|mutation|on|query|repeatable|scalar|schema|subscription|type|union)\\b/,\n\t'operator': /[!=|&]|\\.{3}/,\n\t'property-query': /\\w+(?=\\s*\\()/,\n\t'object': /\\w+(?=\\s*\\{)/,\n\t'punctuation': /[!(){}\\[\\]:=,]/,\n\t'property': /\\w+/\n};\n\nPrism.hooks.add('after-tokenize', function afterTokenizeGraphql(env) {\n\tif (env.language !== 'graphql') {\n\t\treturn;\n\t}\n\n\t/**\n\t * get the graphql token stream that we want to customize\n\t *\n\t * @typedef {InstanceType<import(\"./prism-core\")[\"Token\"]>} Token\n\t * @type {Token[]}\n\t */\n\tvar validTokens = env.tokens.filter(function (token) {\n\t\treturn typeof token !== 'string' && token.type !== 'comment' && token.type !== 'scalar';\n\t});\n\n\tvar currentIndex = 0;\n\n\t/**\n\t * Returns whether the token relative to the current index has the given type.\n\t *\n\t * @param {number} offset\n\t * @returns {Token | undefined}\n\t */\n\tfunction getToken(offset) {\n\t\treturn validTokens[currentIndex + offset];\n\t}\n\n\t/**\n\t * Returns whether the token relative to the current index has the given type.\n\t *\n\t * @param {readonly string[]} types\n\t * @param {number} [offset=0]\n\t * @returns {boolean}\n\t */\n\tfunction isTokenType(types, offset) {\n\t\toffset = offset || 0;\n\t\tfor (var i = 0; i < types.length; i++) {\n\t\t\tvar token = getToken(i + offset);\n\t\t\tif (!token || token.type !== types[i]) {\n\t\t\t\treturn false;\n\t\t\t}\n\t\t}\n\t\treturn true;\n\t}\n\n\t/**\n\t * Returns the index of the closing bracket to an opening bracket.\n\t *\n\t * It is assumed that `token[currentIndex - 1]` is an opening bracket.\n\t *\n\t * If no closing bracket could be found, `-1` will be returned.\n\t *\n\t * @param {RegExp} open\n\t * @param {RegExp} close\n\t * @returns {number}\n\t */\n\tfunction findClosingBracket(open, close) {\n\t\tvar stackHeight = 1;\n\n\t\tfor (var i = currentIndex; i < validTokens.length; i++) {\n\t\t\tvar token = validTokens[i];\n\t\t\tvar content = token.content;\n\n\t\t\tif (token.type === 'punctuation' && typeof content === 'string') {\n\t\t\t\tif (open.test(content)) {\n\t\t\t\t\tstackHeight++;\n\t\t\t\t} else if (close.test(content)) {\n\t\t\t\t\tstackHeight--;\n\n\t\t\t\t\tif (stackHeight === 0) {\n\t\t\t\t\t\treturn i;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\treturn -1;\n\t}\n\n\t/**\n\t * Adds an alias to the given token.\n\t *\n\t * @param {Token} token\n\t * @param {string} alias\n\t * @returns {void}\n\t */\n\tfunction addAlias(token, alias) {\n\t\tvar aliases = token.alias;\n\t\tif (!aliases) {\n\t\t\ttoken.alias = aliases = [];\n\t\t} else if (!Array.isArray(aliases)) {\n\t\t\ttoken.alias = aliases = [aliases];\n\t\t}\n\t\taliases.push(alias);\n\t}\n\n\tfor (; currentIndex < validTokens.length;) {\n\t\tvar startToken = validTokens[currentIndex++];\n\n\t\t// add special aliases for mutation tokens\n\t\tif (startToken.type === 'keyword' && startToken.content === 'mutation') {\n\t\t\t// any array of the names of all input variables (if any)\n\t\t\tvar inputVariables = [];\n\n\t\t\tif (isTokenType(['definition-mutation', 'punctuation']) && getToken(1).content === '(') {\n\t\t\t\t// definition\n\n\t\t\t\tcurrentIndex += 2; // skip 'definition-mutation' and 'punctuation'\n\n\t\t\t\tvar definitionEnd = findClosingBracket(/^\\($/, /^\\)$/);\n\t\t\t\tif (definitionEnd === -1) {\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\n\t\t\t\t// find all input variables\n\t\t\t\tfor (; currentIndex < definitionEnd; currentIndex++) {\n\t\t\t\t\tvar t = getToken(0);\n\t\t\t\t\tif (t.type === 'variable') {\n\t\t\t\t\t\taddAlias(t, 'variable-input');\n\t\t\t\t\t\tinputVariables.push(t.content);\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\tcurrentIndex = definitionEnd + 1;\n\t\t\t}\n\n\t\t\tif (isTokenType(['punctuation', 'property-query']) && getToken(0).content === '{') {\n\t\t\t\tcurrentIndex++; // skip opening bracket\n\n\t\t\t\taddAlias(getToken(0), 'property-mutation');\n\n\t\t\t\tif (inputVariables.length > 0) {\n\t\t\t\t\tvar mutationEnd = findClosingBracket(/^\\{$/, /^\\}$/);\n\t\t\t\t\tif (mutationEnd === -1) {\n\t\t\t\t\t\tcontinue;\n\t\t\t\t\t}\n\n\t\t\t\t\t// give references to input variables a special alias\n\t\t\t\t\tfor (var i = currentIndex; i < mutationEnd; i++) {\n\t\t\t\t\t\tvar varToken = validTokens[i];\n\t\t\t\t\t\tif (varToken.type === 'variable' && inputVariables.indexOf(varToken.content) >= 0) {\n\t\t\t\t\t\t\taddAlias(varToken, 'variable-input');\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n});\n"],"mappings":"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"},"metadata":{},"sourceType":"script"}