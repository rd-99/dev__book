{"ast":null,"code":"'use strict';\n\nmodule.exports = findAndReplace;\nvar visit = require('unist-util-visit-parents');\nvar convert = require('unist-util-is/convert');\nvar escape = require('escape-string-regexp');\nvar splice = [].splice;\nfunction findAndReplace(tree, find, replace, options) {\n  var settings;\n  var schema;\n  if (typeof find === 'string' || find && typeof find.exec === 'function') {\n    schema = [[find, replace]];\n  } else {\n    schema = find;\n    options = replace;\n  }\n  settings = options || {};\n  search(tree, settings, handlerFactory(toPairs(schema)));\n  return tree;\n  function handlerFactory(pairs) {\n    var pair = pairs[0];\n    return handler;\n    function handler(node, parent) {\n      var find = pair[0];\n      var replace = pair[1];\n      var nodes = [];\n      var start = 0;\n      var index = parent.children.indexOf(node);\n      var position;\n      var match;\n      var subhandler;\n      var value;\n      find.lastIndex = 0;\n      match = find.exec(node.value);\n      while (match) {\n        position = match.index;\n        value = replace.apply(null, [].concat(match, {\n          index: match.index,\n          input: match.input\n        }));\n        if (value !== false) {\n          if (start !== position) {\n            nodes.push({\n              type: 'text',\n              value: node.value.slice(start, position)\n            });\n          }\n          if (typeof value === 'string' && value.length > 0) {\n            value = {\n              type: 'text',\n              value: value\n            };\n          }\n          if (value) {\n            nodes = [].concat(nodes, value);\n          }\n          start = position + match[0].length;\n        }\n        if (!find.global) {\n          break;\n        }\n        match = find.exec(node.value);\n      }\n      if (position === undefined) {\n        nodes = [node];\n        index--;\n      } else {\n        if (start < node.value.length) {\n          nodes.push({\n            type: 'text',\n            value: node.value.slice(start)\n          });\n        }\n        nodes.unshift(index, 1);\n        splice.apply(parent.children, nodes);\n      }\n      if (pairs.length > 1) {\n        subhandler = handlerFactory(pairs.slice(1));\n        position = -1;\n        while (++position < nodes.length) {\n          node = nodes[position];\n          if (node.type === 'text') {\n            subhandler(node, parent);\n          } else {\n            search(node, settings, subhandler);\n          }\n        }\n      }\n      return index + nodes.length + 1;\n    }\n  }\n}\nfunction search(tree, settings, handler) {\n  var ignored = convert(settings.ignore || []);\n  var result = [];\n  visit(tree, 'text', visitor);\n  return result;\n  function visitor(node, parents) {\n    var index = -1;\n    var parent;\n    var grandparent;\n    while (++index < parents.length) {\n      parent = parents[index];\n      if (ignored(parent, grandparent ? grandparent.children.indexOf(parent) : undefined, grandparent)) {\n        return;\n      }\n      grandparent = parent;\n    }\n    return handler(node, grandparent);\n  }\n}\nfunction toPairs(schema) {\n  var result = [];\n  var key;\n  var index;\n  if (typeof schema !== 'object') {\n    throw new Error('Expected array or object as schema');\n  }\n  if ('length' in schema) {\n    index = -1;\n    while (++index < schema.length) {\n      result.push([toExpression(schema[index][0]), toFunction(schema[index][1])]);\n    }\n  } else {\n    for (key in schema) {\n      result.push([toExpression(key), toFunction(schema[key])]);\n    }\n  }\n  return result;\n}\nfunction toExpression(find) {\n  return typeof find === 'string' ? new RegExp(escape(find), 'g') : find;\n}\nfunction toFunction(replace) {\n  return typeof replace === 'function' ? replace : returner;\n  function returner() {\n    return replace;\n  }\n}","map":{"version":3,"names":["module","exports","findAndReplace","visit","require","convert","escape","splice","tree","find","replace","options","settings","schema","exec","search","handlerFactory","toPairs","pairs","pair","handler","node","parent","nodes","start","index","children","indexOf","position","match","subhandler","value","lastIndex","apply","concat","input","push","type","slice","length","global","undefined","unshift","ignored","ignore","result","visitor","parents","grandparent","key","Error","toExpression","toFunction","RegExp","returner"],"sources":["C:/Users/Acer/Desktop/dev__book/dev__book/node_modules/mdast-util-find-and-replace/index.js"],"sourcesContent":["'use strict'\n\nmodule.exports = findAndReplace\n\nvar visit = require('unist-util-visit-parents')\nvar convert = require('unist-util-is/convert')\nvar escape = require('escape-string-regexp')\n\nvar splice = [].splice\n\nfunction findAndReplace(tree, find, replace, options) {\n  var settings\n  var schema\n\n  if (typeof find === 'string' || (find && typeof find.exec === 'function')) {\n    schema = [[find, replace]]\n  } else {\n    schema = find\n    options = replace\n  }\n\n  settings = options || {}\n\n  search(tree, settings, handlerFactory(toPairs(schema)))\n\n  return tree\n\n  function handlerFactory(pairs) {\n    var pair = pairs[0]\n\n    return handler\n\n    function handler(node, parent) {\n      var find = pair[0]\n      var replace = pair[1]\n      var nodes = []\n      var start = 0\n      var index = parent.children.indexOf(node)\n      var position\n      var match\n      var subhandler\n      var value\n\n      find.lastIndex = 0\n\n      match = find.exec(node.value)\n\n      while (match) {\n        position = match.index\n        value = replace.apply(\n          null,\n          [].concat(match, {index: match.index, input: match.input})\n        )\n\n        if (value !== false) {\n          if (start !== position) {\n            nodes.push({type: 'text', value: node.value.slice(start, position)})\n          }\n\n          if (typeof value === 'string' && value.length > 0) {\n            value = {type: 'text', value: value}\n          }\n\n          if (value) {\n            nodes = [].concat(nodes, value)\n          }\n\n          start = position + match[0].length\n        }\n\n        if (!find.global) {\n          break\n        }\n\n        match = find.exec(node.value)\n      }\n\n      if (position === undefined) {\n        nodes = [node]\n        index--\n      } else {\n        if (start < node.value.length) {\n          nodes.push({type: 'text', value: node.value.slice(start)})\n        }\n\n        nodes.unshift(index, 1)\n        splice.apply(parent.children, nodes)\n      }\n\n      if (pairs.length > 1) {\n        subhandler = handlerFactory(pairs.slice(1))\n        position = -1\n\n        while (++position < nodes.length) {\n          node = nodes[position]\n\n          if (node.type === 'text') {\n            subhandler(node, parent)\n          } else {\n            search(node, settings, subhandler)\n          }\n        }\n      }\n\n      return index + nodes.length + 1\n    }\n  }\n}\n\nfunction search(tree, settings, handler) {\n  var ignored = convert(settings.ignore || [])\n  var result = []\n\n  visit(tree, 'text', visitor)\n\n  return result\n\n  function visitor(node, parents) {\n    var index = -1\n    var parent\n    var grandparent\n\n    while (++index < parents.length) {\n      parent = parents[index]\n\n      if (\n        ignored(\n          parent,\n          grandparent ? grandparent.children.indexOf(parent) : undefined,\n          grandparent\n        )\n      ) {\n        return\n      }\n\n      grandparent = parent\n    }\n\n    return handler(node, grandparent)\n  }\n}\n\nfunction toPairs(schema) {\n  var result = []\n  var key\n  var index\n\n  if (typeof schema !== 'object') {\n    throw new Error('Expected array or object as schema')\n  }\n\n  if ('length' in schema) {\n    index = -1\n\n    while (++index < schema.length) {\n      result.push([\n        toExpression(schema[index][0]),\n        toFunction(schema[index][1])\n      ])\n    }\n  } else {\n    for (key in schema) {\n      result.push([toExpression(key), toFunction(schema[key])])\n    }\n  }\n\n  return result\n}\n\nfunction toExpression(find) {\n  return typeof find === 'string' ? new RegExp(escape(find), 'g') : find\n}\n\nfunction toFunction(replace) {\n  return typeof replace === 'function' ? replace : returner\n\n  function returner() {\n    return replace\n  }\n}\n"],"mappings":"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"},"metadata":{},"sourceType":"script"}