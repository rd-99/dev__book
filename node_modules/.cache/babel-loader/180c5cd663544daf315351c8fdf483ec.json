{"ast":null,"code":"\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nvar tslib_1 = require(\"tslib\");\nvar assert_1 = tslib_1.__importDefault(require(\"assert\"));\nvar types = tslib_1.__importStar(require(\"ast-types\"));\nvar util = tslib_1.__importStar(require(\"./util\"));\nvar n = types.namedTypes;\nvar isArray = types.builtInTypes.array;\nvar isNumber = types.builtInTypes.number;\nvar PRECEDENCE = {};\n[[\"||\"], [\"&&\"], [\"|\"], [\"^\"], [\"&\"], [\"==\", \"===\", \"!=\", \"!==\"], [\"<\", \">\", \"<=\", \">=\", \"in\", \"instanceof\"], [\">>\", \"<<\", \">>>\"], [\"+\", \"-\"], [\"*\", \"/\", \"%\"], [\"**\"]].forEach(function (tier, i) {\n  tier.forEach(function (op) {\n    PRECEDENCE[op] = i;\n  });\n});\nvar FastPath = function FastPath(value) {\n  assert_1.default.ok(this instanceof FastPath);\n  this.stack = [value];\n};\nvar FPp = FastPath.prototype;\n// Static convenience function for coercing a value to a FastPath.\nFastPath.from = function (obj) {\n  if (obj instanceof FastPath) {\n    // Return a defensive copy of any existing FastPath instances.\n    return obj.copy();\n  }\n  if (obj instanceof types.NodePath) {\n    // For backwards compatibility, unroll NodePath instances into\n    // lightweight FastPath [..., name, value] stacks.\n    var copy = Object.create(FastPath.prototype);\n    var stack = [obj.value];\n    for (var pp = void 0; pp = obj.parentPath; obj = pp) stack.push(obj.name, pp.value);\n    copy.stack = stack.reverse();\n    return copy;\n  }\n  // Otherwise use obj as the value of the new FastPath instance.\n  return new FastPath(obj);\n};\nFPp.copy = function copy() {\n  var copy = Object.create(FastPath.prototype);\n  copy.stack = this.stack.slice(0);\n  return copy;\n};\n// The name of the current property is always the penultimate element of\n// this.stack, and always a String.\nFPp.getName = function getName() {\n  var s = this.stack;\n  var len = s.length;\n  if (len > 1) {\n    return s[len - 2];\n  }\n  // Since the name is always a string, null is a safe sentinel value to\n  // return if we do not know the name of the (root) value.\n  return null;\n};\n// The value of the current property is always the final element of\n// this.stack.\nFPp.getValue = function getValue() {\n  var s = this.stack;\n  return s[s.length - 1];\n};\nFPp.valueIsDuplicate = function () {\n  var s = this.stack;\n  var valueIndex = s.length - 1;\n  return s.lastIndexOf(s[valueIndex], valueIndex - 1) >= 0;\n};\nfunction getNodeHelper(path, count) {\n  var s = path.stack;\n  for (var i = s.length - 1; i >= 0; i -= 2) {\n    var value = s[i];\n    if (n.Node.check(value) && --count < 0) {\n      return value;\n    }\n  }\n  return null;\n}\nFPp.getNode = function getNode(count) {\n  if (count === void 0) {\n    count = 0;\n  }\n  return getNodeHelper(this, ~~count);\n};\nFPp.getParentNode = function getParentNode(count) {\n  if (count === void 0) {\n    count = 0;\n  }\n  return getNodeHelper(this, ~~count + 1);\n};\n// The length of the stack can be either even or odd, depending on whether\n// or not we have a name for the root value. The difference between the\n// index of the root value and the index of the final value is always\n// even, though, which allows us to return the root value in constant time\n// (i.e. without iterating backwards through the stack).\nFPp.getRootValue = function getRootValue() {\n  var s = this.stack;\n  if (s.length % 2 === 0) {\n    return s[1];\n  }\n  return s[0];\n};\n// Temporarily push properties named by string arguments given after the\n// callback function onto this.stack, then call the callback with a\n// reference to this (modified) FastPath object. Note that the stack will\n// be restored to its original state after the callback is finished, so it\n// is probably a mistake to retain a reference to the path.\nFPp.call = function call(callback /*, name1, name2, ... */) {\n  var s = this.stack;\n  var origLen = s.length;\n  var value = s[origLen - 1];\n  var argc = arguments.length;\n  for (var i = 1; i < argc; ++i) {\n    var name = arguments[i];\n    value = value[name];\n    s.push(name, value);\n  }\n  var result = callback(this);\n  s.length = origLen;\n  return result;\n};\n// Similar to FastPath.prototype.call, except that the value obtained by\n// accessing this.getValue()[name1][name2]... should be array-like. The\n// callback will be called with a reference to this path object for each\n// element of the array.\nFPp.each = function each(callback /*, name1, name2, ... */) {\n  var s = this.stack;\n  var origLen = s.length;\n  var value = s[origLen - 1];\n  var argc = arguments.length;\n  for (var i = 1; i < argc; ++i) {\n    var name = arguments[i];\n    value = value[name];\n    s.push(name, value);\n  }\n  for (var i = 0; i < value.length; ++i) {\n    if (i in value) {\n      s.push(i, value[i]);\n      // If the callback needs to know the value of i, call\n      // path.getName(), assuming path is the parameter name.\n      callback(this);\n      s.length -= 2;\n    }\n  }\n  s.length = origLen;\n};\n// Similar to FastPath.prototype.each, except that the results of the\n// callback function invocations are stored in an array and returned at\n// the end of the iteration.\nFPp.map = function map(callback /*, name1, name2, ... */) {\n  var s = this.stack;\n  var origLen = s.length;\n  var value = s[origLen - 1];\n  var argc = arguments.length;\n  for (var i = 1; i < argc; ++i) {\n    var name = arguments[i];\n    value = value[name];\n    s.push(name, value);\n  }\n  var result = new Array(value.length);\n  for (var i = 0; i < value.length; ++i) {\n    if (i in value) {\n      s.push(i, value[i]);\n      result[i] = callback(this, i);\n      s.length -= 2;\n    }\n  }\n  s.length = origLen;\n  return result;\n};\n// Returns true if the node at the tip of the path is wrapped with\n// parentheses, OR if the only reason the node needed parentheses was that\n// it couldn't be the first expression in the enclosing statement (see\n// FastPath#canBeFirstInStatement), and it has an opening `(` character.\n// For example, the FunctionExpression in `(function(){}())` appears to\n// need parentheses only because it's the first expression in the AST, but\n// since it happens to be preceded by a `(` (which is not apparent from\n// the AST but can be determined using FastPath#getPrevToken), there is no\n// ambiguity about how to parse it, so it counts as having parentheses,\n// even though it is not immediately followed by a `)`.\nFPp.hasParens = function () {\n  var node = this.getNode();\n  var prevToken = this.getPrevToken(node);\n  if (!prevToken) {\n    return false;\n  }\n  var nextToken = this.getNextToken(node);\n  if (!nextToken) {\n    return false;\n  }\n  if (prevToken.value === \"(\") {\n    if (nextToken.value === \")\") {\n      // If the node preceded by a `(` token and followed by a `)` token,\n      // then of course it has parentheses.\n      return true;\n    }\n    // If this is one of the few Expression types that can't come first in\n    // the enclosing statement because of parsing ambiguities (namely,\n    // FunctionExpression, ObjectExpression, and ClassExpression) and\n    // this.firstInStatement() returns true, and the node would not need\n    // parentheses in an expression context because this.needsParens(true)\n    // returns false, then it just needs an opening parenthesis to resolve\n    // the parsing ambiguity that made it appear to need parentheses.\n    var justNeedsOpeningParen = !this.canBeFirstInStatement() && this.firstInStatement() && !this.needsParens(true);\n    if (justNeedsOpeningParen) {\n      return true;\n    }\n  }\n  return false;\n};\nFPp.getPrevToken = function (node) {\n  node = node || this.getNode();\n  var loc = node && node.loc;\n  var tokens = loc && loc.tokens;\n  if (tokens && loc.start.token > 0) {\n    var token = tokens[loc.start.token - 1];\n    if (token) {\n      // Do not return tokens that fall outside the root subtree.\n      var rootLoc = this.getRootValue().loc;\n      if (util.comparePos(rootLoc.start, token.loc.start) <= 0) {\n        return token;\n      }\n    }\n  }\n  return null;\n};\nFPp.getNextToken = function (node) {\n  node = node || this.getNode();\n  var loc = node && node.loc;\n  var tokens = loc && loc.tokens;\n  if (tokens && loc.end.token < tokens.length) {\n    var token = tokens[loc.end.token];\n    if (token) {\n      // Do not return tokens that fall outside the root subtree.\n      var rootLoc = this.getRootValue().loc;\n      if (util.comparePos(token.loc.end, rootLoc.end) <= 0) {\n        return token;\n      }\n    }\n  }\n  return null;\n};\n// Inspired by require(\"ast-types\").NodePath.prototype.needsParens, but\n// more efficient because we're iterating backwards through a stack.\nFPp.needsParens = function (assumeExpressionContext) {\n  var node = this.getNode();\n  // This needs to come before `if (!parent) { return false }` because\n  // an object destructuring assignment requires parens for\n  // correctness even when it's the topmost expression.\n  if (node.type === \"AssignmentExpression\" && node.left.type === \"ObjectPattern\") {\n    return true;\n  }\n  var parent = this.getParentNode();\n  if (!parent) {\n    return false;\n  }\n  var name = this.getName();\n  // If the value of this path is some child of a Node and not a Node\n  // itself, then it doesn't need parentheses. Only Node objects (in fact,\n  // only Expression nodes) need parentheses.\n  if (this.getValue() !== node) {\n    return false;\n  }\n  // Only statements don't need parentheses.\n  if (n.Statement.check(node)) {\n    return false;\n  }\n  // Identifiers never need parentheses.\n  if (node.type === \"Identifier\") {\n    return false;\n  }\n  if (parent.type === \"ParenthesizedExpression\" || node.extra && node.extra.parenthesized) {\n    return false;\n  }\n  switch (node.type) {\n    case \"UnaryExpression\":\n    case \"SpreadElement\":\n    case \"SpreadProperty\":\n      return parent.type === \"MemberExpression\" && name === \"object\" && parent.object === node;\n    case \"BinaryExpression\":\n    case \"LogicalExpression\":\n      switch (parent.type) {\n        case \"CallExpression\":\n          return name === \"callee\" && parent.callee === node;\n        case \"UnaryExpression\":\n        case \"SpreadElement\":\n        case \"SpreadProperty\":\n          return true;\n        case \"MemberExpression\":\n          return name === \"object\" && parent.object === node;\n        case \"BinaryExpression\":\n        case \"LogicalExpression\":\n          {\n            var po = parent.operator;\n            var pp = PRECEDENCE[po];\n            var no = node.operator;\n            var np = PRECEDENCE[no];\n            if (pp > np) {\n              return true;\n            }\n            if (pp === np && name === \"right\") {\n              assert_1.default.strictEqual(parent.right, node);\n              return true;\n            }\n            break;\n          }\n        default:\n          return false;\n      }\n      break;\n    case \"SequenceExpression\":\n      switch (parent.type) {\n        case \"ReturnStatement\":\n          return false;\n        case \"ForStatement\":\n          // Although parentheses wouldn't hurt around sequence expressions in\n          // the head of for loops, traditional style dictates that e.g. i++,\n          // j++ should not be wrapped with parentheses.\n          return false;\n        case \"ExpressionStatement\":\n          return name !== \"expression\";\n        default:\n          // Otherwise err on the side of overparenthesization, adding\n          // explicit exceptions above if this proves overzealous.\n          return true;\n      }\n    case \"IntersectionTypeAnnotation\":\n    case \"UnionTypeAnnotation\":\n      return parent.type === \"NullableTypeAnnotation\";\n    case \"Literal\":\n      return parent.type === \"MemberExpression\" && isNumber.check(node.value) && name === \"object\" && parent.object === node;\n    // Babel 6 Literal split\n    case \"NumericLiteral\":\n      return parent.type === \"MemberExpression\" && name === \"object\" && parent.object === node;\n    case \"YieldExpression\":\n    case \"AwaitExpression\":\n    case \"AssignmentExpression\":\n    case \"ConditionalExpression\":\n      switch (parent.type) {\n        case \"UnaryExpression\":\n        case \"SpreadElement\":\n        case \"SpreadProperty\":\n        case \"BinaryExpression\":\n        case \"LogicalExpression\":\n          return true;\n        case \"CallExpression\":\n        case \"NewExpression\":\n          return name === \"callee\" && parent.callee === node;\n        case \"ConditionalExpression\":\n          return name === \"test\" && parent.test === node;\n        case \"MemberExpression\":\n          return name === \"object\" && parent.object === node;\n        default:\n          return false;\n      }\n    case \"ArrowFunctionExpression\":\n      if (n.CallExpression.check(parent) && name === \"callee\" && parent.callee === node) {\n        return true;\n      }\n      if (n.MemberExpression.check(parent) && name === \"object\" && parent.object === node) {\n        return true;\n      }\n      if (n.TSAsExpression && n.TSAsExpression.check(parent) && name === \"expression\" && parent.expression === node) {\n        return true;\n      }\n      return isBinary(parent);\n    case \"ObjectExpression\":\n      if (parent.type === \"ArrowFunctionExpression\" && name === \"body\" && parent.body === node) {\n        return true;\n      }\n      break;\n    case \"TSAsExpression\":\n      if (parent.type === \"ArrowFunctionExpression\" && name === \"body\" && parent.body === node && node.expression.type === \"ObjectExpression\") {\n        return true;\n      }\n      break;\n    case \"CallExpression\":\n      if (name === \"declaration\" && n.ExportDefaultDeclaration.check(parent) && n.FunctionExpression.check(node.callee)) {\n        return true;\n      }\n  }\n  if (parent.type === \"NewExpression\" && name === \"callee\" && parent.callee === node) {\n    return containsCallExpression(node);\n  }\n  if (assumeExpressionContext !== true && !this.canBeFirstInStatement() && this.firstInStatement()) {\n    return true;\n  }\n  return false;\n};\nfunction isBinary(node) {\n  return n.BinaryExpression.check(node) || n.LogicalExpression.check(node);\n}\n// @ts-ignore 'isUnaryLike' is declared but its value is never read. [6133]\nfunction isUnaryLike(node) {\n  return n.UnaryExpression.check(node) ||\n  // I considered making SpreadElement and SpreadProperty subtypes of\n  // UnaryExpression, but they're not really Expression nodes.\n  n.SpreadElement && n.SpreadElement.check(node) || n.SpreadProperty && n.SpreadProperty.check(node);\n}\nfunction containsCallExpression(node) {\n  if (n.CallExpression.check(node)) {\n    return true;\n  }\n  if (isArray.check(node)) {\n    return node.some(containsCallExpression);\n  }\n  if (n.Node.check(node)) {\n    return types.someField(node, function (_name, child) {\n      return containsCallExpression(child);\n    });\n  }\n  return false;\n}\nFPp.canBeFirstInStatement = function () {\n  var node = this.getNode();\n  if (n.FunctionExpression.check(node)) {\n    return false;\n  }\n  if (n.ObjectExpression.check(node)) {\n    return false;\n  }\n  if (n.ClassExpression.check(node)) {\n    return false;\n  }\n  return true;\n};\nFPp.firstInStatement = function () {\n  var s = this.stack;\n  var parentName, parent;\n  var childName, child;\n  for (var i = s.length - 1; i >= 0; i -= 2) {\n    if (n.Node.check(s[i])) {\n      childName = parentName;\n      child = parent;\n      parentName = s[i - 1];\n      parent = s[i];\n    }\n    if (!parent || !child) {\n      continue;\n    }\n    if (n.BlockStatement.check(parent) && parentName === \"body\" && childName === 0) {\n      assert_1.default.strictEqual(parent.body[0], child);\n      return true;\n    }\n    if (n.ExpressionStatement.check(parent) && childName === \"expression\") {\n      assert_1.default.strictEqual(parent.expression, child);\n      return true;\n    }\n    if (n.AssignmentExpression.check(parent) && childName === \"left\") {\n      assert_1.default.strictEqual(parent.left, child);\n      return true;\n    }\n    if (n.ArrowFunctionExpression.check(parent) && childName === \"body\") {\n      assert_1.default.strictEqual(parent.body, child);\n      return true;\n    }\n    if (n.SequenceExpression.check(parent) && parentName === \"expressions\" && childName === 0) {\n      assert_1.default.strictEqual(parent.expressions[0], child);\n      continue;\n    }\n    if (n.CallExpression.check(parent) && childName === \"callee\") {\n      assert_1.default.strictEqual(parent.callee, child);\n      continue;\n    }\n    if (n.MemberExpression.check(parent) && childName === \"object\") {\n      assert_1.default.strictEqual(parent.object, child);\n      continue;\n    }\n    if (n.ConditionalExpression.check(parent) && childName === \"test\") {\n      assert_1.default.strictEqual(parent.test, child);\n      continue;\n    }\n    if (isBinary(parent) && childName === \"left\") {\n      assert_1.default.strictEqual(parent.left, child);\n      continue;\n    }\n    if (n.UnaryExpression.check(parent) && !parent.prefix && childName === \"argument\") {\n      assert_1.default.strictEqual(parent.argument, child);\n      continue;\n    }\n    return false;\n  }\n  return true;\n};\nexports.default = FastPath;","map":{"version":3,"names":["Object","defineProperty","exports","value","tslib_1","require","assert_1","__importDefault","types","__importStar","util","n","namedTypes","isArray","builtInTypes","array","isNumber","number","PRECEDENCE","forEach","tier","i","op","FastPath","default","ok","stack","FPp","prototype","from","obj","copy","NodePath","create","pp","parentPath","push","name","reverse","slice","getName","s","len","length","getValue","valueIsDuplicate","valueIndex","lastIndexOf","getNodeHelper","path","count","Node","check","getNode","getParentNode","getRootValue","call","callback","origLen","argc","arguments","result","each","map","Array","hasParens","node","prevToken","getPrevToken","nextToken","getNextToken","justNeedsOpeningParen","canBeFirstInStatement","firstInStatement","needsParens","loc","tokens","start","token","rootLoc","comparePos","end","assumeExpressionContext","type","left","parent","Statement","extra","parenthesized","object","callee","po","operator","no","np","strictEqual","right","test","CallExpression","MemberExpression","TSAsExpression","expression","isBinary","body","ExportDefaultDeclaration","FunctionExpression","containsCallExpression","BinaryExpression","LogicalExpression","isUnaryLike","UnaryExpression","SpreadElement","SpreadProperty","some","someField","_name","child","ObjectExpression","ClassExpression","parentName","childName","BlockStatement","ExpressionStatement","AssignmentExpression","ArrowFunctionExpression","SequenceExpression","expressions","ConditionalExpression","prefix","argument"],"sources":["C:/Users/Acer/Desktop/dev__book/dev__book/node_modules/jscodeshift/node_modules/recast/lib/fast-path.js"],"sourcesContent":["\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nvar tslib_1 = require(\"tslib\");\nvar assert_1 = tslib_1.__importDefault(require(\"assert\"));\nvar types = tslib_1.__importStar(require(\"ast-types\"));\nvar util = tslib_1.__importStar(require(\"./util\"));\nvar n = types.namedTypes;\nvar isArray = types.builtInTypes.array;\nvar isNumber = types.builtInTypes.number;\nvar PRECEDENCE = {};\n[\n    [\"||\"],\n    [\"&&\"],\n    [\"|\"],\n    [\"^\"],\n    [\"&\"],\n    [\"==\", \"===\", \"!=\", \"!==\"],\n    [\"<\", \">\", \"<=\", \">=\", \"in\", \"instanceof\"],\n    [\">>\", \"<<\", \">>>\"],\n    [\"+\", \"-\"],\n    [\"*\", \"/\", \"%\"],\n    [\"**\"],\n].forEach(function (tier, i) {\n    tier.forEach(function (op) {\n        PRECEDENCE[op] = i;\n    });\n});\nvar FastPath = function FastPath(value) {\n    assert_1.default.ok(this instanceof FastPath);\n    this.stack = [value];\n};\nvar FPp = FastPath.prototype;\n// Static convenience function for coercing a value to a FastPath.\nFastPath.from = function (obj) {\n    if (obj instanceof FastPath) {\n        // Return a defensive copy of any existing FastPath instances.\n        return obj.copy();\n    }\n    if (obj instanceof types.NodePath) {\n        // For backwards compatibility, unroll NodePath instances into\n        // lightweight FastPath [..., name, value] stacks.\n        var copy = Object.create(FastPath.prototype);\n        var stack = [obj.value];\n        for (var pp = void 0; (pp = obj.parentPath); obj = pp)\n            stack.push(obj.name, pp.value);\n        copy.stack = stack.reverse();\n        return copy;\n    }\n    // Otherwise use obj as the value of the new FastPath instance.\n    return new FastPath(obj);\n};\nFPp.copy = function copy() {\n    var copy = Object.create(FastPath.prototype);\n    copy.stack = this.stack.slice(0);\n    return copy;\n};\n// The name of the current property is always the penultimate element of\n// this.stack, and always a String.\nFPp.getName = function getName() {\n    var s = this.stack;\n    var len = s.length;\n    if (len > 1) {\n        return s[len - 2];\n    }\n    // Since the name is always a string, null is a safe sentinel value to\n    // return if we do not know the name of the (root) value.\n    return null;\n};\n// The value of the current property is always the final element of\n// this.stack.\nFPp.getValue = function getValue() {\n    var s = this.stack;\n    return s[s.length - 1];\n};\nFPp.valueIsDuplicate = function () {\n    var s = this.stack;\n    var valueIndex = s.length - 1;\n    return s.lastIndexOf(s[valueIndex], valueIndex - 1) >= 0;\n};\nfunction getNodeHelper(path, count) {\n    var s = path.stack;\n    for (var i = s.length - 1; i >= 0; i -= 2) {\n        var value = s[i];\n        if (n.Node.check(value) && --count < 0) {\n            return value;\n        }\n    }\n    return null;\n}\nFPp.getNode = function getNode(count) {\n    if (count === void 0) { count = 0; }\n    return getNodeHelper(this, ~~count);\n};\nFPp.getParentNode = function getParentNode(count) {\n    if (count === void 0) { count = 0; }\n    return getNodeHelper(this, ~~count + 1);\n};\n// The length of the stack can be either even or odd, depending on whether\n// or not we have a name for the root value. The difference between the\n// index of the root value and the index of the final value is always\n// even, though, which allows us to return the root value in constant time\n// (i.e. without iterating backwards through the stack).\nFPp.getRootValue = function getRootValue() {\n    var s = this.stack;\n    if (s.length % 2 === 0) {\n        return s[1];\n    }\n    return s[0];\n};\n// Temporarily push properties named by string arguments given after the\n// callback function onto this.stack, then call the callback with a\n// reference to this (modified) FastPath object. Note that the stack will\n// be restored to its original state after the callback is finished, so it\n// is probably a mistake to retain a reference to the path.\nFPp.call = function call(callback /*, name1, name2, ... */) {\n    var s = this.stack;\n    var origLen = s.length;\n    var value = s[origLen - 1];\n    var argc = arguments.length;\n    for (var i = 1; i < argc; ++i) {\n        var name = arguments[i];\n        value = value[name];\n        s.push(name, value);\n    }\n    var result = callback(this);\n    s.length = origLen;\n    return result;\n};\n// Similar to FastPath.prototype.call, except that the value obtained by\n// accessing this.getValue()[name1][name2]... should be array-like. The\n// callback will be called with a reference to this path object for each\n// element of the array.\nFPp.each = function each(callback /*, name1, name2, ... */) {\n    var s = this.stack;\n    var origLen = s.length;\n    var value = s[origLen - 1];\n    var argc = arguments.length;\n    for (var i = 1; i < argc; ++i) {\n        var name = arguments[i];\n        value = value[name];\n        s.push(name, value);\n    }\n    for (var i = 0; i < value.length; ++i) {\n        if (i in value) {\n            s.push(i, value[i]);\n            // If the callback needs to know the value of i, call\n            // path.getName(), assuming path is the parameter name.\n            callback(this);\n            s.length -= 2;\n        }\n    }\n    s.length = origLen;\n};\n// Similar to FastPath.prototype.each, except that the results of the\n// callback function invocations are stored in an array and returned at\n// the end of the iteration.\nFPp.map = function map(callback /*, name1, name2, ... */) {\n    var s = this.stack;\n    var origLen = s.length;\n    var value = s[origLen - 1];\n    var argc = arguments.length;\n    for (var i = 1; i < argc; ++i) {\n        var name = arguments[i];\n        value = value[name];\n        s.push(name, value);\n    }\n    var result = new Array(value.length);\n    for (var i = 0; i < value.length; ++i) {\n        if (i in value) {\n            s.push(i, value[i]);\n            result[i] = callback(this, i);\n            s.length -= 2;\n        }\n    }\n    s.length = origLen;\n    return result;\n};\n// Returns true if the node at the tip of the path is wrapped with\n// parentheses, OR if the only reason the node needed parentheses was that\n// it couldn't be the first expression in the enclosing statement (see\n// FastPath#canBeFirstInStatement), and it has an opening `(` character.\n// For example, the FunctionExpression in `(function(){}())` appears to\n// need parentheses only because it's the first expression in the AST, but\n// since it happens to be preceded by a `(` (which is not apparent from\n// the AST but can be determined using FastPath#getPrevToken), there is no\n// ambiguity about how to parse it, so it counts as having parentheses,\n// even though it is not immediately followed by a `)`.\nFPp.hasParens = function () {\n    var node = this.getNode();\n    var prevToken = this.getPrevToken(node);\n    if (!prevToken) {\n        return false;\n    }\n    var nextToken = this.getNextToken(node);\n    if (!nextToken) {\n        return false;\n    }\n    if (prevToken.value === \"(\") {\n        if (nextToken.value === \")\") {\n            // If the node preceded by a `(` token and followed by a `)` token,\n            // then of course it has parentheses.\n            return true;\n        }\n        // If this is one of the few Expression types that can't come first in\n        // the enclosing statement because of parsing ambiguities (namely,\n        // FunctionExpression, ObjectExpression, and ClassExpression) and\n        // this.firstInStatement() returns true, and the node would not need\n        // parentheses in an expression context because this.needsParens(true)\n        // returns false, then it just needs an opening parenthesis to resolve\n        // the parsing ambiguity that made it appear to need parentheses.\n        var justNeedsOpeningParen = !this.canBeFirstInStatement() &&\n            this.firstInStatement() &&\n            !this.needsParens(true);\n        if (justNeedsOpeningParen) {\n            return true;\n        }\n    }\n    return false;\n};\nFPp.getPrevToken = function (node) {\n    node = node || this.getNode();\n    var loc = node && node.loc;\n    var tokens = loc && loc.tokens;\n    if (tokens && loc.start.token > 0) {\n        var token = tokens[loc.start.token - 1];\n        if (token) {\n            // Do not return tokens that fall outside the root subtree.\n            var rootLoc = this.getRootValue().loc;\n            if (util.comparePos(rootLoc.start, token.loc.start) <= 0) {\n                return token;\n            }\n        }\n    }\n    return null;\n};\nFPp.getNextToken = function (node) {\n    node = node || this.getNode();\n    var loc = node && node.loc;\n    var tokens = loc && loc.tokens;\n    if (tokens && loc.end.token < tokens.length) {\n        var token = tokens[loc.end.token];\n        if (token) {\n            // Do not return tokens that fall outside the root subtree.\n            var rootLoc = this.getRootValue().loc;\n            if (util.comparePos(token.loc.end, rootLoc.end) <= 0) {\n                return token;\n            }\n        }\n    }\n    return null;\n};\n// Inspired by require(\"ast-types\").NodePath.prototype.needsParens, but\n// more efficient because we're iterating backwards through a stack.\nFPp.needsParens = function (assumeExpressionContext) {\n    var node = this.getNode();\n    // This needs to come before `if (!parent) { return false }` because\n    // an object destructuring assignment requires parens for\n    // correctness even when it's the topmost expression.\n    if (node.type === \"AssignmentExpression\" &&\n        node.left.type === \"ObjectPattern\") {\n        return true;\n    }\n    var parent = this.getParentNode();\n    if (!parent) {\n        return false;\n    }\n    var name = this.getName();\n    // If the value of this path is some child of a Node and not a Node\n    // itself, then it doesn't need parentheses. Only Node objects (in fact,\n    // only Expression nodes) need parentheses.\n    if (this.getValue() !== node) {\n        return false;\n    }\n    // Only statements don't need parentheses.\n    if (n.Statement.check(node)) {\n        return false;\n    }\n    // Identifiers never need parentheses.\n    if (node.type === \"Identifier\") {\n        return false;\n    }\n    if (parent.type === \"ParenthesizedExpression\" ||\n        (node.extra && node.extra.parenthesized)) {\n        return false;\n    }\n    switch (node.type) {\n        case \"UnaryExpression\":\n        case \"SpreadElement\":\n        case \"SpreadProperty\":\n            return (parent.type === \"MemberExpression\" &&\n                name === \"object\" &&\n                parent.object === node);\n        case \"BinaryExpression\":\n        case \"LogicalExpression\":\n            switch (parent.type) {\n                case \"CallExpression\":\n                    return name === \"callee\" && parent.callee === node;\n                case \"UnaryExpression\":\n                case \"SpreadElement\":\n                case \"SpreadProperty\":\n                    return true;\n                case \"MemberExpression\":\n                    return name === \"object\" && parent.object === node;\n                case \"BinaryExpression\":\n                case \"LogicalExpression\": {\n                    var po = parent.operator;\n                    var pp = PRECEDENCE[po];\n                    var no = node.operator;\n                    var np = PRECEDENCE[no];\n                    if (pp > np) {\n                        return true;\n                    }\n                    if (pp === np && name === \"right\") {\n                        assert_1.default.strictEqual(parent.right, node);\n                        return true;\n                    }\n                    break;\n                }\n                default:\n                    return false;\n            }\n            break;\n        case \"SequenceExpression\":\n            switch (parent.type) {\n                case \"ReturnStatement\":\n                    return false;\n                case \"ForStatement\":\n                    // Although parentheses wouldn't hurt around sequence expressions in\n                    // the head of for loops, traditional style dictates that e.g. i++,\n                    // j++ should not be wrapped with parentheses.\n                    return false;\n                case \"ExpressionStatement\":\n                    return name !== \"expression\";\n                default:\n                    // Otherwise err on the side of overparenthesization, adding\n                    // explicit exceptions above if this proves overzealous.\n                    return true;\n            }\n        case \"IntersectionTypeAnnotation\":\n        case \"UnionTypeAnnotation\":\n            return parent.type === \"NullableTypeAnnotation\";\n        case \"Literal\":\n            return (parent.type === \"MemberExpression\" &&\n                isNumber.check(node.value) &&\n                name === \"object\" &&\n                parent.object === node);\n        // Babel 6 Literal split\n        case \"NumericLiteral\":\n            return (parent.type === \"MemberExpression\" &&\n                name === \"object\" &&\n                parent.object === node);\n        case \"YieldExpression\":\n        case \"AwaitExpression\":\n        case \"AssignmentExpression\":\n        case \"ConditionalExpression\":\n            switch (parent.type) {\n                case \"UnaryExpression\":\n                case \"SpreadElement\":\n                case \"SpreadProperty\":\n                case \"BinaryExpression\":\n                case \"LogicalExpression\":\n                    return true;\n                case \"CallExpression\":\n                case \"NewExpression\":\n                    return name === \"callee\" && parent.callee === node;\n                case \"ConditionalExpression\":\n                    return name === \"test\" && parent.test === node;\n                case \"MemberExpression\":\n                    return name === \"object\" && parent.object === node;\n                default:\n                    return false;\n            }\n        case \"ArrowFunctionExpression\":\n            if (n.CallExpression.check(parent) &&\n                name === \"callee\" &&\n                parent.callee === node) {\n                return true;\n            }\n            if (n.MemberExpression.check(parent) &&\n                name === \"object\" &&\n                parent.object === node) {\n                return true;\n            }\n            if (n.TSAsExpression &&\n                n.TSAsExpression.check(parent) &&\n                name === \"expression\" &&\n                parent.expression === node) {\n                return true;\n            }\n            return isBinary(parent);\n        case \"ObjectExpression\":\n            if (parent.type === \"ArrowFunctionExpression\" &&\n                name === \"body\" &&\n                parent.body === node) {\n                return true;\n            }\n            break;\n        case \"TSAsExpression\":\n            if (parent.type === \"ArrowFunctionExpression\" &&\n                name === \"body\" &&\n                parent.body === node &&\n                node.expression.type === \"ObjectExpression\") {\n                return true;\n            }\n            break;\n        case \"CallExpression\":\n            if (name === \"declaration\" &&\n                n.ExportDefaultDeclaration.check(parent) &&\n                n.FunctionExpression.check(node.callee)) {\n                return true;\n            }\n    }\n    if (parent.type === \"NewExpression\" &&\n        name === \"callee\" &&\n        parent.callee === node) {\n        return containsCallExpression(node);\n    }\n    if (assumeExpressionContext !== true &&\n        !this.canBeFirstInStatement() &&\n        this.firstInStatement()) {\n        return true;\n    }\n    return false;\n};\nfunction isBinary(node) {\n    return n.BinaryExpression.check(node) || n.LogicalExpression.check(node);\n}\n// @ts-ignore 'isUnaryLike' is declared but its value is never read. [6133]\nfunction isUnaryLike(node) {\n    return (n.UnaryExpression.check(node) ||\n        // I considered making SpreadElement and SpreadProperty subtypes of\n        // UnaryExpression, but they're not really Expression nodes.\n        (n.SpreadElement && n.SpreadElement.check(node)) ||\n        (n.SpreadProperty && n.SpreadProperty.check(node)));\n}\nfunction containsCallExpression(node) {\n    if (n.CallExpression.check(node)) {\n        return true;\n    }\n    if (isArray.check(node)) {\n        return node.some(containsCallExpression);\n    }\n    if (n.Node.check(node)) {\n        return types.someField(node, function (_name, child) {\n            return containsCallExpression(child);\n        });\n    }\n    return false;\n}\nFPp.canBeFirstInStatement = function () {\n    var node = this.getNode();\n    if (n.FunctionExpression.check(node)) {\n        return false;\n    }\n    if (n.ObjectExpression.check(node)) {\n        return false;\n    }\n    if (n.ClassExpression.check(node)) {\n        return false;\n    }\n    return true;\n};\nFPp.firstInStatement = function () {\n    var s = this.stack;\n    var parentName, parent;\n    var childName, child;\n    for (var i = s.length - 1; i >= 0; i -= 2) {\n        if (n.Node.check(s[i])) {\n            childName = parentName;\n            child = parent;\n            parentName = s[i - 1];\n            parent = s[i];\n        }\n        if (!parent || !child) {\n            continue;\n        }\n        if (n.BlockStatement.check(parent) &&\n            parentName === \"body\" &&\n            childName === 0) {\n            assert_1.default.strictEqual(parent.body[0], child);\n            return true;\n        }\n        if (n.ExpressionStatement.check(parent) && childName === \"expression\") {\n            assert_1.default.strictEqual(parent.expression, child);\n            return true;\n        }\n        if (n.AssignmentExpression.check(parent) && childName === \"left\") {\n            assert_1.default.strictEqual(parent.left, child);\n            return true;\n        }\n        if (n.ArrowFunctionExpression.check(parent) && childName === \"body\") {\n            assert_1.default.strictEqual(parent.body, child);\n            return true;\n        }\n        if (n.SequenceExpression.check(parent) &&\n            parentName === \"expressions\" &&\n            childName === 0) {\n            assert_1.default.strictEqual(parent.expressions[0], child);\n            continue;\n        }\n        if (n.CallExpression.check(parent) && childName === \"callee\") {\n            assert_1.default.strictEqual(parent.callee, child);\n            continue;\n        }\n        if (n.MemberExpression.check(parent) && childName === \"object\") {\n            assert_1.default.strictEqual(parent.object, child);\n            continue;\n        }\n        if (n.ConditionalExpression.check(parent) && childName === \"test\") {\n            assert_1.default.strictEqual(parent.test, child);\n            continue;\n        }\n        if (isBinary(parent) && childName === \"left\") {\n            assert_1.default.strictEqual(parent.left, child);\n            continue;\n        }\n        if (n.UnaryExpression.check(parent) &&\n            !parent.prefix &&\n            childName === \"argument\") {\n            assert_1.default.strictEqual(parent.argument, child);\n            continue;\n        }\n        return false;\n    }\n    return true;\n};\nexports.default = FastPath;\n"],"mappings":"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"},"metadata":{},"sourceType":"script"}