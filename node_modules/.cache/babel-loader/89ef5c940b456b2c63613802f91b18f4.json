{"ast":null,"code":"\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.getReprinter = exports.Patcher = void 0;\nvar tslib_1 = require(\"tslib\");\nvar assert_1 = tslib_1.__importDefault(require(\"assert\"));\nvar linesModule = tslib_1.__importStar(require(\"./lines\"));\nvar types = tslib_1.__importStar(require(\"ast-types\"));\nvar Printable = types.namedTypes.Printable;\nvar Expression = types.namedTypes.Expression;\nvar ReturnStatement = types.namedTypes.ReturnStatement;\nvar SourceLocation = types.namedTypes.SourceLocation;\nvar util_1 = require(\"./util\");\nvar fast_path_1 = tslib_1.__importDefault(require(\"./fast-path\"));\nvar isObject = types.builtInTypes.object;\nvar isArray = types.builtInTypes.array;\nvar isString = types.builtInTypes.string;\nvar riskyAdjoiningCharExp = /[0-9a-z_$]/i;\nvar Patcher = function Patcher(lines) {\n  assert_1.default.ok(this instanceof Patcher);\n  assert_1.default.ok(lines instanceof linesModule.Lines);\n  var self = this,\n    replacements = [];\n  self.replace = function (loc, lines) {\n    if (isString.check(lines)) lines = linesModule.fromString(lines);\n    replacements.push({\n      lines: lines,\n      start: loc.start,\n      end: loc.end\n    });\n  };\n  self.get = function (loc) {\n    // If no location is provided, return the complete Lines object.\n    loc = loc || {\n      start: {\n        line: 1,\n        column: 0\n      },\n      end: {\n        line: lines.length,\n        column: lines.getLineLength(lines.length)\n      }\n    };\n    var sliceFrom = loc.start,\n      toConcat = [];\n    function pushSlice(from, to) {\n      assert_1.default.ok(util_1.comparePos(from, to) <= 0);\n      toConcat.push(lines.slice(from, to));\n    }\n    replacements.sort(function (a, b) {\n      return util_1.comparePos(a.start, b.start);\n    }).forEach(function (rep) {\n      if (util_1.comparePos(sliceFrom, rep.start) > 0) {\n        // Ignore nested replacement ranges.\n      } else {\n        pushSlice(sliceFrom, rep.start);\n        toConcat.push(rep.lines);\n        sliceFrom = rep.end;\n      }\n    });\n    pushSlice(sliceFrom, loc.end);\n    return linesModule.concat(toConcat);\n  };\n};\nexports.Patcher = Patcher;\nvar Pp = Patcher.prototype;\nPp.tryToReprintComments = function (newNode, oldNode, print) {\n  var patcher = this;\n  if (!newNode.comments && !oldNode.comments) {\n    // We were (vacuously) able to reprint all the comments!\n    return true;\n  }\n  var newPath = fast_path_1.default.from(newNode);\n  var oldPath = fast_path_1.default.from(oldNode);\n  newPath.stack.push(\"comments\", getSurroundingComments(newNode));\n  oldPath.stack.push(\"comments\", getSurroundingComments(oldNode));\n  var reprints = [];\n  var ableToReprintComments = findArrayReprints(newPath, oldPath, reprints);\n  // No need to pop anything from newPath.stack or oldPath.stack, since\n  // newPath and oldPath are fresh local variables.\n  if (ableToReprintComments && reprints.length > 0) {\n    reprints.forEach(function (reprint) {\n      var oldComment = reprint.oldPath.getValue();\n      assert_1.default.ok(oldComment.leading || oldComment.trailing);\n      patcher.replace(oldComment.loc,\n      // Comments can't have .comments, so it doesn't matter whether we\n      // print with comments or without.\n      print(reprint.newPath).indentTail(oldComment.loc.indent));\n    });\n  }\n  return ableToReprintComments;\n};\n// Get all comments that are either leading or trailing, ignoring any\n// comments that occur inside node.loc. Returns an empty array for nodes\n// with no leading or trailing comments.\nfunction getSurroundingComments(node) {\n  var result = [];\n  if (node.comments && node.comments.length > 0) {\n    node.comments.forEach(function (comment) {\n      if (comment.leading || comment.trailing) {\n        result.push(comment);\n      }\n    });\n  }\n  return result;\n}\nPp.deleteComments = function (node) {\n  if (!node.comments) {\n    return;\n  }\n  var patcher = this;\n  node.comments.forEach(function (comment) {\n    if (comment.leading) {\n      // Delete leading comments along with any trailing whitespace they\n      // might have.\n      patcher.replace({\n        start: comment.loc.start,\n        end: node.loc.lines.skipSpaces(comment.loc.end, false, false)\n      }, \"\");\n    } else if (comment.trailing) {\n      // Delete trailing comments along with any leading whitespace they\n      // might have.\n      patcher.replace({\n        start: node.loc.lines.skipSpaces(comment.loc.start, true, false),\n        end: comment.loc.end\n      }, \"\");\n    }\n  });\n};\nfunction getReprinter(path) {\n  assert_1.default.ok(path instanceof fast_path_1.default);\n  // Make sure that this path refers specifically to a Node, rather than\n  // some non-Node subproperty of a Node.\n  var node = path.getValue();\n  if (!Printable.check(node)) return;\n  var orig = node.original;\n  var origLoc = orig && orig.loc;\n  var lines = origLoc && origLoc.lines;\n  var reprints = [];\n  if (!lines || !findReprints(path, reprints)) return;\n  return function (print) {\n    var patcher = new Patcher(lines);\n    reprints.forEach(function (reprint) {\n      var newNode = reprint.newPath.getValue();\n      var oldNode = reprint.oldPath.getValue();\n      SourceLocation.assert(oldNode.loc, true);\n      var needToPrintNewPathWithComments = !patcher.tryToReprintComments(newNode, oldNode, print);\n      if (needToPrintNewPathWithComments) {\n        // Since we were not able to preserve all leading/trailing\n        // comments, we delete oldNode's comments, print newPath with\n        // comments, and then patch the resulting lines where oldNode used\n        // to be.\n        patcher.deleteComments(oldNode);\n      }\n      var newLines = print(reprint.newPath, {\n        includeComments: needToPrintNewPathWithComments,\n        // If the oldNode we're replacing already had parentheses, we may\n        // not need to print the new node with any extra parentheses,\n        // because the existing parentheses will suffice. However, if the\n        // newNode has a different type than the oldNode, let the printer\n        // decide if reprint.newPath needs parentheses, as usual.\n        avoidRootParens: oldNode.type === newNode.type && reprint.oldPath.hasParens()\n      }).indentTail(oldNode.loc.indent);\n      var nls = needsLeadingSpace(lines, oldNode.loc, newLines);\n      var nts = needsTrailingSpace(lines, oldNode.loc, newLines);\n      // If we try to replace the argument of a ReturnStatement like\n      // return\"asdf\" with e.g. a literal null expression, we run the risk\n      // of ending up with returnnull, so we need to add an extra leading\n      // space in situations where that might happen. Likewise for\n      // \"asdf\"in obj. See #170.\n      if (nls || nts) {\n        var newParts = [];\n        nls && newParts.push(\" \");\n        newParts.push(newLines);\n        nts && newParts.push(\" \");\n        newLines = linesModule.concat(newParts);\n      }\n      patcher.replace(oldNode.loc, newLines);\n    });\n    // Recall that origLoc is the .loc of an ancestor node that is\n    // guaranteed to contain all the reprinted nodes and comments.\n    var patchedLines = patcher.get(origLoc).indentTail(-orig.loc.indent);\n    if (path.needsParens()) {\n      return linesModule.concat([\"(\", patchedLines, \")\"]);\n    }\n    return patchedLines;\n  };\n}\nexports.getReprinter = getReprinter;\n// If the last character before oldLoc and the first character of newLines\n// are both identifier characters, they must be separated by a space,\n// otherwise they will most likely get fused together into a single token.\nfunction needsLeadingSpace(oldLines, oldLoc, newLines) {\n  var posBeforeOldLoc = util_1.copyPos(oldLoc.start);\n  // The character just before the location occupied by oldNode.\n  var charBeforeOldLoc = oldLines.prevPos(posBeforeOldLoc) && oldLines.charAt(posBeforeOldLoc);\n  // First character of the reprinted node.\n  var newFirstChar = newLines.charAt(newLines.firstPos());\n  return charBeforeOldLoc && riskyAdjoiningCharExp.test(charBeforeOldLoc) && newFirstChar && riskyAdjoiningCharExp.test(newFirstChar);\n}\n// If the last character of newLines and the first character after oldLoc\n// are both identifier characters, they must be separated by a space,\n// otherwise they will most likely get fused together into a single token.\nfunction needsTrailingSpace(oldLines, oldLoc, newLines) {\n  // The character just after the location occupied by oldNode.\n  var charAfterOldLoc = oldLines.charAt(oldLoc.end);\n  var newLastPos = newLines.lastPos();\n  // Last character of the reprinted node.\n  var newLastChar = newLines.prevPos(newLastPos) && newLines.charAt(newLastPos);\n  return newLastChar && riskyAdjoiningCharExp.test(newLastChar) && charAfterOldLoc && riskyAdjoiningCharExp.test(charAfterOldLoc);\n}\nfunction findReprints(newPath, reprints) {\n  var newNode = newPath.getValue();\n  Printable.assert(newNode);\n  var oldNode = newNode.original;\n  Printable.assert(oldNode);\n  assert_1.default.deepEqual(reprints, []);\n  if (newNode.type !== oldNode.type) {\n    return false;\n  }\n  var oldPath = new fast_path_1.default(oldNode);\n  var canReprint = findChildReprints(newPath, oldPath, reprints);\n  if (!canReprint) {\n    // Make absolutely sure the calling code does not attempt to reprint\n    // any nodes.\n    reprints.length = 0;\n  }\n  return canReprint;\n}\nfunction findAnyReprints(newPath, oldPath, reprints) {\n  var newNode = newPath.getValue();\n  var oldNode = oldPath.getValue();\n  if (newNode === oldNode) return true;\n  if (isArray.check(newNode)) return findArrayReprints(newPath, oldPath, reprints);\n  if (isObject.check(newNode)) return findObjectReprints(newPath, oldPath, reprints);\n  return false;\n}\nfunction findArrayReprints(newPath, oldPath, reprints) {\n  var newNode = newPath.getValue();\n  var oldNode = oldPath.getValue();\n  if (newNode === oldNode || newPath.valueIsDuplicate() || oldPath.valueIsDuplicate()) {\n    return true;\n  }\n  isArray.assert(newNode);\n  var len = newNode.length;\n  if (!(isArray.check(oldNode) && oldNode.length === len)) return false;\n  for (var i = 0; i < len; ++i) {\n    newPath.stack.push(i, newNode[i]);\n    oldPath.stack.push(i, oldNode[i]);\n    var canReprint = findAnyReprints(newPath, oldPath, reprints);\n    newPath.stack.length -= 2;\n    oldPath.stack.length -= 2;\n    if (!canReprint) {\n      return false;\n    }\n  }\n  return true;\n}\nfunction findObjectReprints(newPath, oldPath, reprints) {\n  var newNode = newPath.getValue();\n  isObject.assert(newNode);\n  if (newNode.original === null) {\n    // If newNode.original node was set to null, reprint the node.\n    return false;\n  }\n  var oldNode = oldPath.getValue();\n  if (!isObject.check(oldNode)) return false;\n  if (newNode === oldNode || newPath.valueIsDuplicate() || oldPath.valueIsDuplicate()) {\n    return true;\n  }\n  if (Printable.check(newNode)) {\n    if (!Printable.check(oldNode)) {\n      return false;\n    }\n    var newParentNode = newPath.getParentNode();\n    var oldParentNode = oldPath.getParentNode();\n    if (oldParentNode !== null && oldParentNode.type === \"FunctionTypeAnnotation\" && newParentNode !== null && newParentNode.type === \"FunctionTypeAnnotation\") {\n      var oldNeedsParens = oldParentNode.params.length !== 1 || !!oldParentNode.params[0].name;\n      var newNeedParens = newParentNode.params.length !== 1 || !!newParentNode.params[0].name;\n      if (!oldNeedsParens && newNeedParens) {\n        return false;\n      }\n    }\n    // Here we need to decide whether the reprinted code for newNode is\n    // appropriate for patching into the location of oldNode.\n    if (newNode.type === oldNode.type) {\n      var childReprints = [];\n      if (findChildReprints(newPath, oldPath, childReprints)) {\n        reprints.push.apply(reprints, childReprints);\n      } else if (oldNode.loc) {\n        // If we have no .loc information for oldNode, then we won't be\n        // able to reprint it.\n        reprints.push({\n          oldPath: oldPath.copy(),\n          newPath: newPath.copy()\n        });\n      } else {\n        return false;\n      }\n      return true;\n    }\n    if (Expression.check(newNode) && Expression.check(oldNode) &&\n    // If we have no .loc information for oldNode, then we won't be\n    // able to reprint it.\n    oldNode.loc) {\n      // If both nodes are subtypes of Expression, then we should be able\n      // to fill the location occupied by the old node with code printed\n      // for the new node with no ill consequences.\n      reprints.push({\n        oldPath: oldPath.copy(),\n        newPath: newPath.copy()\n      });\n      return true;\n    }\n    // The nodes have different types, and at least one of the types is\n    // not a subtype of the Expression type, so we cannot safely assume\n    // the nodes are syntactically interchangeable.\n    return false;\n  }\n  return findChildReprints(newPath, oldPath, reprints);\n}\nfunction findChildReprints(newPath, oldPath, reprints) {\n  var newNode = newPath.getValue();\n  var oldNode = oldPath.getValue();\n  isObject.assert(newNode);\n  isObject.assert(oldNode);\n  if (newNode.original === null) {\n    // If newNode.original node was set to null, reprint the node.\n    return false;\n  }\n  // If this node needs parentheses and will not be wrapped with\n  // parentheses when reprinted, then return false to skip reprinting and\n  // let it be printed generically.\n  if (newPath.needsParens() && !oldPath.hasParens()) {\n    return false;\n  }\n  var keys = util_1.getUnionOfKeys(oldNode, newNode);\n  if (oldNode.type === \"File\" || newNode.type === \"File\") {\n    // Don't bother traversing file.tokens, an often very large array\n    // returned by Babylon, and useless for our purposes.\n    delete keys.tokens;\n  }\n  // Don't bother traversing .loc objects looking for reprintable nodes.\n  delete keys.loc;\n  var originalReprintCount = reprints.length;\n  for (var k in keys) {\n    if (k.charAt(0) === \"_\") {\n      // Ignore \"private\" AST properties added by e.g. Babel plugins and\n      // parsers like Babylon.\n      continue;\n    }\n    newPath.stack.push(k, types.getFieldValue(newNode, k));\n    oldPath.stack.push(k, types.getFieldValue(oldNode, k));\n    var canReprint = findAnyReprints(newPath, oldPath, reprints);\n    newPath.stack.length -= 2;\n    oldPath.stack.length -= 2;\n    if (!canReprint) {\n      return false;\n    }\n  }\n  // Return statements might end up running into ASI issues due to\n  // comments inserted deep within the tree, so reprint them if anything\n  // changed within them.\n  if (ReturnStatement.check(newPath.getNode()) && reprints.length > originalReprintCount) {\n    return false;\n  }\n  return true;\n}","map":{"version":3,"names":["Object","defineProperty","exports","value","getReprinter","Patcher","tslib_1","require","assert_1","__importDefault","linesModule","__importStar","types","Printable","namedTypes","Expression","ReturnStatement","SourceLocation","util_1","fast_path_1","isObject","builtInTypes","object","isArray","array","isString","string","riskyAdjoiningCharExp","lines","default","ok","Lines","self","replacements","replace","loc","check","fromString","push","start","end","get","line","column","length","getLineLength","sliceFrom","toConcat","pushSlice","from","to","comparePos","slice","sort","a","b","forEach","rep","concat","Pp","prototype","tryToReprintComments","newNode","oldNode","print","patcher","comments","newPath","oldPath","stack","getSurroundingComments","reprints","ableToReprintComments","findArrayReprints","reprint","oldComment","getValue","leading","trailing","indentTail","indent","node","result","comment","deleteComments","skipSpaces","path","orig","original","origLoc","findReprints","assert","needToPrintNewPathWithComments","newLines","includeComments","avoidRootParens","type","hasParens","nls","needsLeadingSpace","nts","needsTrailingSpace","newParts","patchedLines","needsParens","oldLines","oldLoc","posBeforeOldLoc","copyPos","charBeforeOldLoc","prevPos","charAt","newFirstChar","firstPos","test","charAfterOldLoc","newLastPos","lastPos","newLastChar","deepEqual","canReprint","findChildReprints","findAnyReprints","findObjectReprints","valueIsDuplicate","len","i","newParentNode","getParentNode","oldParentNode","oldNeedsParens","params","name","newNeedParens","childReprints","apply","copy","keys","getUnionOfKeys","tokens","originalReprintCount","k","getFieldValue","getNode"],"sources":["C:/Users/Acer/Desktop/dev__book/dev__book/node_modules/jscodeshift/node_modules/recast/lib/patcher.js"],"sourcesContent":["\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.getReprinter = exports.Patcher = void 0;\nvar tslib_1 = require(\"tslib\");\nvar assert_1 = tslib_1.__importDefault(require(\"assert\"));\nvar linesModule = tslib_1.__importStar(require(\"./lines\"));\nvar types = tslib_1.__importStar(require(\"ast-types\"));\nvar Printable = types.namedTypes.Printable;\nvar Expression = types.namedTypes.Expression;\nvar ReturnStatement = types.namedTypes.ReturnStatement;\nvar SourceLocation = types.namedTypes.SourceLocation;\nvar util_1 = require(\"./util\");\nvar fast_path_1 = tslib_1.__importDefault(require(\"./fast-path\"));\nvar isObject = types.builtInTypes.object;\nvar isArray = types.builtInTypes.array;\nvar isString = types.builtInTypes.string;\nvar riskyAdjoiningCharExp = /[0-9a-z_$]/i;\nvar Patcher = function Patcher(lines) {\n    assert_1.default.ok(this instanceof Patcher);\n    assert_1.default.ok(lines instanceof linesModule.Lines);\n    var self = this, replacements = [];\n    self.replace = function (loc, lines) {\n        if (isString.check(lines))\n            lines = linesModule.fromString(lines);\n        replacements.push({\n            lines: lines,\n            start: loc.start,\n            end: loc.end,\n        });\n    };\n    self.get = function (loc) {\n        // If no location is provided, return the complete Lines object.\n        loc = loc || {\n            start: { line: 1, column: 0 },\n            end: { line: lines.length, column: lines.getLineLength(lines.length) },\n        };\n        var sliceFrom = loc.start, toConcat = [];\n        function pushSlice(from, to) {\n            assert_1.default.ok(util_1.comparePos(from, to) <= 0);\n            toConcat.push(lines.slice(from, to));\n        }\n        replacements\n            .sort(function (a, b) { return util_1.comparePos(a.start, b.start); })\n            .forEach(function (rep) {\n            if (util_1.comparePos(sliceFrom, rep.start) > 0) {\n                // Ignore nested replacement ranges.\n            }\n            else {\n                pushSlice(sliceFrom, rep.start);\n                toConcat.push(rep.lines);\n                sliceFrom = rep.end;\n            }\n        });\n        pushSlice(sliceFrom, loc.end);\n        return linesModule.concat(toConcat);\n    };\n};\nexports.Patcher = Patcher;\nvar Pp = Patcher.prototype;\nPp.tryToReprintComments = function (newNode, oldNode, print) {\n    var patcher = this;\n    if (!newNode.comments && !oldNode.comments) {\n        // We were (vacuously) able to reprint all the comments!\n        return true;\n    }\n    var newPath = fast_path_1.default.from(newNode);\n    var oldPath = fast_path_1.default.from(oldNode);\n    newPath.stack.push(\"comments\", getSurroundingComments(newNode));\n    oldPath.stack.push(\"comments\", getSurroundingComments(oldNode));\n    var reprints = [];\n    var ableToReprintComments = findArrayReprints(newPath, oldPath, reprints);\n    // No need to pop anything from newPath.stack or oldPath.stack, since\n    // newPath and oldPath are fresh local variables.\n    if (ableToReprintComments && reprints.length > 0) {\n        reprints.forEach(function (reprint) {\n            var oldComment = reprint.oldPath.getValue();\n            assert_1.default.ok(oldComment.leading || oldComment.trailing);\n            patcher.replace(oldComment.loc, \n            // Comments can't have .comments, so it doesn't matter whether we\n            // print with comments or without.\n            print(reprint.newPath).indentTail(oldComment.loc.indent));\n        });\n    }\n    return ableToReprintComments;\n};\n// Get all comments that are either leading or trailing, ignoring any\n// comments that occur inside node.loc. Returns an empty array for nodes\n// with no leading or trailing comments.\nfunction getSurroundingComments(node) {\n    var result = [];\n    if (node.comments && node.comments.length > 0) {\n        node.comments.forEach(function (comment) {\n            if (comment.leading || comment.trailing) {\n                result.push(comment);\n            }\n        });\n    }\n    return result;\n}\nPp.deleteComments = function (node) {\n    if (!node.comments) {\n        return;\n    }\n    var patcher = this;\n    node.comments.forEach(function (comment) {\n        if (comment.leading) {\n            // Delete leading comments along with any trailing whitespace they\n            // might have.\n            patcher.replace({\n                start: comment.loc.start,\n                end: node.loc.lines.skipSpaces(comment.loc.end, false, false),\n            }, \"\");\n        }\n        else if (comment.trailing) {\n            // Delete trailing comments along with any leading whitespace they\n            // might have.\n            patcher.replace({\n                start: node.loc.lines.skipSpaces(comment.loc.start, true, false),\n                end: comment.loc.end,\n            }, \"\");\n        }\n    });\n};\nfunction getReprinter(path) {\n    assert_1.default.ok(path instanceof fast_path_1.default);\n    // Make sure that this path refers specifically to a Node, rather than\n    // some non-Node subproperty of a Node.\n    var node = path.getValue();\n    if (!Printable.check(node))\n        return;\n    var orig = node.original;\n    var origLoc = orig && orig.loc;\n    var lines = origLoc && origLoc.lines;\n    var reprints = [];\n    if (!lines || !findReprints(path, reprints))\n        return;\n    return function (print) {\n        var patcher = new Patcher(lines);\n        reprints.forEach(function (reprint) {\n            var newNode = reprint.newPath.getValue();\n            var oldNode = reprint.oldPath.getValue();\n            SourceLocation.assert(oldNode.loc, true);\n            var needToPrintNewPathWithComments = !patcher.tryToReprintComments(newNode, oldNode, print);\n            if (needToPrintNewPathWithComments) {\n                // Since we were not able to preserve all leading/trailing\n                // comments, we delete oldNode's comments, print newPath with\n                // comments, and then patch the resulting lines where oldNode used\n                // to be.\n                patcher.deleteComments(oldNode);\n            }\n            var newLines = print(reprint.newPath, {\n                includeComments: needToPrintNewPathWithComments,\n                // If the oldNode we're replacing already had parentheses, we may\n                // not need to print the new node with any extra parentheses,\n                // because the existing parentheses will suffice. However, if the\n                // newNode has a different type than the oldNode, let the printer\n                // decide if reprint.newPath needs parentheses, as usual.\n                avoidRootParens: oldNode.type === newNode.type && reprint.oldPath.hasParens(),\n            }).indentTail(oldNode.loc.indent);\n            var nls = needsLeadingSpace(lines, oldNode.loc, newLines);\n            var nts = needsTrailingSpace(lines, oldNode.loc, newLines);\n            // If we try to replace the argument of a ReturnStatement like\n            // return\"asdf\" with e.g. a literal null expression, we run the risk\n            // of ending up with returnnull, so we need to add an extra leading\n            // space in situations where that might happen. Likewise for\n            // \"asdf\"in obj. See #170.\n            if (nls || nts) {\n                var newParts = [];\n                nls && newParts.push(\" \");\n                newParts.push(newLines);\n                nts && newParts.push(\" \");\n                newLines = linesModule.concat(newParts);\n            }\n            patcher.replace(oldNode.loc, newLines);\n        });\n        // Recall that origLoc is the .loc of an ancestor node that is\n        // guaranteed to contain all the reprinted nodes and comments.\n        var patchedLines = patcher.get(origLoc).indentTail(-orig.loc.indent);\n        if (path.needsParens()) {\n            return linesModule.concat([\"(\", patchedLines, \")\"]);\n        }\n        return patchedLines;\n    };\n}\nexports.getReprinter = getReprinter;\n// If the last character before oldLoc and the first character of newLines\n// are both identifier characters, they must be separated by a space,\n// otherwise they will most likely get fused together into a single token.\nfunction needsLeadingSpace(oldLines, oldLoc, newLines) {\n    var posBeforeOldLoc = util_1.copyPos(oldLoc.start);\n    // The character just before the location occupied by oldNode.\n    var charBeforeOldLoc = oldLines.prevPos(posBeforeOldLoc) && oldLines.charAt(posBeforeOldLoc);\n    // First character of the reprinted node.\n    var newFirstChar = newLines.charAt(newLines.firstPos());\n    return (charBeforeOldLoc &&\n        riskyAdjoiningCharExp.test(charBeforeOldLoc) &&\n        newFirstChar &&\n        riskyAdjoiningCharExp.test(newFirstChar));\n}\n// If the last character of newLines and the first character after oldLoc\n// are both identifier characters, they must be separated by a space,\n// otherwise they will most likely get fused together into a single token.\nfunction needsTrailingSpace(oldLines, oldLoc, newLines) {\n    // The character just after the location occupied by oldNode.\n    var charAfterOldLoc = oldLines.charAt(oldLoc.end);\n    var newLastPos = newLines.lastPos();\n    // Last character of the reprinted node.\n    var newLastChar = newLines.prevPos(newLastPos) && newLines.charAt(newLastPos);\n    return (newLastChar &&\n        riskyAdjoiningCharExp.test(newLastChar) &&\n        charAfterOldLoc &&\n        riskyAdjoiningCharExp.test(charAfterOldLoc));\n}\nfunction findReprints(newPath, reprints) {\n    var newNode = newPath.getValue();\n    Printable.assert(newNode);\n    var oldNode = newNode.original;\n    Printable.assert(oldNode);\n    assert_1.default.deepEqual(reprints, []);\n    if (newNode.type !== oldNode.type) {\n        return false;\n    }\n    var oldPath = new fast_path_1.default(oldNode);\n    var canReprint = findChildReprints(newPath, oldPath, reprints);\n    if (!canReprint) {\n        // Make absolutely sure the calling code does not attempt to reprint\n        // any nodes.\n        reprints.length = 0;\n    }\n    return canReprint;\n}\nfunction findAnyReprints(newPath, oldPath, reprints) {\n    var newNode = newPath.getValue();\n    var oldNode = oldPath.getValue();\n    if (newNode === oldNode)\n        return true;\n    if (isArray.check(newNode))\n        return findArrayReprints(newPath, oldPath, reprints);\n    if (isObject.check(newNode))\n        return findObjectReprints(newPath, oldPath, reprints);\n    return false;\n}\nfunction findArrayReprints(newPath, oldPath, reprints) {\n    var newNode = newPath.getValue();\n    var oldNode = oldPath.getValue();\n    if (newNode === oldNode ||\n        newPath.valueIsDuplicate() ||\n        oldPath.valueIsDuplicate()) {\n        return true;\n    }\n    isArray.assert(newNode);\n    var len = newNode.length;\n    if (!(isArray.check(oldNode) && oldNode.length === len))\n        return false;\n    for (var i = 0; i < len; ++i) {\n        newPath.stack.push(i, newNode[i]);\n        oldPath.stack.push(i, oldNode[i]);\n        var canReprint = findAnyReprints(newPath, oldPath, reprints);\n        newPath.stack.length -= 2;\n        oldPath.stack.length -= 2;\n        if (!canReprint) {\n            return false;\n        }\n    }\n    return true;\n}\nfunction findObjectReprints(newPath, oldPath, reprints) {\n    var newNode = newPath.getValue();\n    isObject.assert(newNode);\n    if (newNode.original === null) {\n        // If newNode.original node was set to null, reprint the node.\n        return false;\n    }\n    var oldNode = oldPath.getValue();\n    if (!isObject.check(oldNode))\n        return false;\n    if (newNode === oldNode ||\n        newPath.valueIsDuplicate() ||\n        oldPath.valueIsDuplicate()) {\n        return true;\n    }\n    if (Printable.check(newNode)) {\n        if (!Printable.check(oldNode)) {\n            return false;\n        }\n        var newParentNode = newPath.getParentNode();\n        var oldParentNode = oldPath.getParentNode();\n        if (oldParentNode !== null &&\n            oldParentNode.type === \"FunctionTypeAnnotation\" &&\n            newParentNode !== null &&\n            newParentNode.type === \"FunctionTypeAnnotation\") {\n            var oldNeedsParens = oldParentNode.params.length !== 1 || !!oldParentNode.params[0].name;\n            var newNeedParens = newParentNode.params.length !== 1 || !!newParentNode.params[0].name;\n            if (!oldNeedsParens && newNeedParens) {\n                return false;\n            }\n        }\n        // Here we need to decide whether the reprinted code for newNode is\n        // appropriate for patching into the location of oldNode.\n        if (newNode.type === oldNode.type) {\n            var childReprints = [];\n            if (findChildReprints(newPath, oldPath, childReprints)) {\n                reprints.push.apply(reprints, childReprints);\n            }\n            else if (oldNode.loc) {\n                // If we have no .loc information for oldNode, then we won't be\n                // able to reprint it.\n                reprints.push({\n                    oldPath: oldPath.copy(),\n                    newPath: newPath.copy(),\n                });\n            }\n            else {\n                return false;\n            }\n            return true;\n        }\n        if (Expression.check(newNode) &&\n            Expression.check(oldNode) &&\n            // If we have no .loc information for oldNode, then we won't be\n            // able to reprint it.\n            oldNode.loc) {\n            // If both nodes are subtypes of Expression, then we should be able\n            // to fill the location occupied by the old node with code printed\n            // for the new node with no ill consequences.\n            reprints.push({\n                oldPath: oldPath.copy(),\n                newPath: newPath.copy(),\n            });\n            return true;\n        }\n        // The nodes have different types, and at least one of the types is\n        // not a subtype of the Expression type, so we cannot safely assume\n        // the nodes are syntactically interchangeable.\n        return false;\n    }\n    return findChildReprints(newPath, oldPath, reprints);\n}\nfunction findChildReprints(newPath, oldPath, reprints) {\n    var newNode = newPath.getValue();\n    var oldNode = oldPath.getValue();\n    isObject.assert(newNode);\n    isObject.assert(oldNode);\n    if (newNode.original === null) {\n        // If newNode.original node was set to null, reprint the node.\n        return false;\n    }\n    // If this node needs parentheses and will not be wrapped with\n    // parentheses when reprinted, then return false to skip reprinting and\n    // let it be printed generically.\n    if (newPath.needsParens() && !oldPath.hasParens()) {\n        return false;\n    }\n    var keys = util_1.getUnionOfKeys(oldNode, newNode);\n    if (oldNode.type === \"File\" || newNode.type === \"File\") {\n        // Don't bother traversing file.tokens, an often very large array\n        // returned by Babylon, and useless for our purposes.\n        delete keys.tokens;\n    }\n    // Don't bother traversing .loc objects looking for reprintable nodes.\n    delete keys.loc;\n    var originalReprintCount = reprints.length;\n    for (var k in keys) {\n        if (k.charAt(0) === \"_\") {\n            // Ignore \"private\" AST properties added by e.g. Babel plugins and\n            // parsers like Babylon.\n            continue;\n        }\n        newPath.stack.push(k, types.getFieldValue(newNode, k));\n        oldPath.stack.push(k, types.getFieldValue(oldNode, k));\n        var canReprint = findAnyReprints(newPath, oldPath, reprints);\n        newPath.stack.length -= 2;\n        oldPath.stack.length -= 2;\n        if (!canReprint) {\n            return false;\n        }\n    }\n    // Return statements might end up running into ASI issues due to\n    // comments inserted deep within the tree, so reprint them if anything\n    // changed within them.\n    if (ReturnStatement.check(newPath.getNode()) &&\n        reprints.length > originalReprintCount) {\n        return false;\n    }\n    return true;\n}\n"],"mappings":"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"},"metadata":{},"sourceType":"script"}