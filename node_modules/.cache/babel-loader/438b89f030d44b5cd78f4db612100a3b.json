{"ast":null,"code":"exports.flow = {\n  null: {\n    tokenize: tokenizeTable,\n    resolve: resolveTable,\n    interruptible: true\n  }\n};\nvar createSpace = require('micromark/dist/tokenize/factory-space');\nvar setextUnderlineMini = {\n  tokenize: tokenizeSetextUnderlineMini,\n  partial: true\n};\nvar nextPrefixedOrBlank = {\n  tokenize: tokenizeNextPrefixedOrBlank,\n  partial: true\n};\nfunction resolveTable(events, context) {\n  var length = events.length;\n  var index = -1;\n  var token;\n  var inHead;\n  var inDelimiterRow;\n  var inRow;\n  var cell;\n  var content;\n  var text;\n  var contentStart;\n  var contentEnd;\n  var cellStart;\n  while (++index < length) {\n    token = events[index][1];\n    if (inRow) {\n      if (token.type === 'temporaryTableCellContent') {\n        contentStart = contentStart || index;\n        contentEnd = index;\n      }\n      if (\n      // Combine separate content parts into one.\n      (token.type === 'tableCellDivider' || token.type === 'tableRow') && contentEnd) {\n        content = {\n          type: 'tableContent',\n          start: events[contentStart][1].start,\n          end: events[contentEnd][1].end\n        };\n        text = {\n          type: 'chunkText',\n          start: content.start,\n          end: content.end,\n          contentType: 'text'\n        };\n        events.splice(contentStart, contentEnd - contentStart + 1, ['enter', content, context], ['enter', text, context], ['exit', text, context], ['exit', content, context]);\n        index -= contentEnd - contentStart - 3;\n        length = events.length;\n        contentStart = undefined;\n        contentEnd = undefined;\n      }\n    }\n    if (events[index][0] === 'exit' && cellStart && cellStart + 1 < index && (token.type === 'tableCellDivider' || token.type === 'tableRow' && (cellStart + 3 < index || events[cellStart][1].type !== 'whitespace'))) {\n      cell = {\n        type: inDelimiterRow ? 'tableDelimiter' : inHead ? 'tableHeader' : 'tableData',\n        start: events[cellStart][1].start,\n        end: events[index][1].end\n      };\n      events.splice(index + (token.type === 'tableCellDivider' ? 1 : 0), 0, ['exit', cell, context]);\n      events.splice(cellStart, 0, ['enter', cell, context]);\n      index += 2;\n      length = events.length;\n      cellStart = index + 1;\n    }\n    if (token.type === 'tableRow') {\n      inRow = events[index][0] === 'enter';\n      if (inRow) {\n        cellStart = index + 1;\n      }\n    }\n    if (token.type === 'tableDelimiterRow') {\n      inDelimiterRow = events[index][0] === 'enter';\n      if (inDelimiterRow) {\n        cellStart = index + 1;\n      }\n    }\n    if (token.type === 'tableHead') {\n      inHead = events[index][0] === 'enter';\n    }\n  }\n  return events;\n}\nfunction tokenizeTable(effects, ok, nok) {\n  var align = [];\n  var tableHeaderCount = 0;\n  var seenDelimiter;\n  var hasDash;\n  return start;\n  function start(code) {\n    /* istanbul ignore if - used to be passed in beta micromark versions. */\n    if (code === null || code === -5 || code === -4 || code === -3) {\n      return nok(code);\n    }\n    effects.enter('table')._align = align;\n    effects.enter('tableHead');\n    effects.enter('tableRow');\n\n    // If we start with a pipe, we open a cell marker.\n    if (code === 124) {\n      return cellDividerHead(code);\n    }\n    tableHeaderCount++;\n    effects.enter('temporaryTableCellContent');\n    // Can’t be space or eols at the start of a construct, so we’re in a cell.\n    return inCellContentHead(code);\n  }\n  function cellDividerHead(code) {\n    // Always a pipe.\n    effects.enter('tableCellDivider');\n    effects.consume(code);\n    effects.exit('tableCellDivider');\n    seenDelimiter = true;\n    return cellBreakHead;\n  }\n  function cellBreakHead(code) {\n    // EOF, CR, LF, CRLF.\n    if (code === null || code === -5 || code === -4 || code === -3) {\n      return atRowEndHead(code);\n    }\n\n    // HT, VS, SP.\n    if (code === -2 || code === -1 || code === 32) {\n      effects.enter('whitespace');\n      effects.consume(code);\n      return inWhitespaceHead;\n    }\n    if (seenDelimiter) {\n      seenDelimiter = undefined;\n      tableHeaderCount++;\n    }\n\n    // `|`\n    if (code === 124) {\n      return cellDividerHead(code);\n    }\n\n    // Anything else is cell content.\n    effects.enter('temporaryTableCellContent');\n    return inCellContentHead(code);\n  }\n  function inWhitespaceHead(code) {\n    // HT, VS, SP.\n    if (code === -2 || code === -1 || code === 32) {\n      effects.consume(code);\n      return inWhitespaceHead;\n    }\n    effects.exit('whitespace');\n    return cellBreakHead(code);\n  }\n  function inCellContentHead(code) {\n    // EOF, whitespace, pipe\n    if (code === null || code < 0 || code === 32 || code === 124) {\n      effects.exit('temporaryTableCellContent');\n      return cellBreakHead(code);\n    }\n    effects.consume(code);\n    // `\\`\n    return code === 92 ? inCellContentEscapeHead : inCellContentHead;\n  }\n  function inCellContentEscapeHead(code) {\n    // `\\` or `|`\n    if (code === 92 || code === 124) {\n      effects.consume(code);\n      return inCellContentHead;\n    }\n\n    // Anything else.\n    return inCellContentHead(code);\n  }\n  function atRowEndHead(code) {\n    if (code === null) {\n      return nok(code);\n    }\n    effects.exit('tableRow');\n    effects.exit('tableHead');\n\n    // Always a line ending.\n    effects.enter('lineEnding');\n    effects.consume(code);\n    effects.exit('lineEnding');\n\n    // If a setext heading, exit.\n    return effects.check(setextUnderlineMini, nok,\n    // Support an indent before the delimiter row.\n    createSpace(effects, rowStartDelimiter, 'linePrefix', 4));\n  }\n  function rowStartDelimiter(code) {\n    // If there’s another space, or we’re at the EOL/EOF, exit.\n    if (code === null || code < 0 || code === 32) {\n      return nok(code);\n    }\n    effects.enter('tableDelimiterRow');\n    return atDelimiterRowBreak(code);\n  }\n  function atDelimiterRowBreak(code) {\n    // EOF, CR, LF, CRLF.\n    if (code === null || code === -5 || code === -4 || code === -3) {\n      return rowEndDelimiter(code);\n    }\n\n    // HT, VS, SP.\n    if (code === -2 || code === -1 || code === 32) {\n      effects.enter('whitespace');\n      effects.consume(code);\n      return inWhitespaceDelimiter;\n    }\n\n    // `-`\n    if (code === 45) {\n      effects.enter('tableDelimiterFiller');\n      effects.consume(code);\n      hasDash = true;\n      align.push(null);\n      return inFillerDelimiter;\n    }\n\n    // `:`\n    if (code === 58) {\n      effects.enter('tableDelimiterAlignment');\n      effects.consume(code);\n      effects.exit('tableDelimiterAlignment');\n      align.push('left');\n      return afterLeftAlignment;\n    }\n\n    // If we start with a pipe, we open a cell marker.\n    if (code === 124) {\n      effects.enter('tableCellDivider');\n      effects.consume(code);\n      effects.exit('tableCellDivider');\n      return atDelimiterRowBreak;\n    }\n    return nok(code);\n  }\n  function inWhitespaceDelimiter(code) {\n    // HT, VS, SP.\n    if (code === -2 || code === -1 || code === 32) {\n      effects.consume(code);\n      return inWhitespaceDelimiter;\n    }\n    effects.exit('whitespace');\n    return atDelimiterRowBreak(code);\n  }\n  function inFillerDelimiter(code) {\n    // `-`\n    if (code === 45) {\n      effects.consume(code);\n      return inFillerDelimiter;\n    }\n    effects.exit('tableDelimiterFiller');\n\n    // `:`\n    if (code === 58) {\n      effects.enter('tableDelimiterAlignment');\n      effects.consume(code);\n      effects.exit('tableDelimiterAlignment');\n      align[align.length - 1] = align[align.length - 1] === 'left' ? 'center' : 'right';\n      return afterRightAlignment;\n    }\n    return atDelimiterRowBreak(code);\n  }\n  function afterLeftAlignment(code) {\n    // `-`\n    if (code === 45) {\n      effects.enter('tableDelimiterFiller');\n      effects.consume(code);\n      hasDash = true;\n      return inFillerDelimiter;\n    }\n\n    // Anything else is not ok.\n    return nok(code);\n  }\n  function afterRightAlignment(code) {\n    // EOF, CR, LF, CRLF.\n    if (code === null || code === -5 || code === -4 || code === -3) {\n      return rowEndDelimiter(code);\n    }\n\n    // HT, VS, SP.\n    if (code === -2 || code === -1 || code === 32) {\n      effects.enter('whitespace');\n      effects.consume(code);\n      return inWhitespaceDelimiter;\n    }\n\n    // `|`\n    if (code === 124) {\n      effects.enter('tableCellDivider');\n      effects.consume(code);\n      effects.exit('tableCellDivider');\n      return atDelimiterRowBreak;\n    }\n    return nok(code);\n  }\n  function rowEndDelimiter(code) {\n    effects.exit('tableDelimiterRow');\n\n    // Exit if there was no dash at all, or if the header cell count is not the\n    // delimiter cell count.\n    if (!hasDash || tableHeaderCount !== align.length) {\n      return nok(code);\n    }\n    if (code === null) {\n      return tableClose(code);\n    }\n    return effects.check(nextPrefixedOrBlank, tableClose, tableContinue)(code);\n  }\n  function tableClose(code) {\n    effects.exit('table');\n    return ok(code);\n  }\n  function tableContinue(code) {\n    // Always a line ending.\n    effects.enter('lineEnding');\n    effects.consume(code);\n    effects.exit('lineEnding');\n    // We checked that it’s not a prefixed or blank line, so we’re certain a\n    // body is coming, though it may be indented.\n    return createSpace(effects, bodyStart, 'linePrefix', 4);\n  }\n  function bodyStart(code) {\n    effects.enter('tableBody');\n    return rowStartBody(code);\n  }\n  function rowStartBody(code) {\n    effects.enter('tableRow');\n\n    // If we start with a pipe, we open a cell marker.\n    if (code === 124) {\n      return cellDividerBody(code);\n    }\n    effects.enter('temporaryTableCellContent');\n    // Can’t be space or eols at the start of a construct, so we’re in a cell.\n    return inCellContentBody(code);\n  }\n  function cellDividerBody(code) {\n    // Always a pipe.\n    effects.enter('tableCellDivider');\n    effects.consume(code);\n    effects.exit('tableCellDivider');\n    return cellBreakBody;\n  }\n  function cellBreakBody(code) {\n    // EOF, CR, LF, CRLF.\n    if (code === null || code === -5 || code === -4 || code === -3) {\n      return atRowEndBody(code);\n    }\n\n    // HT, VS, SP.\n    if (code === -2 || code === -1 || code === 32) {\n      effects.enter('whitespace');\n      effects.consume(code);\n      return inWhitespaceBody;\n    }\n\n    // `|`\n    if (code === 124) {\n      return cellDividerBody(code);\n    }\n\n    // Anything else is cell content.\n    effects.enter('temporaryTableCellContent');\n    return inCellContentBody(code);\n  }\n  function inWhitespaceBody(code) {\n    // HT, VS, SP.\n    if (code === -2 || code === -1 || code === 32) {\n      effects.consume(code);\n      return inWhitespaceBody;\n    }\n    effects.exit('whitespace');\n    return cellBreakBody(code);\n  }\n  function inCellContentBody(code) {\n    // EOF, whitespace, pipe\n    if (code === null || code < 0 || code === 32 || code === 124) {\n      effects.exit('temporaryTableCellContent');\n      return cellBreakBody(code);\n    }\n    effects.consume(code);\n    // `\\`\n    return code === 92 ? inCellContentEscapeBody : inCellContentBody;\n  }\n  function inCellContentEscapeBody(code) {\n    // `\\` or `|`\n    if (code === 92 || code === 124) {\n      effects.consume(code);\n      return inCellContentBody;\n    }\n\n    // Anything else.\n    return inCellContentBody(code);\n  }\n  function atRowEndBody(code) {\n    effects.exit('tableRow');\n    if (code === null) {\n      return tableBodyClose(code);\n    }\n    return effects.check(nextPrefixedOrBlank, tableBodyClose, tableBodyContinue)(code);\n  }\n  function tableBodyClose(code) {\n    effects.exit('tableBody');\n    return tableClose(code);\n  }\n  function tableBodyContinue(code) {\n    // Always a line ending.\n    effects.enter('lineEnding');\n    effects.consume(code);\n    effects.exit('lineEnding');\n    // Support an optional prefix, then start a body row.\n    return createSpace(effects, rowStartBody, 'linePrefix', 4);\n  }\n}\n\n// Based on micromark, but that won’t work as we’re in a table, and that expects\n// content.\n// <https://github.com/micromark/micromark/blob/main/lib/tokenize/setext-underline.js>\nfunction tokenizeSetextUnderlineMini(effects, ok, nok) {\n  return start;\n  function start(code) {\n    // `-`\n    if (code !== 45) {\n      return nok(code);\n    }\n    effects.enter('setextUnderline');\n    return sequence(code);\n  }\n  function sequence(code) {\n    if (code === 45) {\n      effects.consume(code);\n      return sequence;\n    }\n    return whitespace(code);\n  }\n  function whitespace(code) {\n    if (code === -2 || code === -1 || code === 32) {\n      effects.consume(code);\n      return whitespace;\n    }\n    if (code === null || code === -5 || code === -4 || code === -3) {\n      return ok(code);\n    }\n    return nok(code);\n  }\n}\nfunction tokenizeNextPrefixedOrBlank(effects, ok, nok) {\n  var size = 0;\n  return start;\n  function start(code) {\n    // This is a check, so we don’t care about tokens, but we open a bogus one\n    // so we’re valid.\n    effects.enter('check');\n    // EOL.\n    effects.consume(code);\n    return whitespace;\n  }\n  function whitespace(code) {\n    // VS or SP.\n    if (code === -1 || code === 32) {\n      effects.consume(code);\n      size++;\n      return size === 4 ? ok : whitespace;\n    }\n\n    // EOF or whitespace\n    if (code === null || code < 0) {\n      return ok(code);\n    }\n\n    // Anything else.\n    return nok(code);\n  }\n}","map":{"version":3,"names":["exports","flow","null","tokenize","tokenizeTable","resolve","resolveTable","interruptible","createSpace","require","setextUnderlineMini","tokenizeSetextUnderlineMini","partial","nextPrefixedOrBlank","tokenizeNextPrefixedOrBlank","events","context","length","index","token","inHead","inDelimiterRow","inRow","cell","content","text","contentStart","contentEnd","cellStart","type","start","end","contentType","splice","undefined","effects","ok","nok","align","tableHeaderCount","seenDelimiter","hasDash","code","enter","_align","cellDividerHead","inCellContentHead","consume","exit","cellBreakHead","atRowEndHead","inWhitespaceHead","inCellContentEscapeHead","check","rowStartDelimiter","atDelimiterRowBreak","rowEndDelimiter","inWhitespaceDelimiter","push","inFillerDelimiter","afterLeftAlignment","afterRightAlignment","tableClose","tableContinue","bodyStart","rowStartBody","cellDividerBody","inCellContentBody","cellBreakBody","atRowEndBody","inWhitespaceBody","inCellContentEscapeBody","tableBodyClose","tableBodyContinue","sequence","whitespace","size"],"sources":["C:/Users/Acer/Desktop/dev__book/dev__book/node_modules/micromark-extension-gfm-table/syntax.js"],"sourcesContent":["exports.flow = {\n  null: {tokenize: tokenizeTable, resolve: resolveTable, interruptible: true}\n}\n\nvar createSpace = require('micromark/dist/tokenize/factory-space')\n\nvar setextUnderlineMini = {tokenize: tokenizeSetextUnderlineMini, partial: true}\nvar nextPrefixedOrBlank = {tokenize: tokenizeNextPrefixedOrBlank, partial: true}\n\nfunction resolveTable(events, context) {\n  var length = events.length\n  var index = -1\n  var token\n  var inHead\n  var inDelimiterRow\n  var inRow\n  var cell\n  var content\n  var text\n  var contentStart\n  var contentEnd\n  var cellStart\n\n  while (++index < length) {\n    token = events[index][1]\n\n    if (inRow) {\n      if (token.type === 'temporaryTableCellContent') {\n        contentStart = contentStart || index\n        contentEnd = index\n      }\n\n      if (\n        // Combine separate content parts into one.\n        (token.type === 'tableCellDivider' || token.type === 'tableRow') &&\n        contentEnd\n      ) {\n        content = {\n          type: 'tableContent',\n          start: events[contentStart][1].start,\n          end: events[contentEnd][1].end\n        }\n        text = {\n          type: 'chunkText',\n          start: content.start,\n          end: content.end,\n          contentType: 'text'\n        }\n\n        events.splice(\n          contentStart,\n          contentEnd - contentStart + 1,\n          ['enter', content, context],\n          ['enter', text, context],\n          ['exit', text, context],\n          ['exit', content, context]\n        )\n        index -= contentEnd - contentStart - 3\n        length = events.length\n        contentStart = undefined\n        contentEnd = undefined\n      }\n    }\n\n    if (\n      events[index][0] === 'exit' &&\n      cellStart &&\n      cellStart + 1 < index &&\n      (token.type === 'tableCellDivider' ||\n        (token.type === 'tableRow' &&\n          (cellStart + 3 < index ||\n            events[cellStart][1].type !== 'whitespace')))\n    ) {\n      cell = {\n        type: inDelimiterRow\n          ? 'tableDelimiter'\n          : inHead\n          ? 'tableHeader'\n          : 'tableData',\n        start: events[cellStart][1].start,\n        end: events[index][1].end\n      }\n      events.splice(index + (token.type === 'tableCellDivider' ? 1 : 0), 0, [\n        'exit',\n        cell,\n        context\n      ])\n      events.splice(cellStart, 0, ['enter', cell, context])\n      index += 2\n      length = events.length\n      cellStart = index + 1\n    }\n\n    if (token.type === 'tableRow') {\n      inRow = events[index][0] === 'enter'\n\n      if (inRow) {\n        cellStart = index + 1\n      }\n    }\n\n    if (token.type === 'tableDelimiterRow') {\n      inDelimiterRow = events[index][0] === 'enter'\n\n      if (inDelimiterRow) {\n        cellStart = index + 1\n      }\n    }\n\n    if (token.type === 'tableHead') {\n      inHead = events[index][0] === 'enter'\n    }\n  }\n\n  return events\n}\n\nfunction tokenizeTable(effects, ok, nok) {\n  var align = []\n  var tableHeaderCount = 0\n  var seenDelimiter\n  var hasDash\n\n  return start\n\n  function start(code) {\n    /* istanbul ignore if - used to be passed in beta micromark versions. */\n    if (code === null || code === -5 || code === -4 || code === -3) {\n      return nok(code)\n    }\n\n    effects.enter('table')._align = align\n    effects.enter('tableHead')\n    effects.enter('tableRow')\n\n    // If we start with a pipe, we open a cell marker.\n    if (code === 124) {\n      return cellDividerHead(code)\n    }\n\n    tableHeaderCount++\n    effects.enter('temporaryTableCellContent')\n    // Can’t be space or eols at the start of a construct, so we’re in a cell.\n    return inCellContentHead(code)\n  }\n\n  function cellDividerHead(code) {\n    // Always a pipe.\n    effects.enter('tableCellDivider')\n    effects.consume(code)\n    effects.exit('tableCellDivider')\n    seenDelimiter = true\n    return cellBreakHead\n  }\n\n  function cellBreakHead(code) {\n    // EOF, CR, LF, CRLF.\n    if (code === null || code === -5 || code === -4 || code === -3) {\n      return atRowEndHead(code)\n    }\n\n    // HT, VS, SP.\n    if (code === -2 || code === -1 || code === 32) {\n      effects.enter('whitespace')\n      effects.consume(code)\n      return inWhitespaceHead\n    }\n\n    if (seenDelimiter) {\n      seenDelimiter = undefined\n      tableHeaderCount++\n    }\n\n    // `|`\n    if (code === 124) {\n      return cellDividerHead(code)\n    }\n\n    // Anything else is cell content.\n    effects.enter('temporaryTableCellContent')\n    return inCellContentHead(code)\n  }\n\n  function inWhitespaceHead(code) {\n    // HT, VS, SP.\n    if (code === -2 || code === -1 || code === 32) {\n      effects.consume(code)\n      return inWhitespaceHead\n    }\n\n    effects.exit('whitespace')\n    return cellBreakHead(code)\n  }\n\n  function inCellContentHead(code) {\n    // EOF, whitespace, pipe\n    if (code === null || code < 0 || code === 32 || code === 124) {\n      effects.exit('temporaryTableCellContent')\n      return cellBreakHead(code)\n    }\n\n    effects.consume(code)\n    // `\\`\n    return code === 92 ? inCellContentEscapeHead : inCellContentHead\n  }\n\n  function inCellContentEscapeHead(code) {\n    // `\\` or `|`\n    if (code === 92 || code === 124) {\n      effects.consume(code)\n      return inCellContentHead\n    }\n\n    // Anything else.\n    return inCellContentHead(code)\n  }\n\n  function atRowEndHead(code) {\n    if (code === null) {\n      return nok(code)\n    }\n\n    effects.exit('tableRow')\n    effects.exit('tableHead')\n\n    // Always a line ending.\n    effects.enter('lineEnding')\n    effects.consume(code)\n    effects.exit('lineEnding')\n\n    // If a setext heading, exit.\n    return effects.check(\n      setextUnderlineMini,\n      nok,\n      // Support an indent before the delimiter row.\n      createSpace(effects, rowStartDelimiter, 'linePrefix', 4)\n    )\n  }\n\n  function rowStartDelimiter(code) {\n    // If there’s another space, or we’re at the EOL/EOF, exit.\n    if (code === null || code < 0 || code === 32) {\n      return nok(code)\n    }\n\n    effects.enter('tableDelimiterRow')\n    return atDelimiterRowBreak(code)\n  }\n\n  function atDelimiterRowBreak(code) {\n    // EOF, CR, LF, CRLF.\n    if (code === null || code === -5 || code === -4 || code === -3) {\n      return rowEndDelimiter(code)\n    }\n\n    // HT, VS, SP.\n    if (code === -2 || code === -1 || code === 32) {\n      effects.enter('whitespace')\n      effects.consume(code)\n      return inWhitespaceDelimiter\n    }\n\n    // `-`\n    if (code === 45) {\n      effects.enter('tableDelimiterFiller')\n      effects.consume(code)\n      hasDash = true\n      align.push(null)\n      return inFillerDelimiter\n    }\n\n    // `:`\n    if (code === 58) {\n      effects.enter('tableDelimiterAlignment')\n      effects.consume(code)\n      effects.exit('tableDelimiterAlignment')\n      align.push('left')\n      return afterLeftAlignment\n    }\n\n    // If we start with a pipe, we open a cell marker.\n    if (code === 124) {\n      effects.enter('tableCellDivider')\n      effects.consume(code)\n      effects.exit('tableCellDivider')\n      return atDelimiterRowBreak\n    }\n\n    return nok(code)\n  }\n\n  function inWhitespaceDelimiter(code) {\n    // HT, VS, SP.\n    if (code === -2 || code === -1 || code === 32) {\n      effects.consume(code)\n      return inWhitespaceDelimiter\n    }\n\n    effects.exit('whitespace')\n    return atDelimiterRowBreak(code)\n  }\n\n  function inFillerDelimiter(code) {\n    // `-`\n    if (code === 45) {\n      effects.consume(code)\n      return inFillerDelimiter\n    }\n\n    effects.exit('tableDelimiterFiller')\n\n    // `:`\n    if (code === 58) {\n      effects.enter('tableDelimiterAlignment')\n      effects.consume(code)\n      effects.exit('tableDelimiterAlignment')\n\n      align[align.length - 1] =\n        align[align.length - 1] === 'left' ? 'center' : 'right'\n\n      return afterRightAlignment\n    }\n\n    return atDelimiterRowBreak(code)\n  }\n\n  function afterLeftAlignment(code) {\n    // `-`\n    if (code === 45) {\n      effects.enter('tableDelimiterFiller')\n      effects.consume(code)\n      hasDash = true\n      return inFillerDelimiter\n    }\n\n    // Anything else is not ok.\n    return nok(code)\n  }\n\n  function afterRightAlignment(code) {\n    // EOF, CR, LF, CRLF.\n    if (code === null || code === -5 || code === -4 || code === -3) {\n      return rowEndDelimiter(code)\n    }\n\n    // HT, VS, SP.\n    if (code === -2 || code === -1 || code === 32) {\n      effects.enter('whitespace')\n      effects.consume(code)\n      return inWhitespaceDelimiter\n    }\n\n    // `|`\n    if (code === 124) {\n      effects.enter('tableCellDivider')\n      effects.consume(code)\n      effects.exit('tableCellDivider')\n      return atDelimiterRowBreak\n    }\n\n    return nok(code)\n  }\n\n  function rowEndDelimiter(code) {\n    effects.exit('tableDelimiterRow')\n\n    // Exit if there was no dash at all, or if the header cell count is not the\n    // delimiter cell count.\n    if (!hasDash || tableHeaderCount !== align.length) {\n      return nok(code)\n    }\n\n    if (code === null) {\n      return tableClose(code)\n    }\n\n    return effects.check(nextPrefixedOrBlank, tableClose, tableContinue)(code)\n  }\n\n  function tableClose(code) {\n    effects.exit('table')\n    return ok(code)\n  }\n\n  function tableContinue(code) {\n    // Always a line ending.\n    effects.enter('lineEnding')\n    effects.consume(code)\n    effects.exit('lineEnding')\n    // We checked that it’s not a prefixed or blank line, so we’re certain a\n    // body is coming, though it may be indented.\n    return createSpace(effects, bodyStart, 'linePrefix', 4)\n  }\n\n  function bodyStart(code) {\n    effects.enter('tableBody')\n    return rowStartBody(code)\n  }\n\n  function rowStartBody(code) {\n    effects.enter('tableRow')\n\n    // If we start with a pipe, we open a cell marker.\n    if (code === 124) {\n      return cellDividerBody(code)\n    }\n\n    effects.enter('temporaryTableCellContent')\n    // Can’t be space or eols at the start of a construct, so we’re in a cell.\n    return inCellContentBody(code)\n  }\n\n  function cellDividerBody(code) {\n    // Always a pipe.\n    effects.enter('tableCellDivider')\n    effects.consume(code)\n    effects.exit('tableCellDivider')\n    return cellBreakBody\n  }\n\n  function cellBreakBody(code) {\n    // EOF, CR, LF, CRLF.\n    if (code === null || code === -5 || code === -4 || code === -3) {\n      return atRowEndBody(code)\n    }\n\n    // HT, VS, SP.\n    if (code === -2 || code === -1 || code === 32) {\n      effects.enter('whitespace')\n      effects.consume(code)\n      return inWhitespaceBody\n    }\n\n    // `|`\n    if (code === 124) {\n      return cellDividerBody(code)\n    }\n\n    // Anything else is cell content.\n    effects.enter('temporaryTableCellContent')\n    return inCellContentBody(code)\n  }\n\n  function inWhitespaceBody(code) {\n    // HT, VS, SP.\n    if (code === -2 || code === -1 || code === 32) {\n      effects.consume(code)\n      return inWhitespaceBody\n    }\n\n    effects.exit('whitespace')\n    return cellBreakBody(code)\n  }\n\n  function inCellContentBody(code) {\n    // EOF, whitespace, pipe\n    if (code === null || code < 0 || code === 32 || code === 124) {\n      effects.exit('temporaryTableCellContent')\n      return cellBreakBody(code)\n    }\n\n    effects.consume(code)\n    // `\\`\n    return code === 92 ? inCellContentEscapeBody : inCellContentBody\n  }\n\n  function inCellContentEscapeBody(code) {\n    // `\\` or `|`\n    if (code === 92 || code === 124) {\n      effects.consume(code)\n      return inCellContentBody\n    }\n\n    // Anything else.\n    return inCellContentBody(code)\n  }\n\n  function atRowEndBody(code) {\n    effects.exit('tableRow')\n\n    if (code === null) {\n      return tableBodyClose(code)\n    }\n\n    return effects.check(\n      nextPrefixedOrBlank,\n      tableBodyClose,\n      tableBodyContinue\n    )(code)\n  }\n\n  function tableBodyClose(code) {\n    effects.exit('tableBody')\n    return tableClose(code)\n  }\n\n  function tableBodyContinue(code) {\n    // Always a line ending.\n    effects.enter('lineEnding')\n    effects.consume(code)\n    effects.exit('lineEnding')\n    // Support an optional prefix, then start a body row.\n    return createSpace(effects, rowStartBody, 'linePrefix', 4)\n  }\n}\n\n// Based on micromark, but that won’t work as we’re in a table, and that expects\n// content.\n// <https://github.com/micromark/micromark/blob/main/lib/tokenize/setext-underline.js>\nfunction tokenizeSetextUnderlineMini(effects, ok, nok) {\n  return start\n\n  function start(code) {\n    // `-`\n    if (code !== 45) {\n      return nok(code)\n    }\n\n    effects.enter('setextUnderline')\n    return sequence(code)\n  }\n\n  function sequence(code) {\n    if (code === 45) {\n      effects.consume(code)\n      return sequence\n    }\n\n    return whitespace(code)\n  }\n\n  function whitespace(code) {\n    if (code === -2 || code === -1 || code === 32) {\n      effects.consume(code)\n      return whitespace\n    }\n\n    if (code === null || code === -5 || code === -4 || code === -3) {\n      return ok(code)\n    }\n\n    return nok(code)\n  }\n}\n\nfunction tokenizeNextPrefixedOrBlank(effects, ok, nok) {\n  var size = 0\n\n  return start\n\n  function start(code) {\n    // This is a check, so we don’t care about tokens, but we open a bogus one\n    // so we’re valid.\n    effects.enter('check')\n    // EOL.\n    effects.consume(code)\n    return whitespace\n  }\n\n  function whitespace(code) {\n    // VS or SP.\n    if (code === -1 || code === 32) {\n      effects.consume(code)\n      size++\n      return size === 4 ? ok : whitespace\n    }\n\n    // EOF or whitespace\n    if (code === null || code < 0) {\n      return ok(code)\n    }\n\n    // Anything else.\n    return nok(code)\n  }\n}\n"],"mappings":"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"},"metadata":{},"sourceType":"script"}