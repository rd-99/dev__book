{"ast":null,"code":"(function (Prism) {\n  var keyword = /\\b(?:alignas|alignof|asm|auto|bool|break|case|catch|char|char8_t|char16_t|char32_t|class|compl|concept|const|consteval|constexpr|constinit|const_cast|continue|co_await|co_return|co_yield|decltype|default|delete|do|double|dynamic_cast|else|enum|explicit|export|extern|final|float|for|friend|goto|if|import|inline|int|int8_t|int16_t|int32_t|int64_t|uint8_t|uint16_t|uint32_t|uint64_t|long|module|mutable|namespace|new|noexcept|nullptr|operator|override|private|protected|public|register|reinterpret_cast|requires|return|short|signed|sizeof|static|static_assert|static_cast|struct|switch|template|this|thread_local|throw|try|typedef|typeid|typename|union|unsigned|using|virtual|void|volatile|wchar_t|while)\\b/;\n  var modName = /\\b(?!<keyword>)\\w+(?:\\s*\\.\\s*\\w+)*\\b/.source.replace(/<keyword>/g, function () {\n    return keyword.source;\n  });\n  Prism.languages.cpp = Prism.languages.extend('c', {\n    'class-name': [{\n      pattern: RegExp(/(\\b(?:class|concept|enum|struct|typename)\\s+)(?!<keyword>)\\w+/.source.replace(/<keyword>/g, function () {\n        return keyword.source;\n      })),\n      lookbehind: true\n    },\n    // This is intended to capture the class name of method implementations like:\n    //   void foo::bar() const {}\n    // However! The `foo` in the above example could also be a namespace, so we only capture the class name if\n    // it starts with an uppercase letter. This approximation should give decent results.\n    /\\b[A-Z]\\w*(?=\\s*::\\s*\\w+\\s*\\()/,\n    // This will capture the class name before destructors like:\n    //   Foo::~Foo() {}\n    /\\b[A-Z_]\\w*(?=\\s*::\\s*~\\w+\\s*\\()/i,\n    // This also intends to capture the class name of method implementations but here the class has template\n    // parameters, so it can't be a namespace (until C++ adds generic namespaces).\n    /\\b\\w+(?=\\s*<(?:[^<>]|<(?:[^<>]|<[^<>]*>)*>)*>\\s*::\\s*\\w+\\s*\\()/],\n    'keyword': keyword,\n    'number': {\n      pattern: /(?:\\b0b[01']+|\\b0x(?:[\\da-f']+(?:\\.[\\da-f']*)?|\\.[\\da-f']+)(?:p[+-]?[\\d']+)?|(?:\\b[\\d']+(?:\\.[\\d']*)?|\\B\\.[\\d']+)(?:e[+-]?[\\d']+)?)[ful]{0,4}/i,\n      greedy: true\n    },\n    'operator': />>=?|<<=?|->|--|\\+\\+|&&|\\|\\||[?:~]|<=>|[-+*/%&|^!=<>]=?|\\b(?:and|and_eq|bitand|bitor|not|not_eq|or|or_eq|xor|xor_eq)\\b/,\n    'boolean': /\\b(?:true|false)\\b/\n  });\n  Prism.languages.insertBefore('cpp', 'string', {\n    'module': {\n      // https://en.cppreference.com/w/cpp/language/modules\n      pattern: RegExp(/(\\b(?:module|import)\\s+)/.source + '(?:' +\n      // header-name\n      /\"(?:\\\\(?:\\r\\n|[\\s\\S])|[^\"\\\\\\r\\n])*\"|<[^<>\\r\\n]*>/.source + '|' +\n      // module name or partition or both\n      /<mod-name>(?:\\s*:\\s*<mod-name>)?|:\\s*<mod-name>/.source.replace(/<mod-name>/g, function () {\n        return modName;\n      }) + ')'),\n      lookbehind: true,\n      greedy: true,\n      inside: {\n        'string': /^[<\"][\\s\\S]+/,\n        'operator': /:/,\n        'punctuation': /\\./\n      }\n    },\n    'raw-string': {\n      pattern: /R\"([^()\\\\ ]{0,16})\\([\\s\\S]*?\\)\\1\"/,\n      alias: 'string',\n      greedy: true\n    }\n  });\n  Prism.languages.insertBefore('cpp', 'keyword', {\n    'generic-function': {\n      pattern: /\\b[a-z_]\\w*\\s*<(?:[^<>]|<(?:[^<>])*>)*>(?=\\s*\\()/i,\n      inside: {\n        'function': /^\\w+/,\n        'generic': {\n          pattern: /<[\\s\\S]+/,\n          alias: 'class-name',\n          inside: Prism.languages.cpp\n        }\n      }\n    }\n  });\n  Prism.languages.insertBefore('cpp', 'operator', {\n    'double-colon': {\n      pattern: /::/,\n      alias: 'punctuation'\n    }\n  });\n  Prism.languages.insertBefore('cpp', 'class-name', {\n    // the base clause is an optional list of parent classes\n    // https://en.cppreference.com/w/cpp/language/class\n    'base-clause': {\n      pattern: /(\\b(?:class|struct)\\s+\\w+\\s*:\\s*)[^;{}\"'\\s]+(?:\\s+[^;{}\"'\\s]+)*(?=\\s*[;{])/,\n      lookbehind: true,\n      greedy: true,\n      inside: Prism.languages.extend('cpp', {})\n    }\n  });\n  Prism.languages.insertBefore('inside', 'double-colon', {\n    // All untokenized words that are not namespaces should be class names\n    'class-name': /\\b[a-z_]\\w*\\b(?!\\s*::)/i\n  }, Prism.languages.cpp['base-clause']);\n})(Prism);","map":{"version":3,"names":["Prism","keyword","modName","source","replace","languages","cpp","extend","pattern","RegExp","lookbehind","greedy","insertBefore","inside","alias"],"sources":["C:/Users/Acer/Desktop/dev__book/dev__book/node_modules/prismjs/components/prism-cpp.js"],"sourcesContent":["(function (Prism) {\n\n\tvar keyword = /\\b(?:alignas|alignof|asm|auto|bool|break|case|catch|char|char8_t|char16_t|char32_t|class|compl|concept|const|consteval|constexpr|constinit|const_cast|continue|co_await|co_return|co_yield|decltype|default|delete|do|double|dynamic_cast|else|enum|explicit|export|extern|final|float|for|friend|goto|if|import|inline|int|int8_t|int16_t|int32_t|int64_t|uint8_t|uint16_t|uint32_t|uint64_t|long|module|mutable|namespace|new|noexcept|nullptr|operator|override|private|protected|public|register|reinterpret_cast|requires|return|short|signed|sizeof|static|static_assert|static_cast|struct|switch|template|this|thread_local|throw|try|typedef|typeid|typename|union|unsigned|using|virtual|void|volatile|wchar_t|while)\\b/;\n\tvar modName = /\\b(?!<keyword>)\\w+(?:\\s*\\.\\s*\\w+)*\\b/.source.replace(/<keyword>/g, function () { return keyword.source; });\n\n\tPrism.languages.cpp = Prism.languages.extend('c', {\n\t\t'class-name': [\n\t\t\t{\n\t\t\t\tpattern: RegExp(/(\\b(?:class|concept|enum|struct|typename)\\s+)(?!<keyword>)\\w+/.source\n\t\t\t\t\t.replace(/<keyword>/g, function () { return keyword.source; })),\n\t\t\t\tlookbehind: true\n\t\t\t},\n\t\t\t// This is intended to capture the class name of method implementations like:\n\t\t\t//   void foo::bar() const {}\n\t\t\t// However! The `foo` in the above example could also be a namespace, so we only capture the class name if\n\t\t\t// it starts with an uppercase letter. This approximation should give decent results.\n\t\t\t/\\b[A-Z]\\w*(?=\\s*::\\s*\\w+\\s*\\()/,\n\t\t\t// This will capture the class name before destructors like:\n\t\t\t//   Foo::~Foo() {}\n\t\t\t/\\b[A-Z_]\\w*(?=\\s*::\\s*~\\w+\\s*\\()/i,\n\t\t\t// This also intends to capture the class name of method implementations but here the class has template\n\t\t\t// parameters, so it can't be a namespace (until C++ adds generic namespaces).\n\t\t\t/\\b\\w+(?=\\s*<(?:[^<>]|<(?:[^<>]|<[^<>]*>)*>)*>\\s*::\\s*\\w+\\s*\\()/\n\t\t],\n\t\t'keyword': keyword,\n\t\t'number': {\n\t\t\tpattern: /(?:\\b0b[01']+|\\b0x(?:[\\da-f']+(?:\\.[\\da-f']*)?|\\.[\\da-f']+)(?:p[+-]?[\\d']+)?|(?:\\b[\\d']+(?:\\.[\\d']*)?|\\B\\.[\\d']+)(?:e[+-]?[\\d']+)?)[ful]{0,4}/i,\n\t\t\tgreedy: true\n\t\t},\n\t\t'operator': />>=?|<<=?|->|--|\\+\\+|&&|\\|\\||[?:~]|<=>|[-+*/%&|^!=<>]=?|\\b(?:and|and_eq|bitand|bitor|not|not_eq|or|or_eq|xor|xor_eq)\\b/,\n\t\t'boolean': /\\b(?:true|false)\\b/\n\t});\n\n\tPrism.languages.insertBefore('cpp', 'string', {\n\t\t'module': {\n\t\t\t// https://en.cppreference.com/w/cpp/language/modules\n\t\t\tpattern: RegExp(\n\t\t\t\t/(\\b(?:module|import)\\s+)/.source +\n\t\t\t\t'(?:' +\n\t\t\t\t// header-name\n\t\t\t\t/\"(?:\\\\(?:\\r\\n|[\\s\\S])|[^\"\\\\\\r\\n])*\"|<[^<>\\r\\n]*>/.source +\n\t\t\t\t'|' +\n\t\t\t\t// module name or partition or both\n\t\t\t\t/<mod-name>(?:\\s*:\\s*<mod-name>)?|:\\s*<mod-name>/.source.replace(/<mod-name>/g, function () { return modName; }) +\n\t\t\t\t')'\n\t\t\t),\n\t\t\tlookbehind: true,\n\t\t\tgreedy: true,\n\t\t\tinside: {\n\t\t\t\t'string': /^[<\"][\\s\\S]+/,\n\t\t\t\t'operator': /:/,\n\t\t\t\t'punctuation': /\\./\n\t\t\t}\n\t\t},\n\t\t'raw-string': {\n\t\t\tpattern: /R\"([^()\\\\ ]{0,16})\\([\\s\\S]*?\\)\\1\"/,\n\t\t\talias: 'string',\n\t\t\tgreedy: true\n\t\t}\n\t});\n\n\tPrism.languages.insertBefore('cpp', 'keyword', {\n\t\t'generic-function': {\n\t\t\tpattern: /\\b[a-z_]\\w*\\s*<(?:[^<>]|<(?:[^<>])*>)*>(?=\\s*\\()/i,\n\t\t\tinside: {\n\t\t\t\t'function': /^\\w+/,\n\t\t\t\t'generic': {\n\t\t\t\t\tpattern: /<[\\s\\S]+/,\n\t\t\t\t\talias: 'class-name',\n\t\t\t\t\tinside: Prism.languages.cpp\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t});\n\n\tPrism.languages.insertBefore('cpp', 'operator', {\n\t\t'double-colon': {\n\t\t\tpattern: /::/,\n\t\t\talias: 'punctuation'\n\t\t}\n\t});\n\n\tPrism.languages.insertBefore('cpp', 'class-name', {\n\t\t// the base clause is an optional list of parent classes\n\t\t// https://en.cppreference.com/w/cpp/language/class\n\t\t'base-clause': {\n\t\t\tpattern: /(\\b(?:class|struct)\\s+\\w+\\s*:\\s*)[^;{}\"'\\s]+(?:\\s+[^;{}\"'\\s]+)*(?=\\s*[;{])/,\n\t\t\tlookbehind: true,\n\t\t\tgreedy: true,\n\t\t\tinside: Prism.languages.extend('cpp', {})\n\t\t}\n\t});\n\n\tPrism.languages.insertBefore('inside', 'double-colon', {\n\t\t// All untokenized words that are not namespaces should be class names\n\t\t'class-name': /\\b[a-z_]\\w*\\b(?!\\s*::)/i\n\t}, Prism.languages.cpp['base-clause']);\n\n}(Prism));\n"],"mappings":"AAAC,WAAUA,KAAK,EAAE;EAEjB,IAAIC,OAAO,GAAG,msBAAmsB;EACjtB,IAAIC,OAAO,GAAG,sCAAsC,CAACC,MAAM,CAACC,OAAO,CAAC,YAAY,EAAE,YAAY;IAAE,OAAOH,OAAO,CAACE,MAAM;EAAE,CAAC,CAAC;EAEzHH,KAAK,CAACK,SAAS,CAACC,GAAG,GAAGN,KAAK,CAACK,SAAS,CAACE,MAAM,CAAC,GAAG,EAAE;IACjD,YAAY,EAAE,CACb;MACCC,OAAO,EAAEC,MAAM,CAAC,+DAA+D,CAACN,MAAM,CACpFC,OAAO,CAAC,YAAY,EAAE,YAAY;QAAE,OAAOH,OAAO,CAACE,MAAM;MAAE,CAAC,CAAC,CAAC;MAChEO,UAAU,EAAE;IACb,CAAC;IACD;IACA;IACA;IACA;IACA,gCAAgC;IAChC;IACA;IACA,mCAAmC;IACnC;IACA;IACA,gEAAgE,CAChE;IACD,SAAS,EAAET,OAAO;IAClB,QAAQ,EAAE;MACTO,OAAO,EAAE,gJAAgJ;MACzJG,MAAM,EAAE;IACT,CAAC;IACD,UAAU,EAAE,wHAAwH;IACpI,SAAS,EAAE;EACZ,CAAC,CAAC;EAEFX,KAAK,CAACK,SAAS,CAACO,YAAY,CAAC,KAAK,EAAE,QAAQ,EAAE;IAC7C,QAAQ,EAAE;MACT;MACAJ,OAAO,EAAEC,MAAM,CACd,0BAA0B,CAACN,MAAM,GACjC,KAAK;MACL;MACA,kDAAkD,CAACA,MAAM,GACzD,GAAG;MACH;MACA,iDAAiD,CAACA,MAAM,CAACC,OAAO,CAAC,aAAa,EAAE,YAAY;QAAE,OAAOF,OAAO;MAAE,CAAC,CAAC,GAChH,GACD,CAAC;MACDQ,UAAU,EAAE,IAAI;MAChBC,MAAM,EAAE,IAAI;MACZE,MAAM,EAAE;QACP,QAAQ,EAAE,cAAc;QACxB,UAAU,EAAE,GAAG;QACf,aAAa,EAAE;MAChB;IACD,CAAC;IACD,YAAY,EAAE;MACbL,OAAO,EAAE,mCAAmC;MAC5CM,KAAK,EAAE,QAAQ;MACfH,MAAM,EAAE;IACT;EACD,CAAC,CAAC;EAEFX,KAAK,CAACK,SAAS,CAACO,YAAY,CAAC,KAAK,EAAE,SAAS,EAAE;IAC9C,kBAAkB,EAAE;MACnBJ,OAAO,EAAE,mDAAmD;MAC5DK,MAAM,EAAE;QACP,UAAU,EAAE,MAAM;QAClB,SAAS,EAAE;UACVL,OAAO,EAAE,UAAU;UACnBM,KAAK,EAAE,YAAY;UACnBD,MAAM,EAAEb,KAAK,CAACK,SAAS,CAACC;QACzB;MACD;IACD;EACD,CAAC,CAAC;EAEFN,KAAK,CAACK,SAAS,CAACO,YAAY,CAAC,KAAK,EAAE,UAAU,EAAE;IAC/C,cAAc,EAAE;MACfJ,OAAO,EAAE,IAAI;MACbM,KAAK,EAAE;IACR;EACD,CAAC,CAAC;EAEFd,KAAK,CAACK,SAAS,CAACO,YAAY,CAAC,KAAK,EAAE,YAAY,EAAE;IACjD;IACA;IACA,aAAa,EAAE;MACdJ,OAAO,EAAE,4EAA4E;MACrFE,UAAU,EAAE,IAAI;MAChBC,MAAM,EAAE,IAAI;MACZE,MAAM,EAAEb,KAAK,CAACK,SAAS,CAACE,MAAM,CAAC,KAAK,EAAE,CAAC,CAAC;IACzC;EACD,CAAC,CAAC;EAEFP,KAAK,CAACK,SAAS,CAACO,YAAY,CAAC,QAAQ,EAAE,cAAc,EAAE;IACtD;IACA,YAAY,EAAE;EACf,CAAC,EAAEZ,KAAK,CAACK,SAAS,CAACC,GAAG,CAAC,aAAa,CAAC,CAAC;AAEvC,CAAC,EAACN,KAAK,CAAC"},"metadata":{},"sourceType":"script"}