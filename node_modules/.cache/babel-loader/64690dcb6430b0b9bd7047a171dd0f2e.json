{"ast":null,"code":"import getSurroundingWord from './getSurroundingWord';\nexport function selectWord(_ref) {\n  var text = _ref.text,\n    selection = _ref.selection;\n  if (text && text.length && selection.start === selection.end) {\n    // the user is pointing to a word\n    return getSurroundingWord(text, selection.start);\n  }\n  return selection;\n}\n/**\n *  Gets the number of line-breaks that would have to be inserted before the given 'startPosition'\n *  to make sure there's an empty line between 'startPosition' and the previous text\n */\n\nexport function getBreaksNeededForEmptyLineBefore() {\n  var text = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : \"\";\n  var startPosition = arguments.length > 1 ? arguments[1] : undefined;\n  if (startPosition === 0) return 0; // rules:\n  // - If we're in the first line, no breaks are needed\n  // - Otherwise there must be 2 breaks before the previous character. Depending on how many breaks exist already, we\n  //      may need to insert 0, 1 or 2 breaks\n\n  var neededBreaks = 2;\n  var isInFirstLine = true;\n  for (var i = startPosition - 1; i >= 0 && neededBreaks >= 0; i--) {\n    switch (text.charCodeAt(i)) {\n      case 32:\n        // blank space\n        continue;\n      case 10:\n        // line break\n        neededBreaks--;\n        isInFirstLine = false;\n        break;\n      default:\n        return neededBreaks;\n    }\n  }\n  return isInFirstLine ? 0 : neededBreaks;\n}\n/**\n *  Gets the number of line-breaks that would have to be inserted after the given 'startPosition'\n *  to make sure there's an empty line between 'startPosition' and the next text\n */\n\nexport function getBreaksNeededForEmptyLineAfter() {\n  var text = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : \"\";\n  var startPosition = arguments.length > 1 ? arguments[1] : undefined;\n  if (startPosition === text.length - 1) return 0; // rules:\n  // - If we're in the first line, no breaks are needed\n  // - Otherwise there must be 2 breaks before the previous character. Depending on how many breaks exist already, we\n  //      may need to insert 0, 1 or 2 breaks\n\n  var neededBreaks = 2;\n  var isInLastLine = true;\n  for (var i = startPosition; i < text.length && neededBreaks >= 0; i++) {\n    switch (text.charCodeAt(i)) {\n      case 32:\n        continue;\n      case 10:\n        {\n          neededBreaks--;\n          isInLastLine = false;\n          break;\n        }\n      default:\n        return neededBreaks;\n    }\n  }\n  return isInLastLine ? 0 : neededBreaks;\n}","map":{"version":3,"names":["getSurroundingWord","selectWord","_ref","text","selection","length","start","end","getBreaksNeededForEmptyLineBefore","arguments","undefined","startPosition","neededBreaks","isInFirstLine","i","charCodeAt","getBreaksNeededForEmptyLineAfter","isInLastLine"],"sources":["../../../src/utils/markdownUtils.ts"],"sourcesContent":["import { TextRange } from '../commands';\nimport getSurroundingWord from './getSurroundingWord';\n\nexport interface TextSection {\n  text: string;\n  selection: TextRange;\n}\n\nexport function selectWord({ text, selection }: TextSection): TextRange {\n  if (text && text.length && selection.start === selection.end) {\n    // the user is pointing to a word\n    return getSurroundingWord(text, selection.start);\n  }\n  return selection;\n}\n\n/**\n *  Gets the number of line-breaks that would have to be inserted before the given 'startPosition'\n *  to make sure there's an empty line between 'startPosition' and the previous text\n */\nexport function getBreaksNeededForEmptyLineBefore(text = \"\", startPosition: number): number {\n  if (startPosition === 0) return 0;\n\n  // rules:\n  // - If we're in the first line, no breaks are needed\n  // - Otherwise there must be 2 breaks before the previous character. Depending on how many breaks exist already, we\n  //      may need to insert 0, 1 or 2 breaks\n\n  let neededBreaks = 2;\n  let isInFirstLine = true;\n  for (let i = startPosition - 1; i >= 0 && (neededBreaks >= 0); i--) {\n    switch (text.charCodeAt(i)) {\n      case 32: // blank space\n        continue;\n      case 10: // line break\n        neededBreaks--;\n        isInFirstLine = false;\n        break;\n      default:\n        return neededBreaks;\n    }\n  }\n  return isInFirstLine ? 0 : neededBreaks;\n}\n\n/**\n *  Gets the number of line-breaks that would have to be inserted after the given 'startPosition'\n *  to make sure there's an empty line between 'startPosition' and the next text\n */\nexport function getBreaksNeededForEmptyLineAfter(text = \"\", startPosition: number): number {\n  if (startPosition === text.length - 1) return 0;\n\n  // rules:\n  // - If we're in the first line, no breaks are needed\n  // - Otherwise there must be 2 breaks before the previous character. Depending on how many breaks exist already, we\n  //      may need to insert 0, 1 or 2 breaks\n\n  let neededBreaks = 2;\n  let isInLastLine = true;\n  for (let i = startPosition; i < text.length && (neededBreaks >= 0); i++) {\n    switch (text.charCodeAt(i)) {\n      case 32:\n        continue;\n      case 10: {\n        neededBreaks--;\n        isInLastLine = false;\n        break;\n      }\n      default:\n        return neededBreaks;\n    }\n  }\n  return isInLastLine ? 0 : neededBreaks;\n}\n"],"mappings":"AACA,OAAOA,kBAAP,MAA+B,sBAA/B;AAOA,OAAO,SAASC,UAATA,CAAAC,IAAA,EAAiE;EAAA,IAA3CC,IAA2C,GAAAD,IAAA,CAA3CC,IAA2C;IAArCC,SAAqC,GAAAF,IAAA,CAArCE,SAAqC;EACtE,IAAID,IAAI,IAAIA,IAAI,CAACE,MAAb,IAAuBD,SAAS,CAACE,KAAV,KAAoBF,SAAS,CAACG,GAAzD,EAA8D;IAC5D;IACA,OAAOP,kBAAkB,CAACG,IAAD,EAAOC,SAAS,CAACE,KAAjB,CAAzB;EACD;EACD,OAAOF,SAAP;AACD;AAED;AACA;AACA;AACA;;AACA,OAAO,SAASI,iCAATA,CAAA,EAAqF;EAAA,IAA1CL,IAA0C,GAAAM,SAAA,CAAAJ,MAAA,QAAAI,SAAA,QAAAC,SAAA,GAAAD,SAAA,MAAnC,EAAmC;EAAA,IAA/BE,aAA+B,GAAAF,SAAA,CAAAJ,MAAA,OAAAI,SAAA,MAAAC,SAAA;EAC1F,IAAIC,aAAa,KAAK,CAAtB,EAAyB,OAAO,CAAP,CADiE,CAG1F;EACA;EACA;EACA;;EAEA,IAAIC,YAAY,GAAG,CAAnB;EACA,IAAIC,aAAa,GAAG,IAApB;EACA,KAAK,IAAIC,CAAC,GAAGH,aAAa,GAAG,CAA7B,EAAgCG,CAAC,IAAI,CAAL,IAAWF,YAAY,IAAI,CAA3D,EAA+DE,CAAC,EAAhE,EAAoE;IAClE,QAAQX,IAAI,CAACY,UAAL,CAAgBD,CAAhB,CAAR;MACE,KAAK,EAAL;QAAS;QACP;MACF,KAAK,EAAL;QAAS;QACPF,YAAY;QACZC,aAAa,GAAG,KAAhB;QACA;MACF;QACE,OAAOD,YAAP;IARJ;EAUD;EACD,OAAOC,aAAa,GAAG,CAAH,GAAOD,YAA3B;AACD;AAED;AACA;AACA;AACA;;AACA,OAAO,SAASI,gCAATA,CAAA,EAAoF;EAAA,IAA1Cb,IAA0C,GAAAM,SAAA,CAAAJ,MAAA,QAAAI,SAAA,QAAAC,SAAA,GAAAD,SAAA,MAAnC,EAAmC;EAAA,IAA/BE,aAA+B,GAAAF,SAAA,CAAAJ,MAAA,OAAAI,SAAA,MAAAC,SAAA;EACzF,IAAIC,aAAa,KAAKR,IAAI,CAACE,MAAL,GAAc,CAApC,EAAuC,OAAO,CAAP,CADkD,CAGzF;EACA;EACA;EACA;;EAEA,IAAIO,YAAY,GAAG,CAAnB;EACA,IAAIK,YAAY,GAAG,IAAnB;EACA,KAAK,IAAIH,CAAC,GAAGH,aAAb,EAA4BG,CAAC,GAAGX,IAAI,CAACE,MAAT,IAAoBO,YAAY,IAAI,CAAhE,EAAoEE,CAAC,EAArE,EAAyE;IACvE,QAAQX,IAAI,CAACY,UAAL,CAAgBD,CAAhB,CAAR;MACE,KAAK,EAAL;QACE;MACF,KAAK,EAAL;QAAS;UACPF,YAAY;UACZK,YAAY,GAAG,KAAf;UACA;QACD;MACD;QACE,OAAOL,YAAP;IATJ;EAWD;EACD,OAAOK,YAAY,GAAG,CAAH,GAAOL,YAA1B;AACD"},"metadata":{},"sourceType":"module"}