{"ast":null,"code":"\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.printComments = exports.attach = void 0;\nvar tslib_1 = require(\"tslib\");\nvar assert_1 = tslib_1.__importDefault(require(\"assert\"));\nvar types = tslib_1.__importStar(require(\"ast-types\"));\nvar n = types.namedTypes;\nvar isArray = types.builtInTypes.array;\nvar isObject = types.builtInTypes.object;\nvar lines_1 = require(\"./lines\");\nvar util_1 = require(\"./util\");\nvar childNodesCache = new WeakMap();\n// TODO Move a non-caching implementation of this function into ast-types,\n// and implement a caching wrapper function here.\nfunction getSortedChildNodes(node, lines, resultArray) {\n  if (!node) {\n    return resultArray;\n  }\n  // The .loc checks below are sensitive to some of the problems that\n  // are fixed by this utility function. Specifically, if it decides to\n  // set node.loc to null, indicating that the node's .loc information\n  // is unreliable, then we don't want to add node to the resultArray.\n  util_1.fixFaultyLocations(node, lines);\n  if (resultArray) {\n    if (n.Node.check(node) && n.SourceLocation.check(node.loc)) {\n      // This reverse insertion sort almost always takes constant\n      // time because we almost always (maybe always?) append the\n      // nodes in order anyway.\n      var i = resultArray.length - 1;\n      for (; i >= 0; --i) {\n        var child = resultArray[i];\n        if (child && child.loc && util_1.comparePos(child.loc.end, node.loc.start) <= 0) {\n          break;\n        }\n      }\n      resultArray.splice(i + 1, 0, node);\n      return resultArray;\n    }\n  } else {\n    var childNodes = childNodesCache.get(node);\n    if (childNodes) {\n      return childNodes;\n    }\n  }\n  var names;\n  if (isArray.check(node)) {\n    names = Object.keys(node);\n  } else if (isObject.check(node)) {\n    names = types.getFieldNames(node);\n  } else {\n    return resultArray;\n  }\n  if (!resultArray) {\n    childNodesCache.set(node, resultArray = []);\n  }\n  for (var i = 0, nameCount = names.length; i < nameCount; ++i) {\n    getSortedChildNodes(node[names[i]], lines, resultArray);\n  }\n  return resultArray;\n}\n// As efficiently as possible, decorate the comment object with\n// .precedingNode, .enclosingNode, and/or .followingNode properties, at\n// least one of which is guaranteed to be defined.\nfunction decorateComment(node, comment, lines) {\n  var childNodes = getSortedChildNodes(node, lines);\n  // Time to dust off the old binary search robes and wizard hat.\n  var left = 0;\n  var right = childNodes && childNodes.length;\n  var precedingNode;\n  var followingNode;\n  while (typeof right === \"number\" && left < right) {\n    var middle = left + right >> 1;\n    var child = childNodes[middle];\n    if (util_1.comparePos(child.loc.start, comment.loc.start) <= 0 && util_1.comparePos(comment.loc.end, child.loc.end) <= 0) {\n      // The comment is completely contained by this child node.\n      decorateComment(comment.enclosingNode = child, comment, lines);\n      return; // Abandon the binary search at this level.\n    }\n\n    if (util_1.comparePos(child.loc.end, comment.loc.start) <= 0) {\n      // This child node falls completely before the comment.\n      // Because we will never consider this node or any nodes\n      // before it again, this node must be the closest preceding\n      // node we have encountered so far.\n      precedingNode = child;\n      left = middle + 1;\n      continue;\n    }\n    if (util_1.comparePos(comment.loc.end, child.loc.start) <= 0) {\n      // This child node falls completely after the comment.\n      // Because we will never consider this node or any nodes after\n      // it again, this node must be the closest following node we\n      // have encountered so far.\n      followingNode = child;\n      right = middle;\n      continue;\n    }\n    throw new Error(\"Comment location overlaps with node location\");\n  }\n  if (precedingNode) {\n    comment.precedingNode = precedingNode;\n  }\n  if (followingNode) {\n    comment.followingNode = followingNode;\n  }\n}\nfunction attach(comments, ast, lines) {\n  if (!isArray.check(comments)) {\n    return;\n  }\n  var tiesToBreak = [];\n  comments.forEach(function (comment) {\n    comment.loc.lines = lines;\n    decorateComment(ast, comment, lines);\n    var pn = comment.precedingNode;\n    var en = comment.enclosingNode;\n    var fn = comment.followingNode;\n    if (pn && fn) {\n      var tieCount = tiesToBreak.length;\n      if (tieCount > 0) {\n        var lastTie = tiesToBreak[tieCount - 1];\n        assert_1.default.strictEqual(lastTie.precedingNode === comment.precedingNode, lastTie.followingNode === comment.followingNode);\n        if (lastTie.followingNode !== comment.followingNode) {\n          breakTies(tiesToBreak, lines);\n        }\n      }\n      tiesToBreak.push(comment);\n    } else if (pn) {\n      // No contest: we have a trailing comment.\n      breakTies(tiesToBreak, lines);\n      addTrailingComment(pn, comment);\n    } else if (fn) {\n      // No contest: we have a leading comment.\n      breakTies(tiesToBreak, lines);\n      addLeadingComment(fn, comment);\n    } else if (en) {\n      // The enclosing node has no child nodes at all, so what we\n      // have here is a dangling comment, e.g. [/* crickets */].\n      breakTies(tiesToBreak, lines);\n      addDanglingComment(en, comment);\n    } else {\n      throw new Error(\"AST contains no nodes at all?\");\n    }\n  });\n  breakTies(tiesToBreak, lines);\n  comments.forEach(function (comment) {\n    // These node references were useful for breaking ties, but we\n    // don't need them anymore, and they create cycles in the AST that\n    // may lead to infinite recursion if we don't delete them here.\n    delete comment.precedingNode;\n    delete comment.enclosingNode;\n    delete comment.followingNode;\n  });\n}\nexports.attach = attach;\nfunction breakTies(tiesToBreak, lines) {\n  var tieCount = tiesToBreak.length;\n  if (tieCount === 0) {\n    return;\n  }\n  var pn = tiesToBreak[0].precedingNode;\n  var fn = tiesToBreak[0].followingNode;\n  var gapEndPos = fn.loc.start;\n  // Iterate backwards through tiesToBreak, examining the gaps\n  // between the tied comments. In order to qualify as leading, a\n  // comment must be separated from fn by an unbroken series of\n  // whitespace-only gaps (or other comments).\n  var indexOfFirstLeadingComment = tieCount;\n  var comment;\n  for (; indexOfFirstLeadingComment > 0; --indexOfFirstLeadingComment) {\n    comment = tiesToBreak[indexOfFirstLeadingComment - 1];\n    assert_1.default.strictEqual(comment.precedingNode, pn);\n    assert_1.default.strictEqual(comment.followingNode, fn);\n    var gap = lines.sliceString(comment.loc.end, gapEndPos);\n    if (/\\S/.test(gap)) {\n      // The gap string contained something other than whitespace.\n      break;\n    }\n    gapEndPos = comment.loc.start;\n  }\n  while (indexOfFirstLeadingComment <= tieCount && (comment = tiesToBreak[indexOfFirstLeadingComment]) && (\n  // If the comment is a //-style comment and indented more\n  // deeply than the node itself, reconsider it as trailing.\n  comment.type === \"Line\" || comment.type === \"CommentLine\") && comment.loc.start.column > fn.loc.start.column) {\n    ++indexOfFirstLeadingComment;\n  }\n  tiesToBreak.forEach(function (comment, i) {\n    if (i < indexOfFirstLeadingComment) {\n      addTrailingComment(pn, comment);\n    } else {\n      addLeadingComment(fn, comment);\n    }\n  });\n  tiesToBreak.length = 0;\n}\nfunction addCommentHelper(node, comment) {\n  var comments = node.comments || (node.comments = []);\n  comments.push(comment);\n}\nfunction addLeadingComment(node, comment) {\n  comment.leading = true;\n  comment.trailing = false;\n  addCommentHelper(node, comment);\n}\nfunction addDanglingComment(node, comment) {\n  comment.leading = false;\n  comment.trailing = false;\n  addCommentHelper(node, comment);\n}\nfunction addTrailingComment(node, comment) {\n  comment.leading = false;\n  comment.trailing = true;\n  addCommentHelper(node, comment);\n}\nfunction printLeadingComment(commentPath, print) {\n  var comment = commentPath.getValue();\n  n.Comment.assert(comment);\n  var loc = comment.loc;\n  var lines = loc && loc.lines;\n  var parts = [print(commentPath)];\n  if (comment.trailing) {\n    // When we print trailing comments as leading comments, we don't\n    // want to bring any trailing spaces along.\n    parts.push(\"\\n\");\n  } else if (lines instanceof lines_1.Lines) {\n    var trailingSpace = lines.slice(loc.end, lines.skipSpaces(loc.end) || lines.lastPos());\n    if (trailingSpace.length === 1) {\n      // If the trailing space contains no newlines, then we want to\n      // preserve it exactly as we found it.\n      parts.push(trailingSpace);\n    } else {\n      // If the trailing space contains newlines, then replace it\n      // with just that many newlines, with all other spaces removed.\n      parts.push(new Array(trailingSpace.length).join(\"\\n\"));\n    }\n  } else {\n    parts.push(\"\\n\");\n  }\n  return lines_1.concat(parts);\n}\nfunction printTrailingComment(commentPath, print) {\n  var comment = commentPath.getValue(commentPath);\n  n.Comment.assert(comment);\n  var loc = comment.loc;\n  var lines = loc && loc.lines;\n  var parts = [];\n  if (lines instanceof lines_1.Lines) {\n    var fromPos = lines.skipSpaces(loc.start, true) || lines.firstPos();\n    var leadingSpace = lines.slice(fromPos, loc.start);\n    if (leadingSpace.length === 1) {\n      // If the leading space contains no newlines, then we want to\n      // preserve it exactly as we found it.\n      parts.push(leadingSpace);\n    } else {\n      // If the leading space contains newlines, then replace it\n      // with just that many newlines, sans all other spaces.\n      parts.push(new Array(leadingSpace.length).join(\"\\n\"));\n    }\n  }\n  parts.push(print(commentPath));\n  return lines_1.concat(parts);\n}\nfunction printComments(path, print) {\n  var value = path.getValue();\n  var innerLines = print(path);\n  var comments = n.Node.check(value) && types.getFieldValue(value, \"comments\");\n  if (!comments || comments.length === 0) {\n    return innerLines;\n  }\n  var leadingParts = [];\n  var trailingParts = [innerLines];\n  path.each(function (commentPath) {\n    var comment = commentPath.getValue();\n    var leading = types.getFieldValue(comment, \"leading\");\n    var trailing = types.getFieldValue(comment, \"trailing\");\n    if (leading || trailing && !(n.Statement.check(value) || comment.type === \"Block\" || comment.type === \"CommentBlock\")) {\n      leadingParts.push(printLeadingComment(commentPath, print));\n    } else if (trailing) {\n      trailingParts.push(printTrailingComment(commentPath, print));\n    }\n  }, \"comments\");\n  leadingParts.push.apply(leadingParts, trailingParts);\n  return lines_1.concat(leadingParts);\n}\nexports.printComments = printComments;","map":{"version":3,"names":["Object","defineProperty","exports","value","printComments","attach","tslib_1","require","assert_1","__importDefault","types","__importStar","n","namedTypes","isArray","builtInTypes","array","isObject","object","lines_1","util_1","childNodesCache","WeakMap","getSortedChildNodes","node","lines","resultArray","fixFaultyLocations","Node","check","SourceLocation","loc","i","length","child","comparePos","end","start","splice","childNodes","get","names","keys","getFieldNames","set","nameCount","decorateComment","comment","left","right","precedingNode","followingNode","middle","enclosingNode","Error","comments","ast","tiesToBreak","forEach","pn","en","fn","tieCount","lastTie","default","strictEqual","breakTies","push","addTrailingComment","addLeadingComment","addDanglingComment","gapEndPos","indexOfFirstLeadingComment","gap","sliceString","test","type","column","addCommentHelper","leading","trailing","printLeadingComment","commentPath","print","getValue","Comment","assert","parts","Lines","trailingSpace","slice","skipSpaces","lastPos","Array","join","concat","printTrailingComment","fromPos","firstPos","leadingSpace","path","innerLines","getFieldValue","leadingParts","trailingParts","each","Statement","apply"],"sources":["C:/Users/Acer/Desktop/dev__book/dev__book/node_modules/jscodeshift/node_modules/recast/lib/comments.js"],"sourcesContent":["\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.printComments = exports.attach = void 0;\nvar tslib_1 = require(\"tslib\");\nvar assert_1 = tslib_1.__importDefault(require(\"assert\"));\nvar types = tslib_1.__importStar(require(\"ast-types\"));\nvar n = types.namedTypes;\nvar isArray = types.builtInTypes.array;\nvar isObject = types.builtInTypes.object;\nvar lines_1 = require(\"./lines\");\nvar util_1 = require(\"./util\");\nvar childNodesCache = new WeakMap();\n// TODO Move a non-caching implementation of this function into ast-types,\n// and implement a caching wrapper function here.\nfunction getSortedChildNodes(node, lines, resultArray) {\n    if (!node) {\n        return resultArray;\n    }\n    // The .loc checks below are sensitive to some of the problems that\n    // are fixed by this utility function. Specifically, if it decides to\n    // set node.loc to null, indicating that the node's .loc information\n    // is unreliable, then we don't want to add node to the resultArray.\n    util_1.fixFaultyLocations(node, lines);\n    if (resultArray) {\n        if (n.Node.check(node) && n.SourceLocation.check(node.loc)) {\n            // This reverse insertion sort almost always takes constant\n            // time because we almost always (maybe always?) append the\n            // nodes in order anyway.\n            var i = resultArray.length - 1;\n            for (; i >= 0; --i) {\n                var child = resultArray[i];\n                if (child &&\n                    child.loc &&\n                    util_1.comparePos(child.loc.end, node.loc.start) <= 0) {\n                    break;\n                }\n            }\n            resultArray.splice(i + 1, 0, node);\n            return resultArray;\n        }\n    }\n    else {\n        var childNodes = childNodesCache.get(node);\n        if (childNodes) {\n            return childNodes;\n        }\n    }\n    var names;\n    if (isArray.check(node)) {\n        names = Object.keys(node);\n    }\n    else if (isObject.check(node)) {\n        names = types.getFieldNames(node);\n    }\n    else {\n        return resultArray;\n    }\n    if (!resultArray) {\n        childNodesCache.set(node, (resultArray = []));\n    }\n    for (var i = 0, nameCount = names.length; i < nameCount; ++i) {\n        getSortedChildNodes(node[names[i]], lines, resultArray);\n    }\n    return resultArray;\n}\n// As efficiently as possible, decorate the comment object with\n// .precedingNode, .enclosingNode, and/or .followingNode properties, at\n// least one of which is guaranteed to be defined.\nfunction decorateComment(node, comment, lines) {\n    var childNodes = getSortedChildNodes(node, lines);\n    // Time to dust off the old binary search robes and wizard hat.\n    var left = 0;\n    var right = childNodes && childNodes.length;\n    var precedingNode;\n    var followingNode;\n    while (typeof right === \"number\" && left < right) {\n        var middle = (left + right) >> 1;\n        var child = childNodes[middle];\n        if (util_1.comparePos(child.loc.start, comment.loc.start) <= 0 &&\n            util_1.comparePos(comment.loc.end, child.loc.end) <= 0) {\n            // The comment is completely contained by this child node.\n            decorateComment((comment.enclosingNode = child), comment, lines);\n            return; // Abandon the binary search at this level.\n        }\n        if (util_1.comparePos(child.loc.end, comment.loc.start) <= 0) {\n            // This child node falls completely before the comment.\n            // Because we will never consider this node or any nodes\n            // before it again, this node must be the closest preceding\n            // node we have encountered so far.\n            precedingNode = child;\n            left = middle + 1;\n            continue;\n        }\n        if (util_1.comparePos(comment.loc.end, child.loc.start) <= 0) {\n            // This child node falls completely after the comment.\n            // Because we will never consider this node or any nodes after\n            // it again, this node must be the closest following node we\n            // have encountered so far.\n            followingNode = child;\n            right = middle;\n            continue;\n        }\n        throw new Error(\"Comment location overlaps with node location\");\n    }\n    if (precedingNode) {\n        comment.precedingNode = precedingNode;\n    }\n    if (followingNode) {\n        comment.followingNode = followingNode;\n    }\n}\nfunction attach(comments, ast, lines) {\n    if (!isArray.check(comments)) {\n        return;\n    }\n    var tiesToBreak = [];\n    comments.forEach(function (comment) {\n        comment.loc.lines = lines;\n        decorateComment(ast, comment, lines);\n        var pn = comment.precedingNode;\n        var en = comment.enclosingNode;\n        var fn = comment.followingNode;\n        if (pn && fn) {\n            var tieCount = tiesToBreak.length;\n            if (tieCount > 0) {\n                var lastTie = tiesToBreak[tieCount - 1];\n                assert_1.default.strictEqual(lastTie.precedingNode === comment.precedingNode, lastTie.followingNode === comment.followingNode);\n                if (lastTie.followingNode !== comment.followingNode) {\n                    breakTies(tiesToBreak, lines);\n                }\n            }\n            tiesToBreak.push(comment);\n        }\n        else if (pn) {\n            // No contest: we have a trailing comment.\n            breakTies(tiesToBreak, lines);\n            addTrailingComment(pn, comment);\n        }\n        else if (fn) {\n            // No contest: we have a leading comment.\n            breakTies(tiesToBreak, lines);\n            addLeadingComment(fn, comment);\n        }\n        else if (en) {\n            // The enclosing node has no child nodes at all, so what we\n            // have here is a dangling comment, e.g. [/* crickets */].\n            breakTies(tiesToBreak, lines);\n            addDanglingComment(en, comment);\n        }\n        else {\n            throw new Error(\"AST contains no nodes at all?\");\n        }\n    });\n    breakTies(tiesToBreak, lines);\n    comments.forEach(function (comment) {\n        // These node references were useful for breaking ties, but we\n        // don't need them anymore, and they create cycles in the AST that\n        // may lead to infinite recursion if we don't delete them here.\n        delete comment.precedingNode;\n        delete comment.enclosingNode;\n        delete comment.followingNode;\n    });\n}\nexports.attach = attach;\nfunction breakTies(tiesToBreak, lines) {\n    var tieCount = tiesToBreak.length;\n    if (tieCount === 0) {\n        return;\n    }\n    var pn = tiesToBreak[0].precedingNode;\n    var fn = tiesToBreak[0].followingNode;\n    var gapEndPos = fn.loc.start;\n    // Iterate backwards through tiesToBreak, examining the gaps\n    // between the tied comments. In order to qualify as leading, a\n    // comment must be separated from fn by an unbroken series of\n    // whitespace-only gaps (or other comments).\n    var indexOfFirstLeadingComment = tieCount;\n    var comment;\n    for (; indexOfFirstLeadingComment > 0; --indexOfFirstLeadingComment) {\n        comment = tiesToBreak[indexOfFirstLeadingComment - 1];\n        assert_1.default.strictEqual(comment.precedingNode, pn);\n        assert_1.default.strictEqual(comment.followingNode, fn);\n        var gap = lines.sliceString(comment.loc.end, gapEndPos);\n        if (/\\S/.test(gap)) {\n            // The gap string contained something other than whitespace.\n            break;\n        }\n        gapEndPos = comment.loc.start;\n    }\n    while (indexOfFirstLeadingComment <= tieCount &&\n        (comment = tiesToBreak[indexOfFirstLeadingComment]) &&\n        // If the comment is a //-style comment and indented more\n        // deeply than the node itself, reconsider it as trailing.\n        (comment.type === \"Line\" || comment.type === \"CommentLine\") &&\n        comment.loc.start.column > fn.loc.start.column) {\n        ++indexOfFirstLeadingComment;\n    }\n    tiesToBreak.forEach(function (comment, i) {\n        if (i < indexOfFirstLeadingComment) {\n            addTrailingComment(pn, comment);\n        }\n        else {\n            addLeadingComment(fn, comment);\n        }\n    });\n    tiesToBreak.length = 0;\n}\nfunction addCommentHelper(node, comment) {\n    var comments = node.comments || (node.comments = []);\n    comments.push(comment);\n}\nfunction addLeadingComment(node, comment) {\n    comment.leading = true;\n    comment.trailing = false;\n    addCommentHelper(node, comment);\n}\nfunction addDanglingComment(node, comment) {\n    comment.leading = false;\n    comment.trailing = false;\n    addCommentHelper(node, comment);\n}\nfunction addTrailingComment(node, comment) {\n    comment.leading = false;\n    comment.trailing = true;\n    addCommentHelper(node, comment);\n}\nfunction printLeadingComment(commentPath, print) {\n    var comment = commentPath.getValue();\n    n.Comment.assert(comment);\n    var loc = comment.loc;\n    var lines = loc && loc.lines;\n    var parts = [print(commentPath)];\n    if (comment.trailing) {\n        // When we print trailing comments as leading comments, we don't\n        // want to bring any trailing spaces along.\n        parts.push(\"\\n\");\n    }\n    else if (lines instanceof lines_1.Lines) {\n        var trailingSpace = lines.slice(loc.end, lines.skipSpaces(loc.end) || lines.lastPos());\n        if (trailingSpace.length === 1) {\n            // If the trailing space contains no newlines, then we want to\n            // preserve it exactly as we found it.\n            parts.push(trailingSpace);\n        }\n        else {\n            // If the trailing space contains newlines, then replace it\n            // with just that many newlines, with all other spaces removed.\n            parts.push(new Array(trailingSpace.length).join(\"\\n\"));\n        }\n    }\n    else {\n        parts.push(\"\\n\");\n    }\n    return lines_1.concat(parts);\n}\nfunction printTrailingComment(commentPath, print) {\n    var comment = commentPath.getValue(commentPath);\n    n.Comment.assert(comment);\n    var loc = comment.loc;\n    var lines = loc && loc.lines;\n    var parts = [];\n    if (lines instanceof lines_1.Lines) {\n        var fromPos = lines.skipSpaces(loc.start, true) || lines.firstPos();\n        var leadingSpace = lines.slice(fromPos, loc.start);\n        if (leadingSpace.length === 1) {\n            // If the leading space contains no newlines, then we want to\n            // preserve it exactly as we found it.\n            parts.push(leadingSpace);\n        }\n        else {\n            // If the leading space contains newlines, then replace it\n            // with just that many newlines, sans all other spaces.\n            parts.push(new Array(leadingSpace.length).join(\"\\n\"));\n        }\n    }\n    parts.push(print(commentPath));\n    return lines_1.concat(parts);\n}\nfunction printComments(path, print) {\n    var value = path.getValue();\n    var innerLines = print(path);\n    var comments = n.Node.check(value) && types.getFieldValue(value, \"comments\");\n    if (!comments || comments.length === 0) {\n        return innerLines;\n    }\n    var leadingParts = [];\n    var trailingParts = [innerLines];\n    path.each(function (commentPath) {\n        var comment = commentPath.getValue();\n        var leading = types.getFieldValue(comment, \"leading\");\n        var trailing = types.getFieldValue(comment, \"trailing\");\n        if (leading ||\n            (trailing &&\n                !(n.Statement.check(value) ||\n                    comment.type === \"Block\" ||\n                    comment.type === \"CommentBlock\"))) {\n            leadingParts.push(printLeadingComment(commentPath, print));\n        }\n        else if (trailing) {\n            trailingParts.push(printTrailingComment(commentPath, print));\n        }\n    }, \"comments\");\n    leadingParts.push.apply(leadingParts, trailingParts);\n    return lines_1.concat(leadingParts);\n}\nexports.printComments = printComments;\n"],"mappings":"AAAA,YAAY;;AACZA,MAAM,CAACC,cAAc,CAACC,OAAO,EAAE,YAAY,EAAE;EAAEC,KAAK,EAAE;AAAK,CAAC,CAAC;AAC7DD,OAAO,CAACE,aAAa,GAAGF,OAAO,CAACG,MAAM,GAAG,KAAK,CAAC;AAC/C,IAAIC,OAAO,GAAGC,OAAO,CAAC,OAAO,CAAC;AAC9B,IAAIC,QAAQ,GAAGF,OAAO,CAACG,eAAe,CAACF,OAAO,CAAC,QAAQ,CAAC,CAAC;AACzD,IAAIG,KAAK,GAAGJ,OAAO,CAACK,YAAY,CAACJ,OAAO,CAAC,WAAW,CAAC,CAAC;AACtD,IAAIK,CAAC,GAAGF,KAAK,CAACG,UAAU;AACxB,IAAIC,OAAO,GAAGJ,KAAK,CAACK,YAAY,CAACC,KAAK;AACtC,IAAIC,QAAQ,GAAGP,KAAK,CAACK,YAAY,CAACG,MAAM;AACxC,IAAIC,OAAO,GAAGZ,OAAO,CAAC,SAAS,CAAC;AAChC,IAAIa,MAAM,GAAGb,OAAO,CAAC,QAAQ,CAAC;AAC9B,IAAIc,eAAe,GAAG,IAAIC,OAAO,CAAC,CAAC;AACnC;AACA;AACA,SAASC,mBAAmBA,CAACC,IAAI,EAAEC,KAAK,EAAEC,WAAW,EAAE;EACnD,IAAI,CAACF,IAAI,EAAE;IACP,OAAOE,WAAW;EACtB;EACA;EACA;EACA;EACA;EACAN,MAAM,CAACO,kBAAkB,CAACH,IAAI,EAAEC,KAAK,CAAC;EACtC,IAAIC,WAAW,EAAE;IACb,IAAId,CAAC,CAACgB,IAAI,CAACC,KAAK,CAACL,IAAI,CAAC,IAAIZ,CAAC,CAACkB,cAAc,CAACD,KAAK,CAACL,IAAI,CAACO,GAAG,CAAC,EAAE;MACxD;MACA;MACA;MACA,IAAIC,CAAC,GAAGN,WAAW,CAACO,MAAM,GAAG,CAAC;MAC9B,OAAOD,CAAC,IAAI,CAAC,EAAE,EAAEA,CAAC,EAAE;QAChB,IAAIE,KAAK,GAAGR,WAAW,CAACM,CAAC,CAAC;QAC1B,IAAIE,KAAK,IACLA,KAAK,CAACH,GAAG,IACTX,MAAM,CAACe,UAAU,CAACD,KAAK,CAACH,GAAG,CAACK,GAAG,EAAEZ,IAAI,CAACO,GAAG,CAACM,KAAK,CAAC,IAAI,CAAC,EAAE;UACvD;QACJ;MACJ;MACAX,WAAW,CAACY,MAAM,CAACN,CAAC,GAAG,CAAC,EAAE,CAAC,EAAER,IAAI,CAAC;MAClC,OAAOE,WAAW;IACtB;EACJ,CAAC,MACI;IACD,IAAIa,UAAU,GAAGlB,eAAe,CAACmB,GAAG,CAAChB,IAAI,CAAC;IAC1C,IAAIe,UAAU,EAAE;MACZ,OAAOA,UAAU;IACrB;EACJ;EACA,IAAIE,KAAK;EACT,IAAI3B,OAAO,CAACe,KAAK,CAACL,IAAI,CAAC,EAAE;IACrBiB,KAAK,GAAGzC,MAAM,CAAC0C,IAAI,CAAClB,IAAI,CAAC;EAC7B,CAAC,MACI,IAAIP,QAAQ,CAACY,KAAK,CAACL,IAAI,CAAC,EAAE;IAC3BiB,KAAK,GAAG/B,KAAK,CAACiC,aAAa,CAACnB,IAAI,CAAC;EACrC,CAAC,MACI;IACD,OAAOE,WAAW;EACtB;EACA,IAAI,CAACA,WAAW,EAAE;IACdL,eAAe,CAACuB,GAAG,CAACpB,IAAI,EAAGE,WAAW,GAAG,EAAG,CAAC;EACjD;EACA,KAAK,IAAIM,CAAC,GAAG,CAAC,EAAEa,SAAS,GAAGJ,KAAK,CAACR,MAAM,EAAED,CAAC,GAAGa,SAAS,EAAE,EAAEb,CAAC,EAAE;IAC1DT,mBAAmB,CAACC,IAAI,CAACiB,KAAK,CAACT,CAAC,CAAC,CAAC,EAAEP,KAAK,EAAEC,WAAW,CAAC;EAC3D;EACA,OAAOA,WAAW;AACtB;AACA;AACA;AACA;AACA,SAASoB,eAAeA,CAACtB,IAAI,EAAEuB,OAAO,EAAEtB,KAAK,EAAE;EAC3C,IAAIc,UAAU,GAAGhB,mBAAmB,CAACC,IAAI,EAAEC,KAAK,CAAC;EACjD;EACA,IAAIuB,IAAI,GAAG,CAAC;EACZ,IAAIC,KAAK,GAAGV,UAAU,IAAIA,UAAU,CAACN,MAAM;EAC3C,IAAIiB,aAAa;EACjB,IAAIC,aAAa;EACjB,OAAO,OAAOF,KAAK,KAAK,QAAQ,IAAID,IAAI,GAAGC,KAAK,EAAE;IAC9C,IAAIG,MAAM,GAAIJ,IAAI,GAAGC,KAAK,IAAK,CAAC;IAChC,IAAIf,KAAK,GAAGK,UAAU,CAACa,MAAM,CAAC;IAC9B,IAAIhC,MAAM,CAACe,UAAU,CAACD,KAAK,CAACH,GAAG,CAACM,KAAK,EAAEU,OAAO,CAAChB,GAAG,CAACM,KAAK,CAAC,IAAI,CAAC,IAC1DjB,MAAM,CAACe,UAAU,CAACY,OAAO,CAAChB,GAAG,CAACK,GAAG,EAAEF,KAAK,CAACH,GAAG,CAACK,GAAG,CAAC,IAAI,CAAC,EAAE;MACxD;MACAU,eAAe,CAAEC,OAAO,CAACM,aAAa,GAAGnB,KAAK,EAAGa,OAAO,EAAEtB,KAAK,CAAC;MAChE,OAAO,CAAC;IACZ;;IACA,IAAIL,MAAM,CAACe,UAAU,CAACD,KAAK,CAACH,GAAG,CAACK,GAAG,EAAEW,OAAO,CAAChB,GAAG,CAACM,KAAK,CAAC,IAAI,CAAC,EAAE;MAC1D;MACA;MACA;MACA;MACAa,aAAa,GAAGhB,KAAK;MACrBc,IAAI,GAAGI,MAAM,GAAG,CAAC;MACjB;IACJ;IACA,IAAIhC,MAAM,CAACe,UAAU,CAACY,OAAO,CAAChB,GAAG,CAACK,GAAG,EAAEF,KAAK,CAACH,GAAG,CAACM,KAAK,CAAC,IAAI,CAAC,EAAE;MAC1D;MACA;MACA;MACA;MACAc,aAAa,GAAGjB,KAAK;MACrBe,KAAK,GAAGG,MAAM;MACd;IACJ;IACA,MAAM,IAAIE,KAAK,CAAC,8CAA8C,CAAC;EACnE;EACA,IAAIJ,aAAa,EAAE;IACfH,OAAO,CAACG,aAAa,GAAGA,aAAa;EACzC;EACA,IAAIC,aAAa,EAAE;IACfJ,OAAO,CAACI,aAAa,GAAGA,aAAa;EACzC;AACJ;AACA,SAAS9C,MAAMA,CAACkD,QAAQ,EAAEC,GAAG,EAAE/B,KAAK,EAAE;EAClC,IAAI,CAACX,OAAO,CAACe,KAAK,CAAC0B,QAAQ,CAAC,EAAE;IAC1B;EACJ;EACA,IAAIE,WAAW,GAAG,EAAE;EACpBF,QAAQ,CAACG,OAAO,CAAC,UAAUX,OAAO,EAAE;IAChCA,OAAO,CAAChB,GAAG,CAACN,KAAK,GAAGA,KAAK;IACzBqB,eAAe,CAACU,GAAG,EAAET,OAAO,EAAEtB,KAAK,CAAC;IACpC,IAAIkC,EAAE,GAAGZ,OAAO,CAACG,aAAa;IAC9B,IAAIU,EAAE,GAAGb,OAAO,CAACM,aAAa;IAC9B,IAAIQ,EAAE,GAAGd,OAAO,CAACI,aAAa;IAC9B,IAAIQ,EAAE,IAAIE,EAAE,EAAE;MACV,IAAIC,QAAQ,GAAGL,WAAW,CAACxB,MAAM;MACjC,IAAI6B,QAAQ,GAAG,CAAC,EAAE;QACd,IAAIC,OAAO,GAAGN,WAAW,CAACK,QAAQ,GAAG,CAAC,CAAC;QACvCtD,QAAQ,CAACwD,OAAO,CAACC,WAAW,CAACF,OAAO,CAACb,aAAa,KAAKH,OAAO,CAACG,aAAa,EAAEa,OAAO,CAACZ,aAAa,KAAKJ,OAAO,CAACI,aAAa,CAAC;QAC9H,IAAIY,OAAO,CAACZ,aAAa,KAAKJ,OAAO,CAACI,aAAa,EAAE;UACjDe,SAAS,CAACT,WAAW,EAAEhC,KAAK,CAAC;QACjC;MACJ;MACAgC,WAAW,CAACU,IAAI,CAACpB,OAAO,CAAC;IAC7B,CAAC,MACI,IAAIY,EAAE,EAAE;MACT;MACAO,SAAS,CAACT,WAAW,EAAEhC,KAAK,CAAC;MAC7B2C,kBAAkB,CAACT,EAAE,EAAEZ,OAAO,CAAC;IACnC,CAAC,MACI,IAAIc,EAAE,EAAE;MACT;MACAK,SAAS,CAACT,WAAW,EAAEhC,KAAK,CAAC;MAC7B4C,iBAAiB,CAACR,EAAE,EAAEd,OAAO,CAAC;IAClC,CAAC,MACI,IAAIa,EAAE,EAAE;MACT;MACA;MACAM,SAAS,CAACT,WAAW,EAAEhC,KAAK,CAAC;MAC7B6C,kBAAkB,CAACV,EAAE,EAAEb,OAAO,CAAC;IACnC,CAAC,MACI;MACD,MAAM,IAAIO,KAAK,CAAC,+BAA+B,CAAC;IACpD;EACJ,CAAC,CAAC;EACFY,SAAS,CAACT,WAAW,EAAEhC,KAAK,CAAC;EAC7B8B,QAAQ,CAACG,OAAO,CAAC,UAAUX,OAAO,EAAE;IAChC;IACA;IACA;IACA,OAAOA,OAAO,CAACG,aAAa;IAC5B,OAAOH,OAAO,CAACM,aAAa;IAC5B,OAAON,OAAO,CAACI,aAAa;EAChC,CAAC,CAAC;AACN;AACAjD,OAAO,CAACG,MAAM,GAAGA,MAAM;AACvB,SAAS6D,SAASA,CAACT,WAAW,EAAEhC,KAAK,EAAE;EACnC,IAAIqC,QAAQ,GAAGL,WAAW,CAACxB,MAAM;EACjC,IAAI6B,QAAQ,KAAK,CAAC,EAAE;IAChB;EACJ;EACA,IAAIH,EAAE,GAAGF,WAAW,CAAC,CAAC,CAAC,CAACP,aAAa;EACrC,IAAIW,EAAE,GAAGJ,WAAW,CAAC,CAAC,CAAC,CAACN,aAAa;EACrC,IAAIoB,SAAS,GAAGV,EAAE,CAAC9B,GAAG,CAACM,KAAK;EAC5B;EACA;EACA;EACA;EACA,IAAImC,0BAA0B,GAAGV,QAAQ;EACzC,IAAIf,OAAO;EACX,OAAOyB,0BAA0B,GAAG,CAAC,EAAE,EAAEA,0BAA0B,EAAE;IACjEzB,OAAO,GAAGU,WAAW,CAACe,0BAA0B,GAAG,CAAC,CAAC;IACrDhE,QAAQ,CAACwD,OAAO,CAACC,WAAW,CAAClB,OAAO,CAACG,aAAa,EAAES,EAAE,CAAC;IACvDnD,QAAQ,CAACwD,OAAO,CAACC,WAAW,CAAClB,OAAO,CAACI,aAAa,EAAEU,EAAE,CAAC;IACvD,IAAIY,GAAG,GAAGhD,KAAK,CAACiD,WAAW,CAAC3B,OAAO,CAAChB,GAAG,CAACK,GAAG,EAAEmC,SAAS,CAAC;IACvD,IAAI,IAAI,CAACI,IAAI,CAACF,GAAG,CAAC,EAAE;MAChB;MACA;IACJ;IACAF,SAAS,GAAGxB,OAAO,CAAChB,GAAG,CAACM,KAAK;EACjC;EACA,OAAOmC,0BAA0B,IAAIV,QAAQ,KACxCf,OAAO,GAAGU,WAAW,CAACe,0BAA0B,CAAC,CAAC;EACnD;EACA;EACCzB,OAAO,CAAC6B,IAAI,KAAK,MAAM,IAAI7B,OAAO,CAAC6B,IAAI,KAAK,aAAa,CAAC,IAC3D7B,OAAO,CAAChB,GAAG,CAACM,KAAK,CAACwC,MAAM,GAAGhB,EAAE,CAAC9B,GAAG,CAACM,KAAK,CAACwC,MAAM,EAAE;IAChD,EAAEL,0BAA0B;EAChC;EACAf,WAAW,CAACC,OAAO,CAAC,UAAUX,OAAO,EAAEf,CAAC,EAAE;IACtC,IAAIA,CAAC,GAAGwC,0BAA0B,EAAE;MAChCJ,kBAAkB,CAACT,EAAE,EAAEZ,OAAO,CAAC;IACnC,CAAC,MACI;MACDsB,iBAAiB,CAACR,EAAE,EAAEd,OAAO,CAAC;IAClC;EACJ,CAAC,CAAC;EACFU,WAAW,CAACxB,MAAM,GAAG,CAAC;AAC1B;AACA,SAAS6C,gBAAgBA,CAACtD,IAAI,EAAEuB,OAAO,EAAE;EACrC,IAAIQ,QAAQ,GAAG/B,IAAI,CAAC+B,QAAQ,KAAK/B,IAAI,CAAC+B,QAAQ,GAAG,EAAE,CAAC;EACpDA,QAAQ,CAACY,IAAI,CAACpB,OAAO,CAAC;AAC1B;AACA,SAASsB,iBAAiBA,CAAC7C,IAAI,EAAEuB,OAAO,EAAE;EACtCA,OAAO,CAACgC,OAAO,GAAG,IAAI;EACtBhC,OAAO,CAACiC,QAAQ,GAAG,KAAK;EACxBF,gBAAgB,CAACtD,IAAI,EAAEuB,OAAO,CAAC;AACnC;AACA,SAASuB,kBAAkBA,CAAC9C,IAAI,EAAEuB,OAAO,EAAE;EACvCA,OAAO,CAACgC,OAAO,GAAG,KAAK;EACvBhC,OAAO,CAACiC,QAAQ,GAAG,KAAK;EACxBF,gBAAgB,CAACtD,IAAI,EAAEuB,OAAO,CAAC;AACnC;AACA,SAASqB,kBAAkBA,CAAC5C,IAAI,EAAEuB,OAAO,EAAE;EACvCA,OAAO,CAACgC,OAAO,GAAG,KAAK;EACvBhC,OAAO,CAACiC,QAAQ,GAAG,IAAI;EACvBF,gBAAgB,CAACtD,IAAI,EAAEuB,OAAO,CAAC;AACnC;AACA,SAASkC,mBAAmBA,CAACC,WAAW,EAAEC,KAAK,EAAE;EAC7C,IAAIpC,OAAO,GAAGmC,WAAW,CAACE,QAAQ,CAAC,CAAC;EACpCxE,CAAC,CAACyE,OAAO,CAACC,MAAM,CAACvC,OAAO,CAAC;EACzB,IAAIhB,GAAG,GAAGgB,OAAO,CAAChB,GAAG;EACrB,IAAIN,KAAK,GAAGM,GAAG,IAAIA,GAAG,CAACN,KAAK;EAC5B,IAAI8D,KAAK,GAAG,CAACJ,KAAK,CAACD,WAAW,CAAC,CAAC;EAChC,IAAInC,OAAO,CAACiC,QAAQ,EAAE;IAClB;IACA;IACAO,KAAK,CAACpB,IAAI,CAAC,IAAI,CAAC;EACpB,CAAC,MACI,IAAI1C,KAAK,YAAYN,OAAO,CAACqE,KAAK,EAAE;IACrC,IAAIC,aAAa,GAAGhE,KAAK,CAACiE,KAAK,CAAC3D,GAAG,CAACK,GAAG,EAAEX,KAAK,CAACkE,UAAU,CAAC5D,GAAG,CAACK,GAAG,CAAC,IAAIX,KAAK,CAACmE,OAAO,CAAC,CAAC,CAAC;IACtF,IAAIH,aAAa,CAACxD,MAAM,KAAK,CAAC,EAAE;MAC5B;MACA;MACAsD,KAAK,CAACpB,IAAI,CAACsB,aAAa,CAAC;IAC7B,CAAC,MACI;MACD;MACA;MACAF,KAAK,CAACpB,IAAI,CAAC,IAAI0B,KAAK,CAACJ,aAAa,CAACxD,MAAM,CAAC,CAAC6D,IAAI,CAAC,IAAI,CAAC,CAAC;IAC1D;EACJ,CAAC,MACI;IACDP,KAAK,CAACpB,IAAI,CAAC,IAAI,CAAC;EACpB;EACA,OAAOhD,OAAO,CAAC4E,MAAM,CAACR,KAAK,CAAC;AAChC;AACA,SAASS,oBAAoBA,CAACd,WAAW,EAAEC,KAAK,EAAE;EAC9C,IAAIpC,OAAO,GAAGmC,WAAW,CAACE,QAAQ,CAACF,WAAW,CAAC;EAC/CtE,CAAC,CAACyE,OAAO,CAACC,MAAM,CAACvC,OAAO,CAAC;EACzB,IAAIhB,GAAG,GAAGgB,OAAO,CAAChB,GAAG;EACrB,IAAIN,KAAK,GAAGM,GAAG,IAAIA,GAAG,CAACN,KAAK;EAC5B,IAAI8D,KAAK,GAAG,EAAE;EACd,IAAI9D,KAAK,YAAYN,OAAO,CAACqE,KAAK,EAAE;IAChC,IAAIS,OAAO,GAAGxE,KAAK,CAACkE,UAAU,CAAC5D,GAAG,CAACM,KAAK,EAAE,IAAI,CAAC,IAAIZ,KAAK,CAACyE,QAAQ,CAAC,CAAC;IACnE,IAAIC,YAAY,GAAG1E,KAAK,CAACiE,KAAK,CAACO,OAAO,EAAElE,GAAG,CAACM,KAAK,CAAC;IAClD,IAAI8D,YAAY,CAAClE,MAAM,KAAK,CAAC,EAAE;MAC3B;MACA;MACAsD,KAAK,CAACpB,IAAI,CAACgC,YAAY,CAAC;IAC5B,CAAC,MACI;MACD;MACA;MACAZ,KAAK,CAACpB,IAAI,CAAC,IAAI0B,KAAK,CAACM,YAAY,CAAClE,MAAM,CAAC,CAAC6D,IAAI,CAAC,IAAI,CAAC,CAAC;IACzD;EACJ;EACAP,KAAK,CAACpB,IAAI,CAACgB,KAAK,CAACD,WAAW,CAAC,CAAC;EAC9B,OAAO/D,OAAO,CAAC4E,MAAM,CAACR,KAAK,CAAC;AAChC;AACA,SAASnF,aAAaA,CAACgG,IAAI,EAAEjB,KAAK,EAAE;EAChC,IAAIhF,KAAK,GAAGiG,IAAI,CAAChB,QAAQ,CAAC,CAAC;EAC3B,IAAIiB,UAAU,GAAGlB,KAAK,CAACiB,IAAI,CAAC;EAC5B,IAAI7C,QAAQ,GAAG3C,CAAC,CAACgB,IAAI,CAACC,KAAK,CAAC1B,KAAK,CAAC,IAAIO,KAAK,CAAC4F,aAAa,CAACnG,KAAK,EAAE,UAAU,CAAC;EAC5E,IAAI,CAACoD,QAAQ,IAAIA,QAAQ,CAACtB,MAAM,KAAK,CAAC,EAAE;IACpC,OAAOoE,UAAU;EACrB;EACA,IAAIE,YAAY,GAAG,EAAE;EACrB,IAAIC,aAAa,GAAG,CAACH,UAAU,CAAC;EAChCD,IAAI,CAACK,IAAI,CAAC,UAAUvB,WAAW,EAAE;IAC7B,IAAInC,OAAO,GAAGmC,WAAW,CAACE,QAAQ,CAAC,CAAC;IACpC,IAAIL,OAAO,GAAGrE,KAAK,CAAC4F,aAAa,CAACvD,OAAO,EAAE,SAAS,CAAC;IACrD,IAAIiC,QAAQ,GAAGtE,KAAK,CAAC4F,aAAa,CAACvD,OAAO,EAAE,UAAU,CAAC;IACvD,IAAIgC,OAAO,IACNC,QAAQ,IACL,EAAEpE,CAAC,CAAC8F,SAAS,CAAC7E,KAAK,CAAC1B,KAAK,CAAC,IACtB4C,OAAO,CAAC6B,IAAI,KAAK,OAAO,IACxB7B,OAAO,CAAC6B,IAAI,KAAK,cAAc,CAAE,EAAE;MAC3C2B,YAAY,CAACpC,IAAI,CAACc,mBAAmB,CAACC,WAAW,EAAEC,KAAK,CAAC,CAAC;IAC9D,CAAC,MACI,IAAIH,QAAQ,EAAE;MACfwB,aAAa,CAACrC,IAAI,CAAC6B,oBAAoB,CAACd,WAAW,EAAEC,KAAK,CAAC,CAAC;IAChE;EACJ,CAAC,EAAE,UAAU,CAAC;EACdoB,YAAY,CAACpC,IAAI,CAACwC,KAAK,CAACJ,YAAY,EAAEC,aAAa,CAAC;EACpD,OAAOrF,OAAO,CAAC4E,MAAM,CAACQ,YAAY,CAAC;AACvC;AACArG,OAAO,CAACE,aAAa,GAAGA,aAAa"},"metadata":{},"sourceType":"script"}