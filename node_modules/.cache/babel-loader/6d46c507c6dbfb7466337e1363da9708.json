{"ast":null,"code":"'use strict';\n\nvar repeat = require('repeat-string');\nmodule.exports = markdownTable;\nvar trailingWhitespace = / +$/;\n\n// Characters.\nvar space = ' ';\nvar lineFeed = '\\n';\nvar dash = '-';\nvar colon = ':';\nvar verticalBar = '|';\nvar x = 0;\nvar C = 67;\nvar L = 76;\nvar R = 82;\nvar c = 99;\nvar l = 108;\nvar r = 114;\n\n// Create a table from a matrix of strings.\nfunction markdownTable(table, options) {\n  var settings = options || {};\n  var padding = settings.padding !== false;\n  var start = settings.delimiterStart !== false;\n  var end = settings.delimiterEnd !== false;\n  var align = (settings.align || []).concat();\n  var alignDelimiters = settings.alignDelimiters !== false;\n  var alignments = [];\n  var stringLength = settings.stringLength || defaultStringLength;\n  var rowIndex = -1;\n  var rowLength = table.length;\n  var cellMatrix = [];\n  var sizeMatrix = [];\n  var row = [];\n  var sizes = [];\n  var longestCellByColumn = [];\n  var mostCellsPerRow = 0;\n  var cells;\n  var columnIndex;\n  var columnLength;\n  var largest;\n  var size;\n  var cell;\n  var lines;\n  var line;\n  var before;\n  var after;\n  var code;\n\n  // This is a superfluous loop if we don’t align delimiters, but otherwise we’d\n  // do superfluous work when aligning, so optimize for aligning.\n  while (++rowIndex < rowLength) {\n    cells = table[rowIndex];\n    columnIndex = -1;\n    columnLength = cells.length;\n    row = [];\n    sizes = [];\n    if (columnLength > mostCellsPerRow) {\n      mostCellsPerRow = columnLength;\n    }\n    while (++columnIndex < columnLength) {\n      cell = serialize(cells[columnIndex]);\n      if (alignDelimiters === true) {\n        size = stringLength(cell);\n        sizes[columnIndex] = size;\n        largest = longestCellByColumn[columnIndex];\n        if (largest === undefined || size > largest) {\n          longestCellByColumn[columnIndex] = size;\n        }\n      }\n      row.push(cell);\n    }\n    cellMatrix[rowIndex] = row;\n    sizeMatrix[rowIndex] = sizes;\n  }\n\n  // Figure out which alignments to use.\n  columnIndex = -1;\n  columnLength = mostCellsPerRow;\n  if (typeof align === 'object' && 'length' in align) {\n    while (++columnIndex < columnLength) {\n      alignments[columnIndex] = toAlignment(align[columnIndex]);\n    }\n  } else {\n    code = toAlignment(align);\n    while (++columnIndex < columnLength) {\n      alignments[columnIndex] = code;\n    }\n  }\n\n  // Inject the alignment row.\n  columnIndex = -1;\n  columnLength = mostCellsPerRow;\n  row = [];\n  sizes = [];\n  while (++columnIndex < columnLength) {\n    code = alignments[columnIndex];\n    before = '';\n    after = '';\n    if (code === l) {\n      before = colon;\n    } else if (code === r) {\n      after = colon;\n    } else if (code === c) {\n      before = colon;\n      after = colon;\n    }\n\n    // There *must* be at least one hyphen-minus in each alignment cell.\n    size = alignDelimiters ? Math.max(1, longestCellByColumn[columnIndex] - before.length - after.length) : 1;\n    cell = before + repeat(dash, size) + after;\n    if (alignDelimiters === true) {\n      size = before.length + size + after.length;\n      if (size > longestCellByColumn[columnIndex]) {\n        longestCellByColumn[columnIndex] = size;\n      }\n      sizes[columnIndex] = size;\n    }\n    row[columnIndex] = cell;\n  }\n\n  // Inject the alignment row.\n  cellMatrix.splice(1, 0, row);\n  sizeMatrix.splice(1, 0, sizes);\n  rowIndex = -1;\n  rowLength = cellMatrix.length;\n  lines = [];\n  while (++rowIndex < rowLength) {\n    row = cellMatrix[rowIndex];\n    sizes = sizeMatrix[rowIndex];\n    columnIndex = -1;\n    columnLength = mostCellsPerRow;\n    line = [];\n    while (++columnIndex < columnLength) {\n      cell = row[columnIndex] || '';\n      before = '';\n      after = '';\n      if (alignDelimiters === true) {\n        size = longestCellByColumn[columnIndex] - (sizes[columnIndex] || 0);\n        code = alignments[columnIndex];\n        if (code === r) {\n          before = repeat(space, size);\n        } else if (code === c) {\n          if (size % 2 === 0) {\n            before = repeat(space, size / 2);\n            after = before;\n          } else {\n            before = repeat(space, size / 2 + 0.5);\n            after = repeat(space, size / 2 - 0.5);\n          }\n        } else {\n          after = repeat(space, size);\n        }\n      }\n      if (start === true && columnIndex === 0) {\n        line.push(verticalBar);\n      }\n      if (padding === true &&\n      // Don’t add the opening space if we’re not aligning and the cell is\n      // empty: there will be a closing space.\n      !(alignDelimiters === false && cell === '') && (start === true || columnIndex !== 0)) {\n        line.push(space);\n      }\n      if (alignDelimiters === true) {\n        line.push(before);\n      }\n      line.push(cell);\n      if (alignDelimiters === true) {\n        line.push(after);\n      }\n      if (padding === true) {\n        line.push(space);\n      }\n      if (end === true || columnIndex !== columnLength - 1) {\n        line.push(verticalBar);\n      }\n    }\n    line = line.join('');\n    if (end === false) {\n      line = line.replace(trailingWhitespace, '');\n    }\n    lines.push(line);\n  }\n  return lines.join(lineFeed);\n}\nfunction serialize(value) {\n  return value === null || value === undefined ? '' : String(value);\n}\nfunction defaultStringLength(value) {\n  return value.length;\n}\nfunction toAlignment(value) {\n  var code = typeof value === 'string' ? value.charCodeAt(0) : x;\n  return code === L || code === l ? l : code === R || code === r ? r : code === C || code === c ? c : x;\n}","map":{"version":3,"names":["repeat","require","module","exports","markdownTable","trailingWhitespace","space","lineFeed","dash","colon","verticalBar","x","C","L","R","c","l","r","table","options","settings","padding","start","delimiterStart","end","delimiterEnd","align","concat","alignDelimiters","alignments","stringLength","defaultStringLength","rowIndex","rowLength","length","cellMatrix","sizeMatrix","row","sizes","longestCellByColumn","mostCellsPerRow","cells","columnIndex","columnLength","largest","size","cell","lines","line","before","after","code","serialize","undefined","push","toAlignment","Math","max","splice","join","replace","value","String","charCodeAt"],"sources":["C:/Users/Acer/Desktop/dev__book/dev__book/node_modules/markdown-table/index.js"],"sourcesContent":["'use strict'\n\nvar repeat = require('repeat-string')\n\nmodule.exports = markdownTable\n\nvar trailingWhitespace = / +$/\n\n// Characters.\nvar space = ' '\nvar lineFeed = '\\n'\nvar dash = '-'\nvar colon = ':'\nvar verticalBar = '|'\n\nvar x = 0\nvar C = 67\nvar L = 76\nvar R = 82\nvar c = 99\nvar l = 108\nvar r = 114\n\n// Create a table from a matrix of strings.\nfunction markdownTable(table, options) {\n  var settings = options || {}\n  var padding = settings.padding !== false\n  var start = settings.delimiterStart !== false\n  var end = settings.delimiterEnd !== false\n  var align = (settings.align || []).concat()\n  var alignDelimiters = settings.alignDelimiters !== false\n  var alignments = []\n  var stringLength = settings.stringLength || defaultStringLength\n  var rowIndex = -1\n  var rowLength = table.length\n  var cellMatrix = []\n  var sizeMatrix = []\n  var row = []\n  var sizes = []\n  var longestCellByColumn = []\n  var mostCellsPerRow = 0\n  var cells\n  var columnIndex\n  var columnLength\n  var largest\n  var size\n  var cell\n  var lines\n  var line\n  var before\n  var after\n  var code\n\n  // This is a superfluous loop if we don’t align delimiters, but otherwise we’d\n  // do superfluous work when aligning, so optimize for aligning.\n  while (++rowIndex < rowLength) {\n    cells = table[rowIndex]\n    columnIndex = -1\n    columnLength = cells.length\n    row = []\n    sizes = []\n\n    if (columnLength > mostCellsPerRow) {\n      mostCellsPerRow = columnLength\n    }\n\n    while (++columnIndex < columnLength) {\n      cell = serialize(cells[columnIndex])\n\n      if (alignDelimiters === true) {\n        size = stringLength(cell)\n        sizes[columnIndex] = size\n\n        largest = longestCellByColumn[columnIndex]\n\n        if (largest === undefined || size > largest) {\n          longestCellByColumn[columnIndex] = size\n        }\n      }\n\n      row.push(cell)\n    }\n\n    cellMatrix[rowIndex] = row\n    sizeMatrix[rowIndex] = sizes\n  }\n\n  // Figure out which alignments to use.\n  columnIndex = -1\n  columnLength = mostCellsPerRow\n\n  if (typeof align === 'object' && 'length' in align) {\n    while (++columnIndex < columnLength) {\n      alignments[columnIndex] = toAlignment(align[columnIndex])\n    }\n  } else {\n    code = toAlignment(align)\n\n    while (++columnIndex < columnLength) {\n      alignments[columnIndex] = code\n    }\n  }\n\n  // Inject the alignment row.\n  columnIndex = -1\n  columnLength = mostCellsPerRow\n  row = []\n  sizes = []\n\n  while (++columnIndex < columnLength) {\n    code = alignments[columnIndex]\n    before = ''\n    after = ''\n\n    if (code === l) {\n      before = colon\n    } else if (code === r) {\n      after = colon\n    } else if (code === c) {\n      before = colon\n      after = colon\n    }\n\n    // There *must* be at least one hyphen-minus in each alignment cell.\n    size = alignDelimiters\n      ? Math.max(\n          1,\n          longestCellByColumn[columnIndex] - before.length - after.length\n        )\n      : 1\n\n    cell = before + repeat(dash, size) + after\n\n    if (alignDelimiters === true) {\n      size = before.length + size + after.length\n\n      if (size > longestCellByColumn[columnIndex]) {\n        longestCellByColumn[columnIndex] = size\n      }\n\n      sizes[columnIndex] = size\n    }\n\n    row[columnIndex] = cell\n  }\n\n  // Inject the alignment row.\n  cellMatrix.splice(1, 0, row)\n  sizeMatrix.splice(1, 0, sizes)\n\n  rowIndex = -1\n  rowLength = cellMatrix.length\n  lines = []\n\n  while (++rowIndex < rowLength) {\n    row = cellMatrix[rowIndex]\n    sizes = sizeMatrix[rowIndex]\n    columnIndex = -1\n    columnLength = mostCellsPerRow\n    line = []\n\n    while (++columnIndex < columnLength) {\n      cell = row[columnIndex] || ''\n      before = ''\n      after = ''\n\n      if (alignDelimiters === true) {\n        size = longestCellByColumn[columnIndex] - (sizes[columnIndex] || 0)\n        code = alignments[columnIndex]\n\n        if (code === r) {\n          before = repeat(space, size)\n        } else if (code === c) {\n          if (size % 2 === 0) {\n            before = repeat(space, size / 2)\n            after = before\n          } else {\n            before = repeat(space, size / 2 + 0.5)\n            after = repeat(space, size / 2 - 0.5)\n          }\n        } else {\n          after = repeat(space, size)\n        }\n      }\n\n      if (start === true && columnIndex === 0) {\n        line.push(verticalBar)\n      }\n\n      if (\n        padding === true &&\n        // Don’t add the opening space if we’re not aligning and the cell is\n        // empty: there will be a closing space.\n        !(alignDelimiters === false && cell === '') &&\n        (start === true || columnIndex !== 0)\n      ) {\n        line.push(space)\n      }\n\n      if (alignDelimiters === true) {\n        line.push(before)\n      }\n\n      line.push(cell)\n\n      if (alignDelimiters === true) {\n        line.push(after)\n      }\n\n      if (padding === true) {\n        line.push(space)\n      }\n\n      if (end === true || columnIndex !== columnLength - 1) {\n        line.push(verticalBar)\n      }\n    }\n\n    line = line.join('')\n\n    if (end === false) {\n      line = line.replace(trailingWhitespace, '')\n    }\n\n    lines.push(line)\n  }\n\n  return lines.join(lineFeed)\n}\n\nfunction serialize(value) {\n  return value === null || value === undefined ? '' : String(value)\n}\n\nfunction defaultStringLength(value) {\n  return value.length\n}\n\nfunction toAlignment(value) {\n  var code = typeof value === 'string' ? value.charCodeAt(0) : x\n\n  return code === L || code === l\n    ? l\n    : code === R || code === r\n    ? r\n    : code === C || code === c\n    ? c\n    : x\n}\n"],"mappings":"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"},"metadata":{},"sourceType":"script"}