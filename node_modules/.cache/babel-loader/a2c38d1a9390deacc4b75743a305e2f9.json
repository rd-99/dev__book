{"ast":null,"code":"/**\n * Copyright (c) Facebook, Inc. and its affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n */\n\n'use strict';\n\nconst Collection = require('../Collection');\nconst NodeCollection = require('./Node');\nconst once = require('../utils/once');\nconst recast = require('recast');\nconst astNodesAreEquivalent = recast.types.astNodesAreEquivalent;\nconst b = recast.types.builders;\nvar types = recast.types.namedTypes;\nconst VariableDeclarator = recast.types.namedTypes.VariableDeclarator;\n\n/**\n* @mixin\n*/\nconst globalMethods = {\n  /**\n   * Finds all variable declarators, optionally filtered by name.\n   *\n   * @param {string} name\n   * @return {Collection}\n   */\n  findVariableDeclarators: function (name) {\n    const filter = name ? {\n      id: {\n        name: name\n      }\n    } : null;\n    return this.find(VariableDeclarator, filter);\n  }\n};\nconst filterMethods = {\n  /**\n   * Returns a function that returns true if the provided path is a variable\n   * declarator and requires one of the specified module names.\n   *\n   * @param {string|Array} names A module name or an array of module names\n   * @return {Function}\n   */\n  requiresModule: function (names) {\n    if (names && !Array.isArray(names)) {\n      names = [names];\n    }\n    const requireIdentifier = b.identifier('require');\n    return function (path) {\n      const node = path.value;\n      if (!VariableDeclarator.check(node) || !types.CallExpression.check(node.init) || !astNodesAreEquivalent(node.init.callee, requireIdentifier)) {\n        return false;\n      }\n      return !names || names.some(n => astNodesAreEquivalent(node.init.arguments[0], b.literal(n)));\n    };\n  }\n};\n\n/**\n* @mixin\n*/\nconst transformMethods = {\n  /**\n   * Renames a variable and all its occurrences.\n   *\n   * @param {string} newName\n   * @return {Collection}\n   */\n  renameTo: function (newName) {\n    // TODO: Include JSXElements\n    return this.forEach(function (path) {\n      const node = path.value;\n      const oldName = node.id.name;\n      const rootScope = path.scope;\n      const rootPath = rootScope.path;\n      Collection.fromPaths([rootPath]).find(types.Identifier, {\n        name: oldName\n      }).filter(function (path) {\n        // ignore non-variables\n        const parent = path.parent.node;\n        if (types.MemberExpression.check(parent) && parent.property === path.node && !parent.computed) {\n          // obj.oldName\n          return false;\n        }\n        if (types.Property.check(parent) && parent.key === path.node && !parent.computed) {\n          // { oldName: 3 }\n          return false;\n        }\n        if (types.MethodDefinition.check(parent) && parent.key === path.node && !parent.computed) {\n          // class A { oldName() {} }\n          return false;\n        }\n        if (types.ClassProperty.check(parent) && parent.key === path.node && !parent.computed) {\n          // class A { oldName = 3 }\n          return false;\n        }\n        if (types.JSXAttribute.check(parent) && parent.name === path.node && !parent.computed) {\n          // <Foo oldName={oldName} />\n          return false;\n        }\n        return true;\n      }).forEach(function (path) {\n        let scope = path.scope;\n        while (scope && scope !== rootScope) {\n          if (scope.declares(oldName)) {\n            return;\n          }\n          scope = scope.parent;\n        }\n        if (scope) {\n          // identifier must refer to declared variable\n\n          // It may look like we filtered out properties,\n          // but the filter only ignored property \"keys\", not \"value\"s\n          // In shorthand properties, \"key\" and \"value\" both have an\n          // Identifier with the same structure.\n          const parent = path.parent.node;\n          if (types.Property.check(parent) && parent.shorthand && !parent.method) {\n            path.parent.get('shorthand').replace(false);\n          }\n          path.get('name').replace(newName);\n        }\n      });\n    });\n  }\n};\nfunction register() {\n  NodeCollection.register();\n  Collection.registerMethods(globalMethods);\n  Collection.registerMethods(transformMethods, VariableDeclarator);\n}\nexports.register = once(register);\nexports.filters = filterMethods;","map":{"version":3,"names":["Collection","require","NodeCollection","once","recast","astNodesAreEquivalent","types","b","builders","namedTypes","VariableDeclarator","globalMethods","findVariableDeclarators","name","filter","id","find","filterMethods","requiresModule","names","Array","isArray","requireIdentifier","identifier","path","node","value","check","CallExpression","init","callee","some","n","arguments","literal","transformMethods","renameTo","newName","forEach","oldName","rootScope","scope","rootPath","fromPaths","Identifier","parent","MemberExpression","property","computed","Property","key","MethodDefinition","ClassProperty","JSXAttribute","declares","shorthand","method","get","replace","register","registerMethods","exports","filters"],"sources":["C:/Users/Acer/Desktop/dev__book/dev__book/node_modules/jscodeshift/src/collections/VariableDeclarator.js"],"sourcesContent":["\n/**\n * Copyright (c) Facebook, Inc. and its affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n */\n\n'use strict';\n\nconst Collection = require('../Collection');\nconst NodeCollection = require('./Node');\nconst once = require('../utils/once');\nconst recast = require('recast');\n\nconst astNodesAreEquivalent = recast.types.astNodesAreEquivalent;\nconst b = recast.types.builders;\nvar types = recast.types.namedTypes;\n\nconst VariableDeclarator = recast.types.namedTypes.VariableDeclarator;\n\n/**\n* @mixin\n*/\nconst globalMethods = {\n  /**\n   * Finds all variable declarators, optionally filtered by name.\n   *\n   * @param {string} name\n   * @return {Collection}\n   */\n  findVariableDeclarators: function(name) {\n    const filter = name ? {id: {name: name}} : null;\n    return this.find(VariableDeclarator, filter);\n  }\n};\n\nconst filterMethods = {\n  /**\n   * Returns a function that returns true if the provided path is a variable\n   * declarator and requires one of the specified module names.\n   *\n   * @param {string|Array} names A module name or an array of module names\n   * @return {Function}\n   */\n  requiresModule: function(names) {\n    if (names && !Array.isArray(names)) {\n      names = [names];\n    }\n    const requireIdentifier = b.identifier('require');\n    return function(path) {\n      const node = path.value;\n      if (!VariableDeclarator.check(node) ||\n          !types.CallExpression.check(node.init) ||\n          !astNodesAreEquivalent(node.init.callee, requireIdentifier)) {\n        return false;\n      }\n      return !names ||\n        names.some(\n          n => astNodesAreEquivalent(node.init.arguments[0], b.literal(n))\n        );\n    };\n  }\n};\n\n/**\n* @mixin\n*/\nconst transformMethods = {\n  /**\n   * Renames a variable and all its occurrences.\n   *\n   * @param {string} newName\n   * @return {Collection}\n   */\n  renameTo: function(newName) {\n    // TODO: Include JSXElements\n    return this.forEach(function(path) {\n      const node = path.value;\n      const oldName = node.id.name;\n      const rootScope = path.scope;\n      const rootPath = rootScope.path;\n      Collection.fromPaths([rootPath])\n        .find(types.Identifier, {name: oldName})\n        .filter(function(path) { // ignore non-variables\n          const parent = path.parent.node;\n\n          if (\n            types.MemberExpression.check(parent) &&\n            parent.property === path.node &&\n            !parent.computed\n          ) {\n            // obj.oldName\n            return false;\n          }\n\n          if (\n            types.Property.check(parent) &&\n            parent.key === path.node &&\n            !parent.computed\n          ) {\n            // { oldName: 3 }\n            return false;\n          }\n\n          if (\n            types.MethodDefinition.check(parent) &&\n            parent.key === path.node &&\n            !parent.computed\n          ) {\n            // class A { oldName() {} }\n            return false;\n          }\n\n          if (\n            types.ClassProperty.check(parent) &&\n            parent.key === path.node &&\n            !parent.computed\n          ) {\n            // class A { oldName = 3 }\n            return false;\n          }\n\n          if (\n            types.JSXAttribute.check(parent) &&\n            parent.name === path.node &&\n            !parent.computed\n          ) {\n            // <Foo oldName={oldName} />\n            return false;\n          }\n\n          return true;\n        })\n        .forEach(function(path) {\n          let scope = path.scope;\n          while (scope && scope !== rootScope) {\n            if (scope.declares(oldName)) {\n              return;\n            }\n            scope = scope.parent;\n          }\n          if (scope) { // identifier must refer to declared variable\n\n            // It may look like we filtered out properties,\n            // but the filter only ignored property \"keys\", not \"value\"s\n            // In shorthand properties, \"key\" and \"value\" both have an\n            // Identifier with the same structure.\n            const parent = path.parent.node;\n            if (\n              types.Property.check(parent) &&\n              parent.shorthand &&\n              !parent.method\n            )  {\n\n              path.parent.get('shorthand').replace(false);\n            }\n\n            path.get('name').replace(newName);\n          }\n        });\n    });\n  }\n};\n\n\nfunction register() {\n  NodeCollection.register();\n  Collection.registerMethods(globalMethods);\n  Collection.registerMethods(transformMethods, VariableDeclarator);\n}\n\nexports.register = once(register);\nexports.filters = filterMethods;\n"],"mappings":"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"},"metadata":{},"sourceType":"script"}