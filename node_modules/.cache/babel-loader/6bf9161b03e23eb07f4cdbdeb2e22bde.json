{"ast":null,"code":"(function (Prism) {\n  var expressionDef = /\\{[^\\r\\n\\[\\]{}]*\\}/;\n  var params = {\n    'quoted-string': {\n      pattern: /\"(?:[^\"\\\\]|\\\\.)*\"/,\n      alias: 'operator'\n    },\n    'command-param-id': {\n      pattern: /(\\s)\\w+:/,\n      lookbehind: true,\n      alias: 'property'\n    },\n    'command-param-value': [{\n      pattern: expressionDef,\n      alias: 'selector'\n    }, {\n      pattern: /([\\t ])\\S+/,\n      lookbehind: true,\n      greedy: true,\n      alias: 'operator'\n    }, {\n      pattern: /\\S(?:.*\\S)?/,\n      alias: 'operator'\n    }]\n  };\n  Prism.languages.naniscript = {\n    // ; ...\n    'comment': {\n      pattern: /^([\\t ]*);.*/m,\n      lookbehind: true\n    },\n    // > ...\n    // Define is a control line starting with '>' followed by a word, a space and a text.\n    'define': {\n      pattern: /^>.+/m,\n      alias: 'tag',\n      inside: {\n        'value': {\n          pattern: /(^>\\w+[\\t ]+)(?!\\s)[^{}\\r\\n]+/,\n          lookbehind: true,\n          alias: 'operator'\n        },\n        'key': {\n          pattern: /(^>)\\w+/,\n          lookbehind: true\n        }\n      }\n    },\n    // # ...\n    'label': {\n      pattern: /^([\\t ]*)#[\\t ]*\\w+[\\t ]*$/m,\n      lookbehind: true,\n      alias: 'regex'\n    },\n    'command': {\n      pattern: /^([\\t ]*)@\\w+(?=[\\t ]|$).*/m,\n      lookbehind: true,\n      alias: 'function',\n      inside: {\n        'command-name': /^@\\w+/,\n        'expression': {\n          pattern: expressionDef,\n          greedy: true,\n          alias: 'selector'\n        },\n        'command-params': {\n          pattern: /\\s*\\S[\\s\\S]*/,\n          inside: params\n        }\n      }\n    },\n    // Generic is any line that doesn't start with operators: ;>#@\n    'generic-text': {\n      pattern: /(^[ \\t]*)[^#@>;\\s].*/m,\n      lookbehind: true,\n      alias: 'punctuation',\n      inside: {\n        // \\{ ... \\} ... \\[ ... \\] ... \\\"\n        'escaped-char': /\\\\[{}\\[\\]\"]/,\n        'expression': {\n          pattern: expressionDef,\n          greedy: true,\n          alias: 'selector'\n        },\n        'inline-command': {\n          pattern: /\\[[\\t ]*\\w[^\\r\\n\\[\\]]*\\]/,\n          greedy: true,\n          alias: 'function',\n          inside: {\n            'command-params': {\n              pattern: /(^\\[[\\t ]*\\w+\\b)[\\s\\S]+(?=\\]$)/,\n              lookbehind: true,\n              inside: params\n            },\n            'command-param-name': {\n              pattern: /^(\\[[\\t ]*)\\w+/,\n              lookbehind: true,\n              alias: 'name'\n            },\n            'start-stop-char': /[\\[\\]]/\n          }\n        }\n      }\n    }\n  };\n  Prism.languages.nani = Prism.languages['naniscript'];\n\n  /** @typedef {InstanceType<import(\"./prism-core\")[\"Token\"]>} Token */\n\n  /**\n   * This hook is used to validate generic-text tokens for balanced brackets.\n   * Mark token as bad-line when contains not balanced brackets: {},[]\n   */\n  Prism.hooks.add('after-tokenize', function (env) {\n    /** @type {(Token | string)[]} */\n    var tokens = env.tokens;\n    tokens.forEach(function (token) {\n      if (typeof token !== 'string' && token.type === 'generic-text') {\n        var content = getTextContent(token);\n        if (!isBracketsBalanced(content)) {\n          token.type = 'bad-line';\n          token.content = content;\n        }\n      }\n    });\n  });\n\n  /**\n   * @param {string} input\n   * @returns {boolean}\n   */\n  function isBracketsBalanced(input) {\n    var brackets = '[]{}';\n    var stack = [];\n    for (var i = 0; i < input.length; i++) {\n      var bracket = input[i];\n      var bracketsIndex = brackets.indexOf(bracket);\n      if (bracketsIndex !== -1) {\n        if (bracketsIndex % 2 === 0) {\n          stack.push(bracketsIndex + 1);\n        } else if (stack.pop() !== bracketsIndex) {\n          return false;\n        }\n      }\n    }\n    return stack.length === 0;\n  }\n\n  /**\n   * @param {string | Token | (string | Token)[]} token\n   * @returns {string}\n   */\n  function getTextContent(token) {\n    if (typeof token === 'string') {\n      return token;\n    } else if (Array.isArray(token)) {\n      return token.map(getTextContent).join('');\n    } else {\n      return getTextContent(token.content);\n    }\n  }\n})(Prism);","map":{"version":3,"names":["Prism","expressionDef","params","pattern","alias","lookbehind","greedy","languages","naniscript","inside","nani","hooks","add","env","tokens","forEach","token","type","content","getTextContent","isBracketsBalanced","input","brackets","stack","i","length","bracket","bracketsIndex","indexOf","push","pop","Array","isArray","map","join"],"sources":["C:/Users/Acer/Desktop/dev__book/dev__book/node_modules/prismjs/components/prism-naniscript.js"],"sourcesContent":["(function (Prism) {\n\n\tvar expressionDef = /\\{[^\\r\\n\\[\\]{}]*\\}/;\n\n\tvar params = {\n\t\t'quoted-string': {\n\t\t\tpattern: /\"(?:[^\"\\\\]|\\\\.)*\"/,\n\t\t\talias: 'operator'\n\t\t},\n\t\t'command-param-id': {\n\t\t\tpattern: /(\\s)\\w+:/,\n\t\t\tlookbehind: true,\n\t\t\talias: 'property'\n\t\t},\n\t\t'command-param-value': [\n\t\t\t{\n\t\t\t\tpattern: expressionDef,\n\t\t\t\talias: 'selector',\n\t\t\t},\n\t\t\t{\n\t\t\t\tpattern: /([\\t ])\\S+/,\n\t\t\t\tlookbehind: true,\n\t\t\t\tgreedy: true,\n\t\t\t\talias: 'operator',\n\t\t\t},\n\t\t\t{\n\t\t\t\tpattern: /\\S(?:.*\\S)?/,\n\t\t\t\talias: 'operator',\n\t\t\t}\n\t\t]\n\t};\n\n\tPrism.languages.naniscript = {\n\t\t// ; ...\n\t\t'comment': {\n\t\t\tpattern: /^([\\t ]*);.*/m,\n\t\t\tlookbehind: true,\n\t\t},\n\t\t// > ...\n\t\t// Define is a control line starting with '>' followed by a word, a space and a text.\n\t\t'define': {\n\t\t\tpattern: /^>.+/m,\n\t\t\talias: 'tag',\n\t\t\tinside: {\n\t\t\t\t'value': {\n\t\t\t\t\tpattern: /(^>\\w+[\\t ]+)(?!\\s)[^{}\\r\\n]+/,\n\t\t\t\t\tlookbehind: true,\n\t\t\t\t\talias: 'operator'\n\t\t\t\t},\n\t\t\t\t'key': {\n\t\t\t\t\tpattern: /(^>)\\w+/,\n\t\t\t\t\tlookbehind: true,\n\t\t\t\t}\n\t\t\t}\n\t\t},\n\t\t// # ...\n\t\t'label': {\n\t\t\tpattern: /^([\\t ]*)#[\\t ]*\\w+[\\t ]*$/m,\n\t\t\tlookbehind: true,\n\t\t\talias: 'regex'\n\t\t},\n\t\t'command': {\n\t\t\tpattern: /^([\\t ]*)@\\w+(?=[\\t ]|$).*/m,\n\t\t\tlookbehind: true,\n\t\t\talias: 'function',\n\t\t\tinside: {\n\t\t\t\t'command-name': /^@\\w+/,\n\t\t\t\t'expression': {\n\t\t\t\t\tpattern: expressionDef,\n\t\t\t\t\tgreedy: true,\n\t\t\t\t\talias: 'selector'\n\t\t\t\t},\n\t\t\t\t'command-params': {\n\t\t\t\t\tpattern: /\\s*\\S[\\s\\S]*/,\n\t\t\t\t\tinside: params\n\t\t\t\t},\n\t\t\t}\n\t\t},\n\t\t// Generic is any line that doesn't start with operators: ;>#@\n\t\t'generic-text': {\n\t\t\tpattern: /(^[ \\t]*)[^#@>;\\s].*/m,\n\t\t\tlookbehind: true,\n\t\t\talias: 'punctuation',\n\t\t\tinside: {\n\t\t\t\t// \\{ ... \\} ... \\[ ... \\] ... \\\"\n\t\t\t\t'escaped-char': /\\\\[{}\\[\\]\"]/,\n\t\t\t\t'expression': {\n\t\t\t\t\tpattern: expressionDef,\n\t\t\t\t\tgreedy: true,\n\t\t\t\t\talias: 'selector'\n\t\t\t\t},\n\t\t\t\t'inline-command': {\n\t\t\t\t\tpattern: /\\[[\\t ]*\\w[^\\r\\n\\[\\]]*\\]/,\n\t\t\t\t\tgreedy: true,\n\t\t\t\t\talias: 'function',\n\t\t\t\t\tinside: {\n\t\t\t\t\t\t'command-params': {\n\t\t\t\t\t\t\tpattern: /(^\\[[\\t ]*\\w+\\b)[\\s\\S]+(?=\\]$)/,\n\t\t\t\t\t\t\tlookbehind: true,\n\t\t\t\t\t\t\tinside: params\n\t\t\t\t\t\t},\n\t\t\t\t\t\t'command-param-name': {\n\t\t\t\t\t\t\tpattern: /^(\\[[\\t ]*)\\w+/,\n\t\t\t\t\t\t\tlookbehind: true,\n\t\t\t\t\t\t\talias: 'name',\n\t\t\t\t\t\t},\n\t\t\t\t\t\t'start-stop-char': /[\\[\\]]/,\n\t\t\t\t\t}\n\t\t\t\t},\n\t\t\t}\n\t\t}\n\t};\n\tPrism.languages.nani = Prism.languages['naniscript'];\n\n\t/** @typedef {InstanceType<import(\"./prism-core\")[\"Token\"]>} Token */\n\n\t/**\n\t * This hook is used to validate generic-text tokens for balanced brackets.\n\t * Mark token as bad-line when contains not balanced brackets: {},[]\n\t */\n\tPrism.hooks.add('after-tokenize', function (env) {\n\t\t/** @type {(Token | string)[]} */\n\t\tvar tokens = env.tokens;\n\t\ttokens.forEach(function (token) {\n\t\t\tif (typeof token !== 'string' && token.type === 'generic-text') {\n\t\t\t\tvar content = getTextContent(token);\n\t\t\t\tif (!isBracketsBalanced(content)) {\n\t\t\t\t\ttoken.type = 'bad-line';\n\t\t\t\t\ttoken.content = content;\n\t\t\t\t}\n\t\t\t}\n\t\t});\n\t});\n\n\t/**\n\t * @param {string} input\n\t * @returns {boolean}\n\t */\n\tfunction isBracketsBalanced(input) {\n\t\tvar brackets = '[]{}';\n\t\tvar stack = [];\n\t\tfor (var i = 0; i < input.length; i++) {\n\t\t\tvar bracket = input[i];\n\t\t\tvar bracketsIndex = brackets.indexOf(bracket);\n\t\t\tif (bracketsIndex !== -1) {\n\t\t\t\tif (bracketsIndex % 2 === 0) {\n\t\t\t\t\tstack.push(bracketsIndex + 1);\n\t\t\t\t} else if (stack.pop() !== bracketsIndex) {\n\t\t\t\t\treturn false;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\treturn stack.length === 0;\n\t}\n\n\t/**\n\t * @param {string | Token | (string | Token)[]} token\n\t * @returns {string}\n\t */\n\tfunction getTextContent(token) {\n\t\tif (typeof token === 'string') {\n\t\t\treturn token;\n\t\t} else if (Array.isArray(token)) {\n\t\t\treturn token.map(getTextContent).join('');\n\t\t} else {\n\t\t\treturn getTextContent(token.content);\n\t\t}\n\t}\n\n}(Prism));\n"],"mappings":"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"},"metadata":{},"sourceType":"script"}